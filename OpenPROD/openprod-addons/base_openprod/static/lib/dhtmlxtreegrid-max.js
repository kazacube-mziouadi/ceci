/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* dhtmlx.com */

if (typeof(window.dhx) == "undefined") {
	
	window.dhx = window.dhx4 = {
		
		version: "5.0.2",
		
		skin: null, // allow to be set by user
		
		skinDetect: function(comp) {
			var i = Math.floor(dhx4.readFromCss(comp+"_skin_detect")/10)*10;
			return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace",40:"material"}[i]||null;
		},
		
		// read value from css
		readFromCss: function(className, property, innerHTML) {
			var t = document.createElement("DIV");
			t.className = className;
			if (document.body.firstChild != null) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
			if (typeof(innerHTML) == "string") t.innerHTML = innerHTML;
			var w = t[property||"offsetWidth"];
			t.parentNode.removeChild(t);
			t = null;
			return w;
		},
		
		// id manager
		lastId: 1,
		newId: function() {
			return this.lastId++;
		},
		
		// z-index manager
		zim: {
			data: {},
			step: 5,
			first: function() {
				return 100;
			},
			last: function() {
				var t = this.first();
				for (var a in this.data) t = Math.max(t, this.data[a]);
				return t;
			},
			reserve: function(id) {
				this.data[id] = this.last()+this.step;
				return this.data[id];
			},
			clear: function(id) {
				if (this.data[id] != null) {
					this.data[id] = null;
					delete this.data[id];
				}
			}
		},
		
		// string to boolean
		s2b: function(r) {
			if (typeof(r) == "string") r = r.toLowerCase();
			return (r == true || r == 1 || r == "true" || r == "1" || r == "yes" || r == "y" || r == "on");
		},
		
		// string to json
		s2j: function(s) {
			var obj = null;
			dhx4.temp = null;
			try { eval("dhx4.temp="+s); } catch(e) { dhx4.temp = null; }
			obj = dhx4.temp;
			dhx4.temp = null;
			return obj;
		},
		
		// absolute top/left position on screen
		absLeft: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).left;
		},
		absTop: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).top;
		},
		_aOfs: function(elem) {
			var top = 0, left = 0;
			while (elem) {
				top = top + parseInt(elem.offsetTop);
				left = left + parseInt(elem.offsetLeft);
				elem = elem.offsetParent;
			}
			return {top: top, left: left};
		},
		_aOfsRect: function(elem) {
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { top: Math.round(top), left: Math.round(left) };
		},
		getOffset: function(elem) {
			if (elem.getBoundingClientRect) {
				return this._aOfsRect(elem);
			} else {
				return this._aOfs(elem);
			}
		},
		
		// copy obj
		_isObj: function(k) {
			return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
		},
		_copyObj: function(r) {
			if (this._isObj(r)) {
				var t = {};
				for (var a in r) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			} else {
				var t = [];
				for (var a=0; a<r.length; a++) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			}
			return t;
		},
		
		// screen dim
		screenDim: function() {
			var isIE = (navigator.userAgent.indexOf("MSIE") >= 0);
			var dim = {};
			dim.left = document.body.scrollLeft;
			dim.right = dim.left+(window.innerWidth||document.body.clientWidth);
			dim.top = Math.max((isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			dim.bottom = dim.top+(isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0):window.innerHeight);
			return dim;
		},
		
		// input/textarea range selection
		selectTextRange: function(inp, start, end) {
			
			inp = (typeof(inp)=="string"?document.getElementById(inp):inp);
			
			var len = inp.value.length;
			start = Math.max(Math.min(start, len), 0);
			end = Math.min(end, len);
			
			if (inp.setSelectionRange) {
				try {inp.setSelectionRange(start, end);} catch(e){}; // combo in grid under IE requires try/catch
			} else if (inp.createTextRange) {
				var range = inp.createTextRange();
				range.moveStart("character", start);
				range.moveEnd("character", end-len);
				try {range.select();} catch(e){};
			}
		},
		// transition
		transData: null,
		transDetect: function() {
			
			if (this.transData == null) {
				
				this.transData = {transProp: false, transEv: null};
				
				// transition, MozTransition, WebkitTransition, msTransition, OTransition
				var k = {
					"MozTransition": "transitionend",
					"WebkitTransition": "webkitTransitionEnd",
					"OTransition": "oTransitionEnd",
					"msTransition": "transitionend",
					"transition": "transitionend"
				};
				
				for (var a in k) {
					if (this.transData.transProp == false && document.documentElement.style[a] != null) {
						this.transData.transProp = a;
						this.transData.transEv = k[a];
					}
				}
				k = null;
			}
			
			return this.transData;
			
		},
		
		// xml parser
		_xmlNodeValue: function(node) {
			var value = "";
			for (var q=0; q<node.childNodes.length; q++) {
				value += (node.childNodes[q].nodeValue!=null?node.childNodes[q].nodeValue.toString().replace(/^[\n\r\s]{0,}/,"").replace(/[\n\r\s]{0,}$/,""):"");
			}
			return value;
		}
		
	};
	
	// browser
	window.dhx4.isIE = (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE6 = (window.XMLHttpRequest == null && navigator.userAgent.indexOf("MSIE") >= 0);
	window.dhx4.isIE7 = (navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0);
	window.dhx4.isIE8 = (navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE9 = (navigator.userAgent.indexOf("MSIE 9.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE10 = (navigator.userAgent.indexOf("MSIE 10.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled != true);
	window.dhx4.isIE11 = (navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled == true);
	window.dhx4.isEdge = (navigator.userAgent.indexOf("Edge") >= 0);
	window.dhx4.isOpera = (navigator.userAgent.indexOf("Opera") >= 0);
	window.dhx4.isChrome = (navigator.userAgent.indexOf("Chrome") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isKHTML = (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isFF = (navigator.userAgent.indexOf("Firefox") >= 0);
	window.dhx4.isIPad = (navigator.userAgent.search(/iPad/gi) >= 0);
	
	// dnd data
	window.dhx4.dnd = {
		evs: {},
		p_en: ((window.dhx4.isIE || window.dhx4.isEdge) && (window.navigator.pointerEnabled || window.navigator.msPointerEnabled)), // touch/pointer
		_mTouch: function(e) {
			// mouse touch type in ie10/11/Edge
			return (window.dhx4.isIE10 && e.pointerType == e.MSPOINTER_TYPE_MOUSE || window.dhx4.isIE11 && e.pointerType == "mouse" || window.dhx4.isEdge && e.pointerType == "mouse");
		},
		_touchOn: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "";
			obj = null;
		},
		_touchOff: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "none";
			obj = null;
		}
	};
	
	// dnd events
	if (window.navigator.pointerEnabled == true) { // edge/ie11
		window.dhx4.dnd.evs = {start: "pointerdown", move: "pointermove", end: "pointerup"};
	} else if (window.navigator.msPointerEnabled == true) { // ie10-
		window.dhx4.dnd.evs = {start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp"};
	} else if (typeof(window.addEventListener) != "undefined") { // rest touch devices
		window.dhx4.dnd.evs = {start: "touchstart", move: "touchmove", end: "touchend"};
	};
	
};

if (typeof(window.dhx4.template) == "undefined") {
	
	// trim
	window.dhx4.trim = function(t) {
		return String(t).replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
	};
	
	// template parsing
	window.dhx4.template = function(tpl, data, trim) {
		
		// tpl - template text, #value|func:param0:param1:paramX#
		// data - object with key-value
		// trim - true/false, trim values
		return tpl.replace(/#([a-z0-9_-]{1,})(\|([^#]*))?#/gi, function(){
			
			var key = arguments[1];
			
			var t = window.dhx4.trim(arguments[3]);
			var func = null;
			var args = [data[key]];
			
			if (t.length > 0) {
				
				t = t.split(":");
				var k = [];
				
				// check escaped colon
				for (var q=0; q<t.length; q++) {
					if (q > 0 && k[k.length-1].match(/\\$/) != null) {
						k[k.length-1] = k[k.length-1].replace(/\\$/,"")+":"+t[q];
					} else {
						k.push(t[q]);
					}
				}
				
				func = k[0];
				for (var q=1; q<k.length; q++) args.push(k[q]);
				
			}
			
			// via inner function
			if (typeof(func) == "string" && typeof(window.dhx4.template[func]) == "function") {
				return window.dhx4.template[func].apply(window.dhx4.template, args);
			}
			
			// value only
			if (key.length > 0 && typeof(data[key]) != "undefined") {
				if (trim == true) return window.dhx4.trim(data[key]);
				return String(data[key]);
			}
			
			// key not found
			return "";
			
		});
		
	};
	
	window.dhx4.template.date = function(value, format) {
		// Date obj + format	=> convert to string
		// timestamp + format	=> convert to string
		// string		=> no convert
		// any other value	=> empty string
		if (value != null) {
			if (value instanceof Date) {
				return window.dhx4.date2str(value, format);
			} else {
				value = value.toString();
				if (value.match(/^\d*$/) != null) return window.dhx4.date2str(new Date(parseInt(value)), format);
				return value;
			}
		}
		return "";
	};
	
	window.dhx4.template.maxlength = function(value, limit) {
		return String(value).substr(0, limit);
	};
	
	window.dhx4.template.number_format = function(value, format, group_sep, dec_sep) {
		var fmt = window.dhx4.template._parseFmt(format, group_sep, dec_sep);
		if (fmt == false) return value;
		return window.dhx4.template._getFmtValue(value, fmt);
	};
	
	window.dhx4.template.lowercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toLowerCase();
	};
	window.dhx4.template.uppercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toUpperCase();
	};
	
	// number format helpers
	window.dhx4.template._parseFmt = function(format, group_sep, dec_sep) {
		
		var t = format.match(/^([^\.\,0-9]*)([0\.\,]*)([^\.\,0-9]*)/);
		if (t == null || t.length != 4) return false; // invalid format
		
		var fmt = {
			// int group
			i_len: false,
			i_sep: (typeof(group_sep)=="string"?group_sep:","),
			// decimal
			d_len: false,
			d_sep: (typeof(dec_sep)=="string"?dec_sep:"."),
			// chars before and after
			s_bef: (typeof(t[1])=="string"?t[1]:""),
			s_aft: (typeof(t[3])=="string"?t[3]:"")
		};
		
		var f = t[2].split(".");
		if (f[1] != null) fmt.d_len = f[1].length;
		
		var r = f[0].split(",");
		if (r.length > 1) fmt.i_len = r[r.length-1].length;
		
		return fmt;
		
	};
	
	window.dhx4.template._getFmtValue = function(value, fmt) {
		
		var r = String(value).match(/^(-)?([0-9]{1,})(\.([0-9]{1,}))?$/); // r = [complete value, minus sign, integer, full decimal, decimal]
		
		if (r != null && r.length == 5) {
			var v0 = "";
			// minus sign
			if (r[1] != null) v0 += r[1];
			// chars before
			v0 += fmt.s_bef;
			// int part
			if (fmt.i_len !== false) {
				var i = 0; var v1 = "";
				for (var q=r[2].length-1; q>=0; q--) {
					v1 = ""+r[2].charAt(q)+v1;
					if (++i == fmt.i_len && q > 0) { v1=fmt.i_sep+v1; i=0; }
				}
				v0 += v1;
			} else {
				v0 += r[2];
			}
			// dec part
			if (fmt.d_len !== false) {
				if (r[4] == null) r[4] = "";
				while (r[4].length < fmt.d_len) r[4] += "0";
				eval("dhx4.temp = new RegExp(/\\d{"+fmt.d_len+"}/);");
				var t1 = (r[4]).match(dhx4.temp);
				if (t1 != null) v0 += fmt.d_sep+t1;
				dhx4.temp = t1 = null;
			}
			// chars after
			v0 += fmt.s_aft;
			
			return v0;
		}
		
		return value;
	};
	
};

if (typeof(window.dhx4.dateLang) == "undefined") {
	
	window.dhx4.dateLang = "en";
	window.dhx4.dateStrings = {
		en: {
			monthFullName:	["January","February","March","April","May","June","July","August","September","October","November","December"],
			monthShortName:	["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
			dayFullName:	["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
			dayShortName:	["Su","Mo","Tu","We","Th","Fr","Sa"]
		}
	};
	window.dhx4.dateFormat = {
		en: "%Y-%m-%d"
	};
	
	window.dhx4.date2str = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		if (val instanceof Date) {
			var z = function(t) {
				return (String(t).length==1?"0"+String(t):t);
			}
			var k = function(t) {
				switch(t) {
					case "%d": return z(val.getDate());
					case "%j": return val.getDate();
					case "%D": return strings.dayShortName[val.getDay()];
					case "%l": return strings.dayFullName[val.getDay()];
					case "%m": return z(val.getMonth()+1);
					case "%n": return val.getMonth()+1;
					case "%M": return strings.monthShortName[val.getMonth()];
					case "%F": return strings.monthFullName[val.getMonth()];
					case "%y": return z(val.getYear()%100);
					case "%Y": return val.getFullYear();
					case "%g": return (val.getHours()+11)%12+1;
					case "%h": return z((val.getHours()+11)%12+1);
					case "%G": return val.getHours();
					case "%H": return z(val.getHours());
					case "%i": return z(val.getMinutes());
					case "%s": return z(val.getSeconds());
					case "%a": return (val.getHours()>11?"pm":"am");
					case "%A": return (val.getHours()>11?"PM":"AM");
					case "%%": return "%";
					case "%u": return val.getMilliseconds();
					case "%P":
						if (window.dhx4.temp_calendar != null && window.dhx4.temp_calendar.tz != null) return window.dhx4.temp_calendar.tz;
						var ofs = val.getTimezoneOffset();
						var h = Math.abs(Math.floor(ofs/60));
						var m = Math.abs(ofs)-h*60;
						return (ofs>0?"-":"+")+z(h)+":"+z(m);
					default: return t;
				}
			}
			var t = String(format||window.dhx4.dateFormat).replace(/%[a-zA-Z]/g, k);
		}
		
		return (t||String(val));
		
	};
	
	window.dhx4.str2date = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		// escape custom chars
		format = format.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\\:|]/g, "\\$&");
		
		var v = [];
		var f = [];
		
		// escape required chars
		format = format.replace(/%[a-z]/gi, function(t){
			switch (t) {
				case "%d": case "%m": case "%y": case "%h": case "%H": case "%i": case "%s": f.push(t); return "(\\d{2})"; // 2 digits
				case "%D": case "%l": case "%M": case "%F": f.push(t); return "([a-zéûä\u0430-\u044F\u0451]{1,})"; // chars
				case "%j": case "%n": case "%g": case "%G": f.push(t); return "(\\d{1,2})"; // 1-2 digits
				case "%Y": f.push(t); return "(\\d{4})"; // 4 digits
				case "%a": f.push(t); return "([a|p]m)"; // am/pm
				case "%A": f.push(t); return "([A|P]M)"; // AM/PM
				case "%u": f.push(t); return "(\\d{1,6})"; // 1-6 digits, micro/milliseconds
				case "%P": f.push(t); return "([+-]\\d{1,2}:\\d{1,2})"; // zone offset
			}
			return t;
		});
		
		var re = new RegExp(format, "i");
		var e = val.match(re);
		
		if (e == null || e.length-1 != f.length) return "Invalid Date";
		
		// sorting
		/*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		MSec	u	7
		Zone 	P	7
		*/
		
		for (var q=1; q<e.length; q++) v.push(e[q]);
		
		var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7,"%u":7,"%P":7};
		var v2 = {};
		var f2 = {};
		for (var q=0; q<f.length; q++) {
			if (typeof(p[f[q]]) != "undefined") {
				var ind = p[f[q]];
				if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
				v2[ind].push(v[q]);
				f2[ind].push(f[q]);
			}
		}
		v = [];
		f = [];
		for (var q=1; q<=7; q++) {
			if (v2[q] != null) {
				for (var w=0; w<v2[q].length; w++) {
					v.push(v2[q][w]);
					f.push(f2[q][w]);
				}
			}
		}
		
		// parsing date
		var r = new Date();
		r.setDate(1); // fix for 31th
		r.setHours(0);
		r.setMinutes(0);
		r.setSeconds(0);
		r.setMilliseconds(0);
		
		// get index by value
		var getInd = function(val, ar) {
			for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
			return -1;
		}
		
		for (var q=0; q<v.length; q++) {
			switch (f[q]) {
				case "%d": case "%j": case "%n": case "%m": case "%Y": case "%H": case "%G": case "%i": case "%s": case "%u":
					if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds","%u":"setMilliseconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
					break;
				//
				case "%M": case "%F":
					var k = getInd(v[q].toLowerCase(),strings[{"%M":"monthShortName","%F":"monthFullName"}[f[q]]]);
					if (k >= 0) r.setMonth(k);
					break;
				//
				case "%y":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						r.setFullYear(v0+(v0>50?1900:2000));
					}
					break;
				//
				case "%g": case "%h":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						if (v0 <= 12 && v0 >= 0) r.setHours(v0+(getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0))); // 12:00 AM -> midnight, 12:00 PM -> noon
					}
					break;
				//
				case "%P":
					if (window.dhx4.temp_calendar != null) {
						window.dhx4.temp_calendar.tz = v[q];
					}
					break;
			}
		}
		return r;
	};
	
};

if (typeof(window.dhx4.ajax) == "undefined") {
	
	window.dhx4.ajax = {
		
		// if false - dhxr param will added to prevent caching on client side (default),
		// if true - do not add extra params
		cache: false,
		
		// default method for load/loadStruct, post/get allowed
		// get - since 4.1.1, this should fix 412 error for macos safari
		method: "get",
		
		parse: function(data) {
			if (typeof data !== "string") return data;
			
			data = data.replace(/^[\s]+/,"");
			if (window.DOMParser && !dhx4.isIE) { // ff,ie9
				var obj = (new window.DOMParser()).parseFromString(data, "text/xml");
			} else if (window.ActiveXObject !== window.undefined) {
				var obj = new window.ActiveXObject("Microsoft.XMLDOM");
				obj.async = "false";
				obj.loadXML(data);
			}
			return obj;
		},
		xmltop: function(tagname, xhr, obj) {
			if (typeof xhr.status == "undefined" || xhr.status < 400) {
				xml = (!xhr.responseXML) ? dhx4.ajax.parse(xhr.responseText || xhr) : (xhr.responseXML || xhr);
				if (xml && xml.documentElement !== null) {
					try {
						if (!xml.getElementsByTagName("parsererror").length)
							return xml.getElementsByTagName(tagname)[0];
					} catch(e){}
				}
			}
			if (obj !== -1) dhx4.callEvent("onLoadXMLError",["Incorrect XML", arguments[1], obj]);
			return document.createElement("DIV");
		},
		xpath: function(xpathExp, docObj) {
			if (!docObj.nodeName) docObj = docObj.responseXML || docObj;
			if (dhx4.isIE) {
				try {
					return docObj.selectNodes(xpathExp)||[];
				} catch(e){ return []; }
			} else {
				var rows = [];
				var first;
				var col = (docObj.ownerDocument||docObj).evaluate(xpathExp, docObj, null, XPathResult.ANY_TYPE, null);
				while (first = col.iterateNext()) rows.push(first);
				return rows;
			}
		},
		query: function(config) {
			dhx4.ajax._call(
				(config.method || "GET"),
				config.url,
				config.data || "",
				(config.async || true),
				config.callback,
				null,
				config.headers
			);
		},
		get: function(url, onLoad) {
			return this._call("GET", url, null, true, onLoad);
		},
		getSync: function(url) {
			return this._call("GET", url, null, false);
		},
		put: function(url, postData, onLoad) {
			return this._call("PUT", url, postData, true, onLoad);
		},
		del: function(url, postData, onLoad) {
			return this._call("DELETE", url, postData, true, onLoad);
		},
		post: function(url, postData, onLoad) {
			if (arguments.length == 1) {
				postData = "";
			} else if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]) == "function")) {
				onLoad = postData;
				postData = "";
			} else {
				postData = String(postData);
			}
			return this._call("POST", url, postData, true, onLoad);
		},
		postSync: function(url, postData) {
			postData = (postData == null ? "" : String(postData));
			return this._call("POST", url, postData, false);
		},
		getLong: function(url, onLoad) {
			this._call("GET", url, null, true, onLoad, {url:url});
		},
		postLong: function(url, postData, onLoad) {
			if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]))) {
				onLoad = postData;
				postData = "";
			}
			this._call("POST", url, postData, true, onLoad, {url:url, postData:postData});
		},
		_call: function(method, url, postData, async, onLoad, longParams, headers) {
			
			var t = (window.XMLHttpRequest && !dhx4.isIE ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
			var isQt = (navigator.userAgent.match(/AppleWebKit/) != null && navigator.userAgent.match(/Qt/) != null && navigator.userAgent.match(/Safari/) != null);
			
			if (async == true) {
				t.onreadystatechange = function() {
					if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) { // what for long response and status 404?
						if (t.status != 200 || t.responseText == "")
							if (!dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}])) return;

						window.setTimeout(function(){
							if (typeof(onLoad) == "function") {
								onLoad.apply(window, [{xmlDoc:t, filePath:url, async:async}]); // dhtmlx-compat, response.xmlDoc.responseXML/responseText
							}
							if (longParams != null) {
								if (typeof(longParams.postData) != "undefined") {
									dhx4.ajax.postLong(longParams.url, longParams.postData, onLoad);
								} else {
									dhx4.ajax.getLong(longParams.url, onLoad);
								}
							}
							onLoad = null;
							t = null;
						},1);
					}
				}
			}
			
			if (method == "GET") {
				url += this._dhxr(url);
			}
			
			t.open(method, url, async);
			
			if (headers != null) {
				for (var key in headers) t.setRequestHeader(key, headers[key]);
			} else if (method == "POST" || method == "PUT" || method == "DELETE") {
				t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			} else if (method == "GET") {
				postData = null;
			}
			
			t.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			
			t.send(postData);
			
			if (async != true) {
				if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) {
					if (t.status != 200 || t.responseText == "") dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}]);
				}
			}
			
			return {xmlDoc:t, filePath:url, async:async}; // dhtmlx-compat, response.xmlDoc.responseXML/responseText
			
		},
		
		_dhxr: function(sign, value) {
			if (this.cache != true) {
				if (sign.match(/^[\?\&]$/) == null) sign = (sign.indexOf("?")>=0?"&":"?");
				if (typeof(value) == "undefined") value = true;
				return sign+"dhxr"+new Date().getTime()+(value==true?"=1":"");
			}
			return "";
		}
	};
	
};

if (typeof(window.dhx4._enableDataLoading) == "undefined") {
	
	window.dhx4._enableDataLoading = function(obj, initObj, xmlToJson, xmlRootTag, mode) {
		
		if (mode == "clear") {
			
			// clear attached functionality
			
			for (var a in obj._dhxdataload) {
				obj._dhxdataload[a] = null;
				delete obj._dhxdataload[a];
			};
			
			obj._loadData = null;
			obj._dhxdataload = null;
			obj.load = null;
			obj.loadStruct = null;
			
			obj = null;
			
			return;
			
		}
		
		obj._dhxdataload = { // move to obj.conf?
			initObj: initObj,
			xmlToJson: xmlToJson,
			xmlRootTag: xmlRootTag,
			onBeforeXLS: null
		};
		
		obj._loadData = function(data, loadParams, onLoad) {
			
			if (arguments.length == 2) {
				onLoad = loadParams;
				loadParams = null;
			}
			
			var obj = null;
			
			// deprecated from 4.0, compatability with version (url, type[json|xml], onLoad)
			if (arguments.length == 3) onLoad = arguments[2];
			
			if (typeof(data) == "string") {
				
				var k = data.replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
				
				var tag = new RegExp("^<"+this._dhxdataload.xmlRootTag);
				
				// xml
				if (tag.test(k.replace(/^<\?xml[^\?]*\?>\s*/, ""))) { // remove leading <?xml ...?> if any, \n can be also present
					obj = dhx4.ajax.parse(data);
					if (obj != null) obj = this[this._dhxdataload.xmlToJson].apply(this, [obj]); // xml to json
				}
				
				if (obj == null && (k.match(/^[\s\S]*{[.\s\S]*}[\s\S]*$/) != null || k.match(/^[\s\S]*\[[.\s\S]*\][\s\S]*$/) != null)) { // check for '{...}' or '[...]', cut leading/trailing \n\r with \s\S
					obj = dhx4.s2j(k);
				}
				
				if (obj == null) {
					
					this.callEvent("onXLS",[]);
					
					var params = [];
					
					// allow to modify url and add params
					if (typeof(this._dhxdataload.onBeforeXLS) == "function") {
						var k = this._dhxdataload.onBeforeXLS.apply(this,[data]);
						if (k != null && typeof(k) == "object") {
							if (k.url != null) data = k.url;
							if (k.params != null) { for (var a in k.params) params.push(a+"="+encodeURIComponent(k.params[a])); }
						}
					}
					
					var t = this;
					var callBack = function(r) {
						
						var obj = null;
						
						if ((r.xmlDoc.getResponseHeader("Content-Type")||"").search(/xml/gi) >= 0 || (r.xmlDoc.responseText.replace(/^\s{1,}/,"")).match(/^</) != null) {
							obj = t[t._dhxdataload.xmlToJson].apply(t,[r.xmlDoc.responseXML]);
						} else {
							obj = dhx4.s2j(r.xmlDoc.responseText);
						}
						
						// init
						if (obj != null) t[t._dhxdataload.initObj].apply(t,[obj,data]); // data => url
						
						t.callEvent("onXLE",[]);
						
						if (onLoad != null) {
							if (typeof(onLoad) == "function") {
								onLoad.apply(t,[]);
							} else if (typeof(window[onLoad]) == "function") {
								window[onLoad].apply(t,[]);
							}
						}
						
						callBack = onLoad = null;
						obj = r = t = null;
						
					};
					
					params = params.join("&")+(typeof(loadParams)=="string"?"&"+loadParams:"");
					
					if (dhx4.ajax.method == "post") {
						dhx4.ajax.post(data, params, callBack);
					} else if (dhx4.ajax.method == "get") {
						dhx4.ajax.get(data+(params.length>0?(data.indexOf("?")>0?"&":"?")+params:""), callBack);
					}
					
					return;
				}
				
			} else {
				if (typeof(data.documentElement) == "object" || (typeof(data.tagName) != "undefined" && typeof(data.getElementsByTagName) != "undefined" && data.getElementsByTagName(this._dhxdataload.xmlRootTag).length > 0)) { // xml
					obj = this[this._dhxdataload.xmlToJson].apply(this, [data]);
				} else { // json
					obj = window.dhx4._copyObj(data);
				}
				
			}
			
			// init
			if (obj != null) this[this._dhxdataload.initObj].apply(this,[obj]);
			
			if (onLoad != null) {
				if (typeof(onLoad) == "function") {
					onLoad.apply(this, []);
				} else if (typeof(window[onLoad]) == "function") {
					window[onLoad].apply(this, []);
				}
				onLoad = null;
			}
			
		};
		
		// loadStruct for hdr/conf
		// load for data
		if (mode != null) {
			var k = {struct: "loadStruct", data: "load"};
			for (var a in mode) {
				if (mode[a] == true) obj[k[a]] = function() {return this._loadData.apply(this, arguments);}
			}
		}
		
		obj = null;
		
	};
};

if (typeof(window.dhx4._eventable) == "undefined") {
	
	window.dhx4._eventable = function(obj, mode) {
		
		if (mode == "clear") {
			
			obj.detachAllEvents();
			
			obj.dhxevs = null;
			
			obj.attachEvent = null;
			obj.detachEvent = null;
			obj.checkEvent = null;
			obj.callEvent = null;
			obj.detachAllEvents = null;
			
			obj = null;
			
			return;
			
		}
		
		obj.dhxevs = { data: {} };
		
		obj.attachEvent = function(name, func) {
			name = String(name).toLowerCase();
			if (!this.dhxevs.data[name]) this.dhxevs.data[name] = {};
			var eventId = window.dhx4.newId();
			this.dhxevs.data[name][eventId] = func;
			return eventId;
		}
		
		obj.detachEvent = function(eventId) {
			for (var a in this.dhxevs.data) {
				var k = 0;
				for (var b in this.dhxevs.data[a]) {
					if (b == eventId) {
						this.dhxevs.data[a][b] = null;
						delete this.dhxevs.data[a][b];
					} else {
						k++;
					}
				}
				if (k == 0) {
					this.dhxevs.data[a] = null;
					delete this.dhxevs.data[a];
				}
			}
		}
		
		obj.checkEvent = function(name) {
			name = String(name).toLowerCase();
			return (this.dhxevs.data[name] != null);
		}
		
		obj.callEvent = function(name, params) {
			name = String(name).toLowerCase();
			if (this.dhxevs.data[name] == null) return true;
			var r = true;
			for (var a in this.dhxevs.data[name]) {
				r = this.dhxevs.data[name][a].apply(this, params) && r;
			}
			return r;
		}
		
		obj.detachAllEvents = function() {
			for (var a in this.dhxevs.data) {
				for (var b in this.dhxevs.data[a]) {
					this.dhxevs.data[a][b] = null;
					delete this.dhxevs.data[a][b];
				}
				this.dhxevs.data[a] = null;
				delete this.dhxevs.data[a];
			}
		}
		
		obj = null;
	};
	
	dhx4._eventable(dhx4);
	
};

// validation
// all purpose set of rules, based on http://code.google.com/p/validation-js
if (!window.dhtmlxValidation) {
	dhtmlxValidation = function(){};
	dhtmlxValidation.prototype = {
		isEmpty: function(value) {
			return value == '';
		},
		isNotEmpty: function(value) {
			return (value instanceof Array?value.length>0:!value == ''); // array in case of multiselect
		},
		isValidBoolean: function(value) {
			return !!value.toString().match(/^(0|1|true|false)$/);
		},
		isValidEmail: function(value) {
			return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,5})$)/i);
		},
		isValidInteger: function(value) {
			return !!value.toString().match(/(^-?\d+$)/);
		},
		isValidNumeric: function(value) {
			return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
		},
		isValidAplhaNumeric: function(value) {
			return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
		},
		// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
		isValidDatetime: function(value) {
			var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
			return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
		},
		// 0000-00-00 to 9999-12-31
		isValidDate: function(value) {
			var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
			return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
		},
		// 00:00:00 to 59:59:59
		isValidTime: function(value) {
			var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
			return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
		},
		// 0.0.0.0 to 255.255.255.255
		isValidIPv4: function(value) { 
			var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
			return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
		},
		isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
			return value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
		},
		// Social Security Number (999-99-9999 or 999999999)
		isValidSSN: function(value) {
			return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
		},
		// Social Insurance Number (999999999)
		isValidSIN: function(value) {
			return value.toString().match(/^\d{9}$/) && true || false;
		}
	};
	dhtmlxValidation = new dhtmlxValidation();
};


if (typeof(window.dhtmlx) == "undefined") {
	window.dhtmlx={
		extend:function(a, b){
			for (var key in b)
				if (!a[key])
					a[key]=b[key];
			return a;
		},
		extend_api:function(name,map,ext){
			var t = window[name];
			if (!t) return; //component not defined
			window[name]=function(obj){
				if (obj && typeof obj == "object" && !obj.tagName){
					var that = t.apply(this,(map._init?map._init(obj):arguments));
					//global settings
					for (var a in dhtmlx)
						if (map[a]) this[map[a]](dhtmlx[a]);			
					//local settings
					for (var a in obj){
						if (map[a]) this[map[a]](obj[a]);
						else if (a.indexOf("on")===0){
							this.attachEvent(a,obj[a]);
						}
					}
				} else
					var that = t.apply(this,arguments);
				if (map._patch) map._patch(this);
				return that||this;
			};
			window[name].prototype=t.prototype;
			if (ext)
				dhtmlx.extend(window[name].prototype,ext);
		},
		url:function(str){
			if (str.indexOf("?") != -1)
				return "&";
			else
				return "?";
		}
	};
};

/**  
*     @desc: find out what symbol to use as url param delimiters in further params
*     @type: private
*     @param: str - current url string
*     @topic: 0  
*/


function dhtmlDragAndDropObject(){
	if (window.dhtmlDragAndDrop)
		return window.dhtmlDragAndDrop;

	this.lastLanding=0;
	this.dragNode=0;
	this.dragStartNode=0;
	this.dragStartObject=0;
	this.tempDOMU=null;
	this.tempDOMM=null;
	this.waitDrag=0;
	window.dhtmlDragAndDrop=this;

	return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
	htmlNode.onmousedown=null;
	htmlNode.dragStarter=null;
	htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
	htmlNode.onmousedown=this.preCreateDragCopy;
	htmlNode.dragStarter=dhtmlObject;
	this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
	htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
	if ((e||window.event) && (e||event).button == 2)
		return;

	if (window.dhtmlDragAndDrop.waitDrag){
		window.dhtmlDragAndDrop.waitDrag=0;
		document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
		document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
		return false;
	}
	
	if (window.dhtmlDragAndDrop.dragNode)
		window.dhtmlDragAndDrop.stopDrag(e);	

	window.dhtmlDragAndDrop.waitDrag=1;
	window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
	window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
	window.dhtmlDragAndDrop.dragStartNode=this;
	window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
	document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
	document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
	window.dhtmlDragAndDrop.downtime = new Date().valueOf();
	

	if ((e)&&(e.preventDefault)){
		e.preventDefault();
		return false;
	}
	return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
	if (!e)
		e=window.event;
	dragger=window.dhtmlDragAndDrop;
	if ((new Date()).valueOf()-dragger.downtime<100) return;

	//if ((e.button == 0)&&(_isIE))
	//	return dragger.stopDrag();

	if (!dragger.dragNode){
		if (dragger.waitDrag){
			dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);
	
			if (!dragger.dragNode)
				return dragger.stopDrag();
	
			dragger.dragNode.onselectstart=function(){return false;}
			dragger.gldragNode=dragger.dragNode;
			document.body.appendChild(dragger.dragNode);
			document.body.onmouseup=dragger.stopDrag;
			dragger.waitDrag=0;
			dragger.dragNode.pWindow=window;
			dragger.initFrameRoute();
		} 
		else return dragger.stopDrag(e, true);
	}

	if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
		var grd = dragger.gldragNode;

		if (dragger.gldragNode.old)
			grd=dragger.gldragNode.old;

		//if (!document.all) dragger.calculateFramePosition();
		grd.parentNode.removeChild(grd);
		var oldBody = dragger.dragNode.pWindow;

		if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
			grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);	
			
		//		var oldp=dragger.dragNode.parentObject;
		if (_isIE){
			var div = document.createElement("Div");
			div.innerHTML=dragger.dragNode.outerHTML;
			dragger.dragNode=div.childNodes[0];
		} else
			dragger.dragNode=dragger.dragNode.cloneNode(true);

		dragger.dragNode.pWindow=window;
		//		dragger.dragNode.parentObject=oldp;

		dragger.gldragNode.old=dragger.dragNode;
		document.body.appendChild(dragger.dragNode);
		oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
	}

	dragger.dragNode.style.left=e.clientX+15+(dragger.fx
		? dragger.fx*(-1)
		: 0)
		+(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
	dragger.dragNode.style.top=e.clientY+3+(dragger.fy
		? dragger.fy*(-1)
		: 0)
		+(document.body.scrollTop||document.documentElement.scrollTop)+"px";

	if (!e.srcElement)
		var z = e.target;
	else
		z=e.srcElement;
	dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
	//this.fx = 0, this.fy = 0;
	if (window.name){
		var el = parent.frames[window.name].frameElement.offsetParent;
		var fx = 0;
		var fy = 0;

		while (el){
			fx+=el.offsetLeft;
			fy+=el.offsetTop;
			el=el.offsetParent;
		}

		if ((parent.dhtmlDragAndDrop)){
			var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
			fx+=ls.split('_')[0]*1;
			fy+=ls.split('_')[1]*1;
		}

		if (n)
			return fx+"_"+fy;
		else
			this.fx=fx;
		this.fy=fy;
	}
	return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
	if ((htmlObject)&&(htmlObject.dragLanding)){
		if (this.lastLanding)
			this.lastLanding.dragLanding._dragOut(this.lastLanding);
		this.lastLanding=htmlObject;
		this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
			e.clientY, e);
		this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
	} else {
		if ((htmlObject)&&(htmlObject.tagName != "BODY"))
			this.checkLanding(htmlObject.parentNode, e);
		else {
			if (this.lastLanding)
				this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
			this.lastLanding=0;

			if (this._onNotFound)
				this._onNotFound();
		}
	}
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
	dragger=window.dhtmlDragAndDrop;

	if (!mode){
		dragger.stopFrameRoute();
		var temp = dragger.lastLanding;
		dragger.lastLanding=null;

		if (temp)
			temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
				? event.srcElement
				: e.target));
	}
	dragger.lastLanding=null;

	if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
		dragger.dragNode.parentNode.removeChild(dragger.dragNode);
	dragger.dragNode=0;
	dragger.gldragNode=0;
	dragger.fx=0;
	dragger.fy=0;
	dragger.dragStartNode=0;
	dragger.dragStartObject=0;
	document.body.onmouseup=dragger.tempDOMU;
	document.body.onmousemove=dragger.tempDOMM;
	dragger.tempDOMU=null;
	dragger.tempDOMM=null;
	dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
	if (win)
		window.dhtmlDragAndDrop.stopDrag(1, 1);

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
		} catch(e){}
	}

	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.stopFrameRoute(window);
	} catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
	if (win){
		window.dhtmlDragAndDrop.preCreateDragCopy();
		window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
		window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
		window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
		window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
		window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
		window.waitDrag=0;

		if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
			window.dhtmlDragAndDrop.calculateFramePosition();
	}
	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.initFrameRoute(window);
	}catch(e){}

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
		} catch(e){}
	}
}

 _isFF = false;
 _isIE = false;
 _isOpera = false;
 _isKHTML = false;
 _isMacOS = false;
 _isChrome = false;
 _FFrv = false;
 _KHTMLrv = false;
 _OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
	_isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
	_isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
	 _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

	if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
		_isFF=true;
		 _FFrv = 1.9;
	} else
		_isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
	_isOpera=true;
	_OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
	_isIE=true;
	if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 9.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
		 document.documentMode > 7) && 
			document.compatMode != "BackCompat"){
		_isIE=8;
	}
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
	//ie11
	_isIE=8;
} else {
	_isFF=true;
	 _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}

if (typeof(window.dhtmlxEvent) == "undefined") {
	
	function dhtmlxEvent(el, event, handler){
		if (el.addEventListener)
			el.addEventListener(event, handler, false);
	
		else if (el.attachEvent)
			el.attachEvent("on"+event, handler);
	}
};

if (dhtmlxEvent.touchDelay == null) {
	dhtmlxEvent.touchDelay = 2000;
};

if (typeof(dhtmlxEvent.initTouch) == "undefined") {
	
	dhtmlxEvent.initTouch = function(){
		var longtouch;
		var target;
		var tx, ty;
	
		dhtmlxEvent(document.body, "touchstart", function(ev){
			target = ev.touches[0].target;
			tx = ev.touches[0].clientX;
			ty = ev.touches[0].clientY;
			longtouch = window.setTimeout(touch_event, dhtmlxEvent.touchDelay);
		});
		function touch_event(){
			if (target){
				var ev = document.createEvent("HTMLEvents"); // for chrome and firefox
				ev.initEvent("dblclick", true, true);
				target.dispatchEvent(ev);
				longtouch = target = null;
			}
		};
		dhtmlxEvent(document.body, "touchmove", function(ev){
			if (longtouch){
				if (Math.abs(ev.touches[0].clientX - tx) > 50 || Math.abs(ev.touches[0].clientY - ty) > 50 ){
					window.clearTimeout(longtouch);
					longtouch = target = false;
				}
			}
		});
		dhtmlxEvent(document.body, "touchend", function(ev){
			if (longtouch){
				window.clearTimeout(longtouch);
				longtouch = target = false;
			}
		});
	
		dhtmlxEvent.initTouch = function(){};
	};
};

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
	* 	@desc: constructor, data processor object 
	*	@param: serverProcessorURL - url used for update
	*	@type: public
	*/
function dataProcessor(serverProcessorURL){
    this.serverProcessor = serverProcessorURL;
    this.action_param="!nativeeditor_status";
    
	this.object = null;
	this.updatedRows = []; //ids of updated rows
	
	this.autoUpdate = true;
	this.updateMode = "cell";
	this._tMode="GET"; 
	this._headers = null;
	this._payload = null;
	this.post_delim = "_";
	
    this._waitMode=0;
    this._in_progress={};//?
    this._invalid={};
    this.mandatoryFields=[];
    this.messages=[];
    
    this.styles={
    	updated:"font-weight:bold;",
    	inserted:"font-weight:bold;",
    	deleted:"text-decoration : line-through;",
    	invalid:"background-color:FFE0E0;",
    	invalid_cell:"border-bottom:2px solid red;",
    	error:"color:red;",
    	clear:"font-weight:normal;text-decoration:none;"
    };
    
    this.enableUTFencoding(true);
    dhx4._eventable(this);

    if (this.connector_init){
    	this.setTransactionMode("POST",true);
		this.serverProcessor+=(this.serverProcessor.indexOf("?")!=-1?"&":"?")+"editing=true";
	};

    return this;
    }

dataProcessor.prototype={
	url:function(str){
		if (str.indexOf("?") != -1)
			return "&";
		else
			return "?";
	},
	setTransactionMode:function(mode,total){
		if (typeof mode == "object"){
			this._tMode = mode.mode || this._tMode;
			this._headers = this._headers || mode.headers;
			this._payload = this._payload || mode.payload;
		} else {
     	    this._tMode=mode;
			this._tSend=total;
		}

		if (this._tMode == "REST"){
			this._tSend = false;
			this._endnm = true;
		}
    },
    escape:function(data){
    	if (this._utf)
    		return encodeURIComponent(data);
    	else
        	return escape(data);
	},
    /**
	* 	@desc: allows to set escaping mode
	*	@param: true - utf based escaping, simple - use current page encoding
	*	@type: public
	*/	
	enableUTFencoding:function(mode){
        this._utf=dhx4.s2b(mode);
    },
    /**
	* 	@desc: allows to define, which column may trigger update
	*	@param: val - array or list of true/false values
	*	@type: public
	*/
	setDataColumns:function(val){
		this._columns=(typeof val == "string")?val.split(","):val;
    },
    /**
	* 	@desc: get state of updating
	*	@returns:   true - all in sync with server, false - some items not updated yet.
	*	@type: public
	*/
	getSyncState:function(){
		return !this.updatedRows.length;
	},
	/**
	* 	@desc: enable/disable named field for data syncing, will use column ids for grid
	*	@param:   mode - true/false
	*	@type: public
	*/
	enableDataNames:function(mode){
		this._endnm=dhx4.s2b(mode);
	},
	/**
	* 	@desc: enable/disable mode , when only changed fields and row id send to the server side, instead of all fields in default mode
	*	@param:   mode - true/false
	*	@type: public
	*/
	enablePartialDataSend:function(mode){
		this._changed=dhx4.s2b(mode);
	},
	/**
	* 	@desc: set if rows should be send to server automaticaly
	*	@param: mode - "row" - based on row selection changed, "cell" - based on cell editing finished, "off" - manual data sending
	*	@type: public
	*/
	setUpdateMode:function(mode,dnd){
		this.autoUpdate = (mode=="cell");
		this.updateMode = mode;
		this.dnd=dnd;
	},
	ignore:function(code,master){
		this._silent_mode=true;
		code.call(master||window);
		this._silent_mode=false;
	},
	/**
	* 	@desc: mark row as updated/normal. check mandatory fields,initiate autoupdate (if turned on)
	*	@param: rowId - id of row to set update-status for
	*	@param: state - true for "updated", false for "not updated"
	*	@param: mode - update mode name
	*	@type: public
	*/
	setUpdated:function(rowId,state,mode){
		this._log("item "+rowId+" "+(state?"marked":"unmarked")+" ["+(mode||"updated")+"]");

		if (this._silent_mode) return;
		var ind=this.findRow(rowId);
		
		mode=mode||"updated";
		var existing = this.obj.getUserData(rowId,this.action_param);
		if (existing && mode == "updated") mode=existing;
		if (state){
			this.set_invalid(rowId,false); //clear previous error flag
			this.updatedRows[ind]=rowId;
			this.obj.setUserData(rowId,this.action_param,mode);
			if (this._in_progress[rowId]) 
				this._in_progress[rowId]="wait";
		} else{
			if (!this.is_invalid(rowId)){
				this.updatedRows.splice(ind,1);
				this.obj.setUserData(rowId,this.action_param,"");
			}
		}

		//clear changed flag
		if (!state)
			this._clearUpdateFlag(rowId);
     			
		this.markRow(rowId,state,mode);
		if (state && this.autoUpdate) this.sendData(rowId);
	},
	_clearUpdateFlag:function(id){},
	markRow:function(id,state,mode){ 
		var str="";
		var invalid=this.is_invalid(id);
		if (invalid){
        	str=this.styles[invalid];
        	state=true;
    	}
		if (this.callEvent("onRowMark",[id,state,mode,invalid])){
			//default logic
			str=this.styles[state?mode:"clear"]+str;
			
        	this.obj[this._methods[0]](id,str);

			if (invalid && invalid.details){
				str+=this.styles[invalid+"_cell"];
				for (var i=0; i < invalid.details.length; i++)
					if (invalid.details[i])
        				this.obj[this._methods[1]](id,i,str);
			}
		}
	},
	getState:function(id){
		return this.obj.getUserData(id,this.action_param);
	},
	is_invalid:function(id){
		return this._invalid[id];
	},
	set_invalid:function(id,mode,details){ 
		if (details) mode={value:mode, details:details, toString:function(){ return this.value.toString(); }};
		this._invalid[id]=mode;
	},
	/**
	* 	@desc: check mandatory fields and varify values of cells, initiate update (if specified)
	*	@param: rowId - id of row to set update-status for
	*	@type: public
	*/
	checkBeforeUpdate:function(rowId){ 
		return true;
	},
	/**
	* 	@desc: send row(s) values to server
	*	@param: rowId - id of row which data to send. If not specified, then all "updated" rows will be send
	*	@type: public
	*/
	sendData:function(rowId){
		if (rowId)
			this._log("Sending: "+rowId);

		if (this._waitMode && (this.obj.mytype=="tree" || this.obj._h2)) return;
		if (this.obj.editStop) this.obj.editStop();
	
		
		if(typeof rowId == "undefined" || this._tSend) return this.sendAllData();
		if (this._in_progress[rowId]) return false;
		
		this.messages=[];
		if (this.getState(rowId) !== "deleted")
			if (!this.checkBeforeUpdate(rowId) && this.callEvent("onValidationError",[rowId,this.messages])) return false;

		this._beforeSendData(this._getRowData(rowId),rowId);
    },
    _beforeSendData:function(data,rowId){
    	if (!this.callEvent("onBeforeUpdate",[rowId,this.getState(rowId),data])) return false;	
		this._sendData(data,rowId);
    },
    serialize:function(data, id){
    	if (typeof data == "string")
    		return data;
    	if (typeof id != "undefined")
    		return this.serialize_one(data,"");
    	else{
    		var stack = [];
    		var keys = [];
    		for (var key in data)
    			if (data.hasOwnProperty(key)){
    				stack.push(this.serialize_one(data[key],key+this.post_delim));
    				keys.push(key);
				}
    		stack.push("ids="+this.escape(keys.join(",")));
    		if (window.dhtmlx && dhtmlx.security_key)
				stack.push("dhx_security="+dhtmlx.security_key);
    		return stack.join("&");
    	}
    },
    serialize_one:function(data, pref){
    	if (typeof data == "string")
    		return data;
    	var stack = [];
    	for (var key in data)
    		if (data.hasOwnProperty(key)){
    			if ((key == "id" || key == this.action_param) && this._tMode == "REST") continue;
    			stack.push(this.escape((pref||"")+key)+"="+this.escape(data[key]));
    		}
		return stack.join("&");
    },
    _applyPayload:function(url){
    	if (this._payload)
      		for (var key in this._payload)
       			url = url + (url.indexOf("?") === -1 ? "?" : "&" ) + this.escape(key) + "=" + this.escape(this._payload[key]);
       	return url;
    },
    _sendData:function(a1,rowId){
    
    	this._log("url: "+this.serverProcessor);
    	this._log(a1)

    	if (!a1) return; //nothing to send
		if (!this.callEvent("onBeforeDataSending",rowId?[rowId,this.getState(rowId),a1]:[null, null, a1])) return false;				
		
    	if (rowId)
			this._in_progress[rowId]=(new Date()).valueOf();

		var that = this;
		var back = function(xml){
			var ids = [];
			if (rowId)
				ids.push(rowId);
			else if (a1)
				for (var key in a1)
					ids.push(key);

			return that.afterUpdate(that,xml,ids);
		};
		
		var a3 = this.serverProcessor+(this._user?(this.url(this.serverProcessor)+["dhx_user="+this._user,"dhx_version="+this.obj.getUserData(0,"version")].join("&")):"");
        var a4 = this._applyPayload(a3);

		if (this._tMode=="GET"){
	     	dhx4.ajax.query({
        		url:a4+((a4.indexOf("?")!=-1)?"&":"?")+this.serialize(a1,rowId),
        		method:"GET",
        		headers:this._headers,
        		callback:back
        	});
		}
		else if (this._tMode == "POST"){
			dhx4.ajax.query({
        		url:a4,
        		method:"POST",
        		headers:this._headers,
        		callback:back,
        		data:this.serialize(a1,rowId)
        	});
		}
        else if (this._tMode == "REST"){
        	var state = this.getState(rowId);
        	var url = a3.replace(/(\&|\?)editing\=true/,"");
        	var parts = url.split("?");
        	if (parts[1])
        		parts[1] = "?"+parts[1];

        	var data = "";
        	var method = "post";

        	if (state == "inserted"){
        		data = this.serialize(a1, rowId);
        	} else if (state == "deleted"){
        		method = "DELETE";
        		url = parts[0]+rowId+(parts[1]||"");
        	} else {
        		method = "PUT";
        		data = this.serialize(a1, rowId);
        		url = parts[0]+rowId+(parts[1]||"");
        	}

        	this._applyPayload(url);
        	dhx4.ajax.query({
        		url:url,
        		method:method,
        		headers:this._headers,
        		data:data,
        		callback:back
        	});
        }

		this._waitMode++;
    },
	sendAllData:function(){
		this._log("Sending all updated items");
		if (!this.updatedRows.length) return;			

		this.messages=[]; var valid=true;
		for (var i=0; i<this.updatedRows.length; i++)
			if (this.getState(this.updatedRows[i]) !== "deleted")
				valid&=this.checkBeforeUpdate(this.updatedRows[i]);

		if (!valid && !this.callEvent("onValidationError",["",this.messages])) return false;
	
		if (this._tSend) 
			this._sendData(this._getAllData());
		else
			for (var i=0; i<this.updatedRows.length; i++)
				if (!this._in_progress[this.updatedRows[i]]){
					if (this.is_invalid(this.updatedRows[i])) continue;
					this._beforeSendData(this._getRowData(this.updatedRows[i]),this.updatedRows[i]);
					if (this._waitMode && (this.obj.mytype=="tree" || this.obj._h2)) return; //block send all for tree
				}
	},
    
	
	
	
	
	
	
	
	_getAllData:function(rowId){
		var out={};
		var has_one = false;
		for(var i=0;i<this.updatedRows.length;i++){
			var id=this.updatedRows[i];
			if (this._in_progress[id] || this.is_invalid(id)) continue;
			if (!this.callEvent("onBeforeUpdate",[id,this.getState(id), this._getRowData(id)])) continue;
			out[id]=this._getRowData(id,id+this.post_delim);
			has_one = true;
			this._in_progress[id]=(new Date()).valueOf();
		}
		return has_one?out:null;
	},
	
	
	/**
	* 	@desc: specify column which value should be varified before sending to server
	*	@param: ind - column index (0 based)
	*	@param: verifFunction - function (object) which should verify cell value (if not specified, then value will be compared to empty string). Two arguments will be passed into it: value and column name
	*	@type: public
	*/
	setVerificator:function(ind,verifFunction){
		this.mandatoryFields[ind] = verifFunction||(function(value){return (value!=="");});
	},
	/**
	* 	@desc: remove column from list of those which should be verified
	*	@param: ind - column Index (0 based)
	*	@type: public
	*/
	clearVerificator:function(ind){
		this.mandatoryFields[ind] = false;
	},
	
	
	
	
	
	findRow:function(pattern){
		var i=0;
    	for(i=0;i<this.updatedRows.length;i++)
		    if(pattern==this.updatedRows[i]) break;
	    return i;
    },

   
	


    





	/**
	* 	@desc: define custom actions
	*	@param: name - name of action, same as value of action attribute
	*	@param: handler - custom function, which receives a XMl response content for action
	*	@type: private
	*/
	defineAction:function(name,handler){
        if (!this._uActions) this._uActions=[];
            this._uActions[name]=handler;
	},




	/**
*     @desc: used in combination with setOnBeforeUpdateHandler to create custom client-server transport system
*     @param: sid - id of item before update
*     @param: tid - id of item after up0ate
*     @param: action - action name
*     @type: public
*     @topic: 0
*/
	afterUpdateCallback:function(sid, tid, action, btag) {
		this._log("Action: "+action+" SID:"+sid+" TID:"+tid, btag);
		var marker = sid;
		var correct=(action!="error" && action!="invalid");
		if (!correct) this.set_invalid(sid,action);
		if ((this._uActions)&&(this._uActions[action])&&(!this._uActions[action](btag))) 
			return (delete this._in_progress[marker]);
			
		if (this._in_progress[marker]!="wait")
	    	this.setUpdated(sid, false);
	    	
	    var soid = sid;
	
	    switch (action) {
	    case "inserted":
	    case "insert":
	        if (tid != sid) {
	            this.obj[this._methods[2]](sid, tid);
	            sid = tid;
	        }
	        break;
	    case "delete":
	    case "deleted":
	    	this.obj.setUserData(sid, this.action_param, "true_deleted");
	        this.obj[this._methods[3]](sid);
	        delete this._in_progress[marker];
	        return this.callEvent("onAfterUpdate", [sid, action, tid, btag]);
	        break;
	    }
	    
	    if (this._in_progress[marker]!="wait"){
	    	if (correct) this.obj.setUserData(sid, this.action_param,'');
	    	delete this._in_progress[marker];
    	} else {
    		delete this._in_progress[marker];
    		this.setUpdated(tid,true,this.obj.getUserData(sid,this.action_param));
		}
	    
	    this.callEvent("onAfterUpdate", [soid, action, tid, btag]);
	},
	enableDebug:function(){
		this._debug = true;
	},
	_log:function(){
		if (this._debug && window.console && window.console.info)
			window.console.info.apply(window.console, arguments);
	},
	/**
	* 	@desc: response from server
	*	@param: xml - XMLLoader object with response XML
	*	@type: private
	*/
	afterUpdate:function(that,xml,id){
		this._log("Server response received");
		//try to use json first
		if (window.JSON){
			try{
				var tag = JSON.parse(xml.xmlDoc.responseText);
				var action = tag.action || this.getState(id) || "updated";
				var sid = tag.sid || id[0];
				var tid = tag.tid || id[0];
				that.afterUpdateCallback(sid, tid, action, tag);
				that.finalizeUpdate();
				return;
			} catch(e){
			}
		}
		//xml response
		var top = dhx4.ajax.xmltop("data", xml.xmlDoc); //fix incorrect content type in IE
		if (!top || top.tagName == "DIV") return this.cleanUpdate(id);
		var atag=dhx4.ajax.xpath("//data/action", top);
		if (!atag.length) return this.cleanUpdate(id);

		for (var i=0; i<atag.length; i++){
        	var btag=atag[i];
			var action = btag.getAttribute("type");
			var sid = btag.getAttribute("sid");
			var tid = btag.getAttribute("tid");
			
			that.afterUpdateCallback(sid,tid,action,btag);
		}
		that.finalizeUpdate();
	},
	cleanUpdate:function(id){
		if (id)
			for (var i = 0; i < id.length; i++)
				delete this._in_progress[id[i]];
	},
	finalizeUpdate:function(){
		if (this._waitMode) this._waitMode--;
		
		if ((this.obj.mytype=="tree" || this.obj._h2) && this.updatedRows.length) 
			this.sendData();
		this.callEvent("onAfterUpdateFinish",[]);
		if (!this.updatedRows.length)
			this.callEvent("onFullSync",[]);
	},




	
	/**
	* 	@desc: initializes data-processor
	*	@param: anObj - dhtmlxGrid object to attach this data-processor to
	*	@type: public
	*/
	init:function(anObj){
		this.obj = anObj;
		if (anObj._dp_init) 
			anObj._dp_init(this);
		if (this.connector_init)
			anObj._dataprocessor=this;
	},
	
	
	setOnAfterUpdate:function(ev){
		this.attachEvent("onAfterUpdate",ev);
	},
	setOnBeforeUpdateHandler:function(func){  
		this.attachEvent("onBeforeDataSending",func);
	},



	/* starts autoupdate mode
		@param interval
			time interval for sending update requests
	*/
	setAutoUpdate: function(interval, user) {
		interval = interval || 2000;
		
		this._user = user || (new Date()).valueOf();
		this._need_update = false;
		this._update_busy = false;
		
		this.attachEvent("onAfterUpdate",function(sid,action,tid,xml_node){
			this.afterAutoUpdate(sid, action, tid, xml_node);
		});
		this.attachEvent("onFullSync",function(){
			this.fullSync();
		});
		
		var self = this;
		window.setInterval(function(){
			self.loadUpdate();
		}, interval);
	},


	/* process updating request answer
		if status == collision version is depricated
		set flag for autoupdating immidiatly
	*/
	afterAutoUpdate: function(sid, action, tid, xml_node) {
		if (action == 'collision') {
			this._need_update = true;
			return false;
		} else {
			return true;
		}
	},


	/* callback function for onFillSync event
		call update function if it's need
	*/
	fullSync: function() {
		if (this._need_update == true) {
			this._need_update = false;
			this.loadUpdate();
		}
		return true;
	},


	/* sends query to the server and call callback function
	*/
	getUpdates: function(url,callback){
		if (this._update_busy) 
			return false;
		else
			this._update_busy = true;
		
		dhx4.ajax.get(url, callback);
	},


	/* returns xml node value
		@param node
			xml node
	*/
	_v: function(node) {
		if (node.firstChild) return node.firstChild.nodeValue;
		return "";
	},


	/* returns values array of xml nodes array
		@param arr
			array of xml nodes
	*/
	_a: function(arr) {
		var res = [];
		for (var i=0; i < arr.length; i++) {
			res[i]=this._v(arr[i]);
		};
		return res;
	},


	/* loads updates and processes them
	*/
	loadUpdate: function(){
		var self = this;
		var version = this.obj.getUserData(0,"version");
		var url = this.serverProcessor+this.url(this.serverProcessor)+["dhx_user="+this._user,"dhx_version="+version].join("&");
		url = url.replace("editing=true&","");
		this.getUpdates(url, function(r){
			var top = dhx4.ajax.xmltop("updates", r.xmlDoc);
			var vers = dhx4.ajax.xpath("//userdata", top);
			self.obj.setUserData(0,"version",self._v(vers[0]));
			
			var upds = dhx4.ajax.xpath("//update", top);
			if (upds.length){
				self._silent_mode = true;
				
				for (var i=0; i<upds.length; i++) {
					var status = upds[i].getAttribute('status');
					var id = upds[i].getAttribute('id');
					var parent = upds[i].getAttribute('parent');
					switch (status) {
						case 'inserted':
							self.callEvent("insertCallback",[upds[i], id, parent]);
							break;
						case 'updated':
							self.callEvent("updateCallback",[upds[i], id, parent]);
							break;
						case 'deleted':
							self.callEvent("deleteCallback",[upds[i], id, parent]);
							break;
					}
				}
				
				self._silent_mode = false;
			}
			
			self._update_busy = false;
			self = null;
		});
	}

};

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
	@author dhtmlx.com
	@license GPL, see license.txt
*/

if (window.dataProcessor && !dataProcessor.prototype.init_original)
	dataProcessor.prototype.connector_init=true;


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCalendarObject(inps, skin) {
	
	// parse inputs
	this.i = {};
	
	var p = null;
	if (typeof(inps) == "string") {
		var t0 = document.getElementById(inps);
	} else {
		var t0 = inps;
	}
	if (t0 && typeof(t0) == "object" && t0.tagName && String(t0.tagName).toLowerCase() != "input") p = t0;
	t0 = null;
	
	// single param
	if (typeof(inps) != "object" || !inps.length) inps = [inps];
	for (var q=0; q<inps.length; q++) {
		if (typeof(inps[q]) == "string") inps[q] = (document.getElementById(inps[q])||null);
		if (inps[q] != null && inps[q].tagName && String(inps[q].tagName).toLowerCase() == "input") {
			this.i[window.dhx4.newId()] = {input: inps[q]};
		} else {
			if (!(inps[q] instanceof Array) && inps[q] instanceof Object && (inps[q].input != null || inps[q].button != null)) {
				if (inps[q].input != null && typeof(inps[q].input) == "string") inps[q].input = document.getElementById(inps[q].input);
				if (inps[q].button != null && typeof(inps[q].button) == "string") inps[q].button = document.getElementById(inps[q].button);
				this.i[window.dhx4.newId()] = inps[q];
			}
		}
		inps[q] = null;
	}
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhtmlxcalendar")||"material"),
		zi: window.dhx4.newId(),
		touch: !window.dhx4.isIE,
		time: true,
		today: false,
		ws_first: true // false => start year from 52/53 wekk number (if 1st jan belongs to 1st week)
	}
	
	this.setSkin = function(skin, force) {
		if (this.conf.skin == skin && !force) return;
		this.conf.skin = skin;
		this.base.className = "dhtmlxcalendar_"+this.conf.skin;
		this._ifrSize();
	}
	
	// create base
	this.base = document.createElement("DIV");
	this.base.style.display = "none";
	this.base.appendChild(document.createElement("DIV"));
	
	if (p != null) {
		this._hasParent = true;
		p.appendChild(this.base);
		p = null;
	} else { 
		document.body.appendChild(this.base);
	}
	
	this.setParent = function(p) {
		if (this._hasParent) {
			if (typeof(p) == "object") {
				p.appendChild(this.base);
			} else if (typeof(p) == "string") {
				document.getElementById(p).appendChild(this.base);
			}
		}
	}
	
	this.setSkin(this.conf.skin, true);
	
	this.base.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault();
		e.cancelBubble = true;
	}
	this.base.onmousedown = function() {
		return false;
	}
	
	if (this.conf.touch) {
		this.base.ontouchstart = this.base.onclick;
	}
	
	this.loadUserLanguage = function(lang) {
		if (!this.langData[lang]) return;
		this.lang = lang;
		this.setWeekStartDay(this.langData[this.lang].weekstart);
		this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
		// month selector
		if (this.msCont) {
			var e = 0;
			for (var q=0; q<this.msCont.childNodes.length; q++) {
				for (var w=0; w<this.msCont.childNodes[q].childNodes.length; w++) {
					this.msCont.childNodes[q].childNodes[w].innerHTML = this.langData[this.lang].monthesSNames[e++];
				}
			}
		}
		// today/clear
		this.contTime.childNodes[0].childNodes[0].childNodes[5].innerHTML = this.langData[this.lang].today;
		this.contTime.childNodes[0].childNodes[0].childNodes[4].innerHTML = this.langData[this.lang].clear;
	}
	
	// build month and year header
	this.contMonth = document.createElement("DIV");
	this.contMonth.className = "dhtmlxcalendar_month_cont";
	this.contMonth.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.base.firstChild.appendChild(this.contMonth);
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contMonth.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_month_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left\";'></div>"+
			"<span></span>"+ // hdrformat will here
			"<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right\";'></div>";
	ul.appendChild(li);
	
	var that = this;
	
	li.onclick = function(e) {
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		// change month by clicking left-right arrows
		if (t.className && t.className.indexOf("dhtmlxcalendar_month_arrow") === 0) {
			that._hideSelector();
			var ind = (t.parentNode.firstChild==t?-1:1);
			var k0 = new Date(that._activeMonth);
			that._drawMonth(new Date(that._activeMonth.getFullYear(), that._activeMonth.getMonth()+ind, 1, 0, 0, 0, 0));
			that._evOnArrowClick([k0, new Date(that._activeMonth)]);
			return;
		}
		// show month selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_month") {
			e.cancelBubble = true;
			that._showSelector("month", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_month", true);
			return;
		}
		// show year selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_year") {
			e.cancelBubble = true;
			that._showSelector("year", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_year", true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	// build days names
	this.contDays = document.createElement("DIV");
	this.contDays.className = "dhtmlxcalendar_days_cont";
	this.base.firstChild.appendChild(this.contDays);
	
	this.setWeekStartDay = function(ind) {
		// 1..7 = Mo-Su, also 0 = Su
		if (ind == 0) ind = 7;
		this._wStart = Math.min(Math.max((isNaN(ind)?1:ind),1),7);
		this._drawDaysOfWeek();
	}
	
	this._drawDaysOfWeek = function() {
		if (this.contDays.childNodes.length == 0) {
			var ul = document.createElement("UL");
			ul.className = "dhtmlxcalendar_line";
			this.contDays.appendChild(ul);
		} else {
			var ul = this.contDays.firstChild;
		}
		
		var w = this._wStart;
		var k = this.langData[this.lang].daysSNames;
		k.push(String(this.langData[this.lang].daysSNames[0]).valueOf());
		
		for (var q=0; q<8; q++) {
			if (ul.childNodes[q] == null) {
				var li = document.createElement("LI");
				ul.appendChild(li);
			} else {
				var li = ul.childNodes[q];
			}
			if (q == 0) {
				li.className = "dhtmlxcalendar_cell_wn";
				li.innerHTML = "<div class='dhtmlxcalendar_label'>"+(this.langData[this.lang].weekname||"w")+"</div>";
			} else {
				li.className = "dhtmlxcalendar_cell"+(w>=6?" dhtmlxcalendar_day_weekday_cell":"")+(q==1?"_first":"");
				li.innerHTML = k[w];
				if (++w > 7) w = 1;
			}
		}
		if (this._activeMonth != null) this._drawMonth(this._activeMonth);
	}
	
	this._wStart = this.langData[this.lang].weekstart;
	this.setWeekStartDay(this._wStart);
	
	// dates container
	this.contDates = document.createElement("DIV");
	this.contDates.className = "dhtmlxcalendar_dates_cont";
	this.base.firstChild.appendChild(this.contDates);
	
	this.contDates.onclick = function(e){
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null && !t._css_dis) {
			
			var t1 = that._activeDate.getHours();
			var t2 = that._activeDate.getMinutes();
			var d0 = t._date;
			
			// cjeck if allow to modify input
			if (that.checkEvent("onBeforeChange")) {
				if (!that.callEvent("onBeforeChange",[new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),t1,t2)])) return;
			}
			
			if (that._activeDateCell != null) {
				that._activeDateCell._css_date = false;
				that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			}
			
			// update month if day from prev/next month clicked
			var refreshView = (that._activeDate.getFullYear()+"_"+that._activeDate.getMonth() != d0.getFullYear()+"_"+d0.getMonth());
			
			that._nullDate = false;
			that._activeDate = new Date(d0.getFullYear(),d0.getMonth(),d0.getDate(),t1,t2);
			
			that._activeDateCell = t;
			that._activeDateCell._css_date = true;
			that._activeDateCell._css_hover = false;
			that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			
			if (refreshView) that._drawMonth(that._activeDate);
			
			// update date in input if any
			that._updateInp();
			
			// hide
			if (!that._hasParent) {
				if (e.type == "touchstart") {
					window.setTimeout(function(){that._hide();},400);
				} else {
					that._hide();
				}
			}
			//
			that._evOnClick([new Date(that._activeDate.getTime())]);
			
		}
	}
	
	if (this.conf.touch == true) {
		this.contDates.ontouchstart = this.contDates.onclick;
	}
	
	this.contDates.onmouseover = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null) { // && t != that._activeDateCell) { // skip hover for selected date
			if (that._lastHover == t || t._css_hover) return;
			t._css_hover = true;
			that._updateCellStyle(t._q, t._w);
			that._lastHover = t;
			that._evOnMouseOver([new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),0,0,0,0),e]);
			t = null;
		}
	}
	this.contDates.onmouseout = function(e) {
		that._clearDayHover(e||event);
	}
	
	this._lastHover = null;
	this._clearDayHover = function(ev) {
		if (!this._lastHover) return;
		this._lastHover._css_hover = false;
		this._updateCellStyle(this._lastHover._q, this._lastHover._w);
		if (ev != null) that._evOnMouseOut([new Date(this._lastHover._date.getFullYear(),this._lastHover._date.getMonth(),this._lastHover._date.getDate(),0,0,0,0),ev]);
		this._lastHover = null;
	}
	
	// build cells
	for (var q=0; q<6; q++) {
		var ul = document.createElement("UL");
		ul.className = "dhtmlxcalendar_line";
		this.contDates.appendChild(ul);
		for (var w=0; w<=7; w++) {
			var li = document.createElement("LI");
			if (w == 0) {
				// week number
				li.className = "dhtmlxcalendar_cell_wn";
			} else {
				li.className = "dhtmlxcalendar_cell";
			}
			ul.appendChild(li);
		}
	}
	
	
	// timepicker
	this.contTime = document.createElement("DIV");
	this.contTime.className = "dhtmlxcalendar_time_cont";
	this.contTime.style.display = "none";
	this.base.firstChild.appendChild(this.contTime);
	
	this.showTime = function() {
		if (this.conf.time != true) {
			this.conf.time = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideTime = function() {
		if (this.conf.time == true) {
			this.conf.time = false;
			this._adjustTimeCont();
		}
	}
	
	this.showToday = function() {
		if (this.conf.today != true) {
			this.conf.today = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideToday = function() {
		if (this.conf.today == true) {
			this.conf.today = false;
			this._adjustTimeCont();
		}
	}
	
	this._adjustTimeCont = function() {
		var css = "";
		if (this.conf.time == true) css += "_time";
		if (this.conf.today == true) css += "_today";
		if (css == "") {
			this.contTime.style.display = "none";
		} else {
			this.contTime.className = "dhtmlxcalendar_time_cont dhtmlxcalendar_mode"+css;
			this.contTime.style.display = "";
		}
		this._ifrSize();
	}
	
	this._adjustTimeCont();
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contTime.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_time_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_time_img'></div>"+
			"<span class='dhtmlxcalendar_label_hours'></span><span class='dhtmlxcalendar_label_colon'>:</span><span class='dhtmlxcalendar_label_minutes'></span>"+
			"<span class='dhtmlxcalendar_label_clear'>"+this.langData[this.lang].clear+"</span><span class='dhtmlxcalendar_label_today'>"+this.langData[this.lang].today+"</span>"; // added in 4.6
	ul.appendChild(li);
	
	li.onclick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		if (t.tagName != null && t.tagName.toLowerCase() == "span" && t._par == true && t.parentNode != null) {
			t = t.parentNode;
		}
		// show hours selector
		if (t.className && t.className == "dhtmlxcalendar_label_hours") {
			e.cancelBubble = true;
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("hours", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_hours", true);
			return;
		}
		// show minutes selector
		if (t.className && t.className == "dhtmlxcalendar_label_minutes") {
			e.cancelBubble = true;
			if (that._minutesInterval == 1) {
				var d = that.getFormatedDate("%i");
				t.innerHTML = "<span class='dhtmlxcalendar_selected_date'>"+d.charAt(0)+"</span>"+d.charAt(1);
				t.firstChild._par = true;
				that._selectorMode = 1; // select hour
			}
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("minutes", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_minutes",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
		// today/clear buttons, added in 4.6
		if (t.className && t.className == "dhtmlxcalendar_label_today") {
			var d = new Date();
			d = new Date(d.getFullYear(), d.getMonth(), d.getDate(), that._activeDate.getHours(), that._activeDate.getMinutes(), that._activeDate.getSeconds(), that._activeDate.getMilliseconds());
			that.setDate(d);
			that._updateInp();
			that.callEvent("onButtonClick", [d]);
		}
		if (t.className && t.className == "dhtmlxcalendar_label_clear") {
			that._nullDate = true;
			that._drawMonth(new Date());
			that._updateInp();
			that.callEvent("onButtonClick", [null]);
		}
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	this._activeMonth = null;
	
	this._activeDate = new Date();
	this._activeDateCell = null;
	
	this.setDate = function(d) {
		window.dhx4.temp_calendar = {tz:null};
		this._nullDate = (typeof(d) == "undefined" || d === "" || !d);
		
		if (!(d instanceof Date)) {
			d = this._strToDate(String(d||""));
			if (d == "Invalid Date") d = new Date(); else this.conf.tz = window.dhx4.temp_calendar.tz;
			window.dhx4.temp_calendar = null;
		}
		if (this.conf.tz == null) this.conf.tz = window.dhx4.date2str(d,"%P");
		
		var time = d.getTime();
		
		// out of range
		if (this._isOutOfRange(time)) return;
		
		this._activeDate = new Date(time);
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		this._updateVisibleHours();
		this._updateVisibleMinutes();
	}
	
	this.getDate = function(formated) {
		if (this._nullDate) return null;
		var t = new Date(this._activeDate.getTime());
		if (formated) {
			window.dhx4.temp_calendar = {tz:this.conf.tz};
			var d = this._dateToStr(t);
			window.dhx4.temp_calendar = null;
			return d;
		}
		return t;
	}
	
	this._drawMonth = function(d) {
		
		if (!(d instanceof Date)) return;
		if (isNaN(d.getFullYear())) d = new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeMonth = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeDateCell = null;
		
		var first = new Date(this._activeMonth.getTime());
		var d0 = first.getDay();
		
		var e0 = d0-this._wStart;
		if (e0 < 0) e0 = e0+7;
		first.setDate(first.getDate()-e0);
		
		var mx = d.getMonth();
		var dx = new Date(this._activeDate.getFullYear(), this._activeDate.getMonth(), this._activeDate.getDate(), 0, 0, 0, 0).getTime();
		var i = 0;
		for (var q=0; q<6; q++) {
			var ws = this._wStart;
			for (var w=0; w<=7; w++) {
				if (w == 0) {
					var wn = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0));
					// if active month set to jan and 1st jan belong to 1st week - display 1st week instead of 52/53
					if (wn >= 52 && this.conf.ws_first == true && this._activeMonth.getMonth() == 0) {
						var wn2 = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i+7, 0, 0, 0, 0));
						if (wn2 < wn && wn2 > 1) wn = 1;
					}
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='dhtmlxcalendar_label'>"+wn+"</div>";
				} else {
					
					var d2 = new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0);
					if (d2.getHours() != 0) {
						var h = (d2.getHours()>12 ? 24-d2.getHours() : d2.getHours()); // yesturday/tomorrow while daylight saving
						d2.setTime(d2.getTime() + 60*60*1000*h);
					}
					
					var day = d2.getDay();
					var time = d2.getTime();
					
					var label_css = "dhtmlxcalendar_label";
					if (this._tipData[time] != null) {
						if (this._tipData[time].usePopup && typeof(window.dhtmlXPopup) == "function") {
							this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
							this._initTooltipPopup();
						} else {
							this.contDates.childNodes[q].childNodes[w].setAttribute("title", this._tipData[time].text);
						}
						if (this._tipData[time].showIcon) label_css += " dhtmlxcalendar_label_title";
					} else {
						this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
						
					}
					
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='"+label_css+"'>"+d2.getDate()+"</div>";
					
					this.contDates.childNodes[q].childNodes[w]._date = new Date(time);
					this.contDates.childNodes[q].childNodes[w]._q = q;
					this.contDates.childNodes[q].childNodes[w]._w = w;
					this.contDates.childNodes[q].childNodes[w]._css_month = (d2.getMonth()==mx);
					this.contDates.childNodes[q].childNodes[w]._css_date = (!this._nullDate&&time==dx);
					this.contDates.childNodes[q].childNodes[w]._css_weekend = (ws>=6);
					this.contDates.childNodes[q].childNodes[w]._css_dis = this._isOutOfRange(time);
					this.contDates.childNodes[q].childNodes[w]._css_holiday = (this._holidays[time] == true);
					
					this._updateCellStyle(q, w);
					
					if (time==dx) this._activeDateCell = this.contDates.childNodes[q].childNodes[w];
					
					if (++ws > 7) ws = 1;
					i++;
				}
				
			}
		}
		
		this.contMonth.firstChild.firstChild.childNodes[1].innerHTML = this._buildMonthHdr(d);
		
	}
	
	this._updateCellStyle = function(q, w) {
		
		var r = this.contDates.childNodes[q].childNodes[w];
		
		var s = "dhtmlxcalendar_cell dhtmlxcalendar_cell";
		
		// this/another month
		s += (r._css_month ? "_month" : "");
		
		// selected date
		s += (r._css_date ? "_date" : "");
		
		// is weekend
		s += (r._css_weekend ? "_weekend" : "");
		
		// is holiday
		s += (r._css_holiday ? "_holiday" : "");
		
		// is cell disabled
		s += (r._css_dis ? "_dis" : "");
		
		// is cell hover (only if not disabled)
		s += (r._css_hover && !r._css_dis ? "_hover" : "");
		
		r.className = s;
		r = null;
		
	}
	
	/* global selector obj */
	
	this._minutesInterval = 5; // default
	
	this._initSelector = function(type,css) {
		
		if (!this._selCover) {
			this._selCover = document.createElement("DIV");
			this._selCover.className = "dhtmlxcalendar_selector_cover";
			this.base.firstChild.appendChild(this._selCover);
		}

		if (!this._sel) {
			
			this._sel = document.createElement("DIV");
			this._sel.className = "dhtmlxcalendar_selector_obj";
			this.base.firstChild.appendChild(this._sel);
			
			this._sel.appendChild(document.createElement("TABLE"));
			this._sel.firstChild.className = "dhtmlxcalendar_selector_table";
			this._sel.firstChild.cellSpacing = 0;
			this._sel.firstChild.cellPadding = 0;
			this._sel.firstChild.border = 0;
			this._sel.firstChild.appendChild(document.createElement("TBODY"));
			this._sel.firstChild.firstChild.appendChild(document.createElement("TR"));
			
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].className = "dhtmlxcalendar_selector_cell_left";
			this._sel.firstChild.firstChild.firstChild.childNodes[1].className = "dhtmlxcalendar_selector_cell_middle";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].className = "dhtmlxcalendar_selector_cell_right";
			this._sel.firstChild.firstChild.firstChild.childNodes[0].innerHTML = "&nbsp;";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].innerHTML = "&nbsp;";
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_left dhtmlxcalendar_selector_cell_left_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_left";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_right dhtmlxcalendar_selector_cell_right_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_right";
			}
			
			this._sel.onmouseover = function(e) {
				e = e||event;
				var t = (e.target||e.srcElement);
				if (t._cell === true) {
					if (that._selHover != t) that._clearSelHover();
					if (String(t.className).match(/^\s{0,}dhtmlxcalendar_selector_cell\s{0,}$/gi) !=null) {
						t.className += " dhtmlxcalendar_selector_cell_hover";
						that._selHover = t;
					}
				}
			}
			
			this._sel.onmouseout = function() {
				that._clearSelHover();
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(-1);
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(1);
			}
			
			if (this.conf.touch == true) {
				this._sel.firstChild.firstChild.firstChild.childNodes[0].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick;
				this._sel.firstChild.firstChild.firstChild.childNodes[2].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick;
			}
			
			this._sel._ta = {};
			
			this._selHover = null;
			
			this._sel.appendChild(document.createElement("DIV"));
			this._sel.lastChild.className = "dhtmlxcalendar_selector_obj_arrow";
		}
		
		// check if already inited
		if (this._sel._ta[type] == true) return;
		
		// init month
		if (type == "month") {
			
			this._msCells = {};
			
			this.msCont = document.createElement("DIV");
			this.msCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.msCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.msCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this.langData[this.lang].monthesSNames[i];
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._month = i;
					li._cell = true;
					this._msCells[i++] = li;
				}
			}
			
			this.msCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._month != null) {
					that._hideSelector();
					that._updateActiveMonth();
					that._drawMonth(new Date(that._activeMonth.getFullYear(), t._month, 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.msCont.ontouchstart = this.msCont.onclick;
			}
		}
		
		// init year
		if (type == "year") {
			
			this._ysCells = {};
			
			this.ysCont = document.createElement("DIV");
			this.ysCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.ysCont);
			
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.ysCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.className = "dhtmlxcalendar_selector_cell";
					li._cell = true;
					ul.appendChild(li);
				}
			}
			
			this.ysCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._year != null) {
					that._hideSelector();
					that._drawMonth(new Date(t._year, that._activeMonth.getMonth(), 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.ysCont.ontouchstart = this.ysCont.onclick;
			}
			
		}
		
		// init hours
		if (type == "hours") {
			
			this._hsCells = {};
			
			this.hsCont = document.createElement("DIV");
			this.hsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.hsCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.hsCont.appendChild(ul);
				for (var w=0; w<6; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this._fixLength(i,2);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._hours = i;
					li._cell = true;
					this._hsCells[i++] = li;
				}
			}
			
			this.hsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._hours != null) {
					that._hideSelector();
					that._activeDate.setHours(t._hours);
					that._updateActiveHours();
					that._updateVisibleHours();
					that._doOnSelectorChange();
					//
					that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
				}
			}
			if (this.conf.touch == true) {
				this.hsCont.ontouchstart = this.hsCont.onclick;
			}
		}
		
		// init minutes
		if (type == "minutes") {
			
			// _minutesInterval = 5, def
			
			var q1 = 4;
			var w1 = 3;
			var len = 2; // leading zero
			
			if (this._minutesInterval == 1) {
				if (this._selectorMode == 1) {
					q1 = 2;
					w1 = 3;
					len = 1;
				} else {
					q1 = 2;
					w1 = 5;
					len = 1;
					css += "5";
				}
			}
			if (this._minutesInterval == 10) q1 = 2;
			if (this._minutesInterval == 15) {
				q1 = 1;
				w1 = 4;
				css += "4";
			}
			
			this._rsCells = {};
			
			this.rsCont = document.createElement("DIV");
			this.rsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.rsCont);
			
			var i = 0;
			for (var q=0; q<q1; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.rsCont.appendChild(ul);
				for (var w=0; w<w1; w++) {
					var li = document.createElement("LI");
					li.innerHTML = (len>1?this._fixLength(i,len):i);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._minutes = i;
					li._cell = true;
					this._rsCells[i] = li;
					i += this._minutesInterval;
				}
			}
			
			this.rsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._minutes != null) {
					if (that._minutesInterval == 1) {
						
						var m = that.getFormatedDate("%i");
						if (that._selectorMode == 1) {
							m = t._minutes.toString()+m.charAt(1);
						} else {
							m = m.charAt(0)+t._minutes.toString();
						}
						that._activeDate.setMinutes(Number(m));
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
						
						that._hideSelector(); // will unload
						
						if (that._selectorMode == 1) {
							// show 2nd
							
							that._updateVisibleMinutes(true);
							that._selectorMode = 2;
							that._showSelector("minutes", that._sel._x, that._sel._y, "selector_minutes", true);
							that._updateActiveMinutes();
							return;
						} else {
							that._selectorMode = 1;
						}
					} else {
						that._hideSelector();
						that._activeDate.setMinutes(t._minutes);
						that._updateActiveMinutes();
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
					}
					that._updateVisibleMinutes();
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.rsCont.ontouchstart = this.rsCont.onclick;
			}
		}
		
		// mark that selector of current type is inited
		this._sel._ta[type] = true;
	}
	
	this._showSelector = function(type, x, y, css, autoHide) {
		
		if (autoHide === true && this._sel != null && this._isSelectorVisible() && type == this._sel._t) {
			this._hideSelector();
			return;
		}
		
		if (this.conf.skin == "dhx_terrace") {
			x += 12; // ul's margin
		}
		
		if (!this._sel || !this._sel._ta[type]) this._initSelector(type,css);
		
		// minutes was visible, selector jumps to other type, remove red line
		if (type != this._sel._t && this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
		}
		
		this._sel._x = x;
		this._sel._y = y;
		
		// show selector cover
		this._sel.style.visibility = "hidden";
		this._sel.style.display = "";
		
		this._selCover.style.width = this.base.offsetWidth-2+"px";
		this._selCover.style.top = this.contMonth.offsetHeight+"px";
		this._selCover.style.height = this.contDates.offsetHeight+this.contDays.offsetHeight-1+"px";
		
		this._selCover.style.display = "";
		
		// show selector
		this._sel._t = type;
		this._sel.className = "dhtmlxcalendar_selector_obj dhtmlxcalendar_"+css+(type=="hours"&&this.conf.today==true?"2":"");
		
		// left/right table arrows
		this._sel.childNodes[0].firstChild.firstChild.childNodes[0].style.display = this._sel.childNodes[0].firstChild.firstChild.childNodes[2].style.display = (type=="year"?"":"none");
		
		// coords
		var x0 = Math.max(0, x-Math.round(this._sel.offsetWidth/2));
		if (x0+this._sel.offsetWidth > this._sel.parentNode.offsetWidth) {
			x0 = this._sel.parentNode.offsetWidth - this._sel.offsetWidth;
		}
		
		this._sel.style.left = x0+"px";
		
		if (type == "hours" || type == "minutes") {
			this._sel.style.top = y-this._sel.offsetHeight+"px";
		} else {
			this._sel.style.top = y+"px";
		}
		
		// arrow width
		this._sel.childNodes[1].style.width = this._sel.childNodes[0].offsetWidth+"px";
		
		// final apply
		this._sel.style.visibility = "visible";
		
		// callbacks
		this._doOnSelectorShow(type);
	}
	
	this._doOnSelectorShow = function(type) {
		if (type == "month") this._updateActiveMonth();
		if (type == "year") this._updateYearsList(this._activeMonth);
		if (type == "hours") this._updateActiveHours();
		if (type == "minutes") this._updateActiveMinutes();
	}
	
	this._hideSelector = function(selMode) {
		if (!this._sel) return;
		this._sel.style.display = "none";
		this._sel.style.visible = "hidden";
		this._selCover.style.display = "none";
		//
		if (this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
			this._unloadSelector("minutes");
		}
	}
	
	this._isSelectorVisible = function() {
		if (!this._sel) return false;
		return (this._sel.style.display != "none");
	}
	
	this._doOnSelectorChange = function(state) {
		this.callEvent("onChange",[new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), this._activeDate.getDate(), this._activeDate.getHours(), this._activeDate.getMinutes(), this._activeDate.getSeconds()),state===true]);
	}
	
	this._clearSelHover = function() {
		if (!this._selHover) return;
		this._selHover.className = String(this._selHover.className.replace(/dhtmlxcalendar_selector_cell_hover/gi,""));
		this._selHover = null;
	}
	
	this._unloadSelector = function(type) {
		if (!this._sel) return;
		if (!this._sel._ta[type]) return;
		
		// month selector
		if (type == "month") {
			
			this.msCont.onclick = this.msCont.ontouchstart = null;
			this._msActive = null;
			
			// li
			for (var a in this._msCells) {
				this._msCells[a]._cell = null;
				this._msCells[a]._month = null;
				this._msCells[a].parentNode.removeChild(this._msCells[a]);
				this._msCells[a] = null;
			}
			this._msCells = null;
			
			// ul
			while (this.msCont.childNodes.length > 0) this.msCont.removeChild(this.msCont.lastChild);
			
			// div
			this.msCont.parentNode.removeChild(this.msCont);
			this.msCont = null;
			
		}
		
		// years selector
		if (type == "year") {
			
			this.ysCont.onclick = this.ysCont.ontouchstart = null;
			
			// li
			for (var a in this._ysCells) {
				this._ysCells[a]._cell = null;
				this._ysCells[a]._year = null;
				this._ysCells[a].parentNode.removeChild(this._ysCells[a]);
				this._ysCells[a] = null;
			}
			this._ysCells = null;
			
			// ul
			while (this.ysCont.childNodes.length > 0) this.ysCont.removeChild(this.ysCont.lastChild);
			
			// div
			this.ysCont.parentNode.removeChild(this.ysCont);
			this.ysCont = null;
			
		}
		
		// hours selector
		if (type == "hours") {
			
			this.hsCont.onclick = this.hsCont.ontouchstart = null;
			this._hsActive = null;
			
			// li
			for (var a in this._hsCells) {
				this._hsCells[a]._cell = null;
				this._hsCells[a]._hours = null;
				this._hsCells[a].parentNode.removeChild(this._hsCells[a]);
				this._hsCells[a] = null;
			}
			this._hsCells = null;
			
			// ul
			while (this.hsCont.childNodes.length > 0) this.hsCont.removeChild(this.hsCont.lastChild);
			
			// div
			this.hsCont.parentNode.removeChild(this.hsCont);
			this.hsCont = null;
			
		}
		
		// minutes selector
		if (type == "minutes") {
			
			this.rsCont.onclick = this.rsCont.ontouchstart = null;
			this._rsActive = null;
			
			// li
			for (var a in this._rsCells) {
				this._rsCells[a]._cell = null;
				this._rsCells[a]._minutes = null;
				this._rsCells[a].parentNode.removeChild(this._rsCells[a]);
				this._rsCells[a] = null;
			}
			this._rsCells = null;
			
			// ul
			while (this.rsCont.childNodes.length > 0) this.rsCont.removeChild(this.rsCont.lastChild);
			
			// div
			this.rsCont.parentNode.removeChild(this.rsCont);
			this.rsCont = null;
			
		}
		
		
		this._sel._ta[type] = null;
	}
	
	this.setMinutesInterval = function(d) {
		if (!(d == 1 || d == 5 || d == 10 || d == 15)) return;
		this._minutesInterval = d;
		this._unloadSelector("minutes");
	}
	
	
	/* month selector */
	
	this._updateActiveMonth = function() {
		if (typeof(this._msActive) != "undefined" && typeof(this._msCells[this._msActive]) != "undefined") this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell";
		this._msActive = this._activeMonth.getMonth();
		this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	/* year selector */
	
	this._updateActiveYear = function() {
		var i = this._activeMonth.getFullYear();
		if (this._ysCells[i]) this._ysCells[i].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	this._updateYearsList = function(d) {
		for (var a in this._ysCells) {
			this._ysCells[a] = null;
			delete this._ysCells[a];
		}
		//
		var i = 12*Math.floor(d.getFullYear()/12);
		for (var q=0; q<4; q++) {
			for (var w=0; w<3; w++) {
				this.ysCont.childNodes[q].childNodes[w].innerHTML = i;
				this.ysCont.childNodes[q].childNodes[w]._year = i;
				this.ysCont.childNodes[q].childNodes[w].className = "dhtmlxcalendar_selector_cell";
				this._ysCells[i++] = this.ysCont.childNodes[q].childNodes[w];
			}
		}
		this._updateActiveYear();
	}
	
	this._scrollYears = function(i) {
		var y = (i<0?this.ysCont.firstChild.firstChild._year:this.ysCont.lastChild.lastChild._year)+i;
		var d = new Date(y, this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		this._updateYearsList(d);
	}
	
	/* hours selector */
	
	// update hours in selector
	this._updateActiveHours = function() {
		if (typeof(this._hsActive) != "undefined" && typeof(this._hsCells[this._hsActive]) != "undefined") this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell";
		this._hsActive = this._activeDate.getHours();
		this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update hours in calendar
	this._updateVisibleHours = function() {
		this.contTime.firstChild.firstChild.childNodes[1].innerHTML = this._fixLength(this._activeDate.getHours(),2);
	}
	
	/* minutes selector */
	
	// update minutes in selector
	this._updateActiveMinutes = function() {
		if (this._rsActive != null && typeof(this._rsActive) != "undefined" && typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell";
		if (this._minutesInterval == 1) {
			this._rsActive = (this.getFormatedDate("%i").toString()).charAt(this._selectorMode==1?0:1);
		} else {
			this._rsActive = this._activeDate.getMinutes();
		}
		if (typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update minutes in calendar
	this._updateVisibleMinutes = function(h) {
		var t = this._fixLength(this._activeDate.getMinutes(),2).toString();
		if (h == true) t = t.charAt(0)+"<span class='dhtmlxcalendar_selected_date'>"+t.charAt(1)+"</span>";
		this.contTime.firstChild.firstChild.childNodes[3].innerHTML = t;
		if (h == true) this.contTime.firstChild.firstChild.childNodes[3].lastChild._par = true;
	}
	
	/* some common functionality */
	
	this._fixLength = function(t, r) {
		while (String(t).length < r) t = "0"+String(t);
		return t;
	}
	
	this._dateFormat = "";
	this._dateFormatRE = null;
	
	this.setDateFormat = function(format) {
		
		// check value in inputs
		// for 1st call on init strTodate not defined
		var upd = {};
		if (this._strToDate != null) {
			for (var a in this.i) {
				if (this.i[a].input != null && this.i[a].input.value.length > 0) {
					var d = this._strToDate(this.i[a].input.value, this._dateFormat||this.langData[this.lang].dateformat||"%Y-%m-%d");
					if (d instanceof Date) upd[a] = d;
				}
			}
		}
		
		this._dateFormat = format;
		var k = String(this._dateFormat).replace(/%[a-zA-Z]+/g,function(t){
			var t2 = t.replace(/%/,"");
			switch (t2) {
				case "n": case "h": case "j": case "g": case "G": return "\\d{1,2}";
				case "m": case "d": case "H": case "i": case "s": case "y": return "\\d{2}";
				case "Y": return "\\d{4}";
				case "M": return "("+that.langData[that.lang].monthesSNames.join("|").toLowerCase()+"){1,}";
				case "F": return "("+that.langData[that.lang].monthesFNames.join("|").toLowerCase()+"){1,}";
				case "D": return "[a-z]{2}";
				case "a": case "A": return "AM|PM";
				case "u": return "\\d{1,6}";
				case "P": return "[\\+\\-]\\d{1,2}\\:\\d{1,2}";
			}
			return t;
		});
		
		this._dateFormatRE = new RegExp(k,"i");
		
		// update dates in inputs
		for (var a in upd) {
			this.i[a].input.value = this._dateToStr(upd[a]);
		}
		upd = null;
	}
	
	this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
	
	this._updateDateStr = function(str) {
		// check if valid str
		if (!this._dateFormatRE || !str.match(this._dateFormatRE)) return;
		
		// input was not updated
		if (str == this.getFormatedDate()) return;
		
		var r = this._strToDate(str);
		if (!(r instanceof Date)) return;
		
		// cjeck if allow to modify input
		if (this.checkEvent("onBeforeChange")) {
			if (!this.callEvent("onBeforeChange",[new Date(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds())])) {
				// revert value
				this._updateInp();
				return;
			}
		}
		
		this._nullDate = false;
		this._activeDate = r;
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		
		this._updateVisibleMinutes();
		this._updateVisibleHours();
		
		if (this._sel && this._isSelectorVisible()) this._doOnSelectorShow(this._sel._t);
		this._doOnSelectorChange(true);
		
	}
	
	this.showMonth = function(d) {
		if (typeof(d) == "string") d = this._strToDate(d);
		if (!(d instanceof Date)) return;
		this._drawMonth(d);
	}
	
	this.setFormatedDate = function(format, str, a, return_only) {
		var date = this._strToDate(str, format);
		if (return_only) return date;
		this.setDate(date);
	}

	this.getFormatedDate = function(format, date){
		if (!(date && date instanceof Date)){
			if (this._nullDate) return ""; 
			date = new Date(this._activeDate);
		}
		return this._dateToStr(date, format);
	}
	
	/* week numbers */
	this.getWeekNumber = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return "Invalid Date";
		
		if (typeof(this._ftDay) == "undefined") this._ftDay = 4;
		
		var ws = this._wStart; // 1..7 = Mo-Su
		var we = ws+7;
		
		var ft = 4; // first thursday
		
		
		var x1_date = new Date(dateX.getFullYear(), 0, 1, 0, 0, 0, 0);// day-of-week, jan first
		var x1 = x1_date.getDay();
		if (x1 == 0) x1 = 7;
		
		// offset
		if (ft < ws) {
			ft += 7;
			x1 += 7;
		}
		
		// detect date of 1st week
		
		var i = 0; // week offset
		if (x1 >= ws && x1 <= ft) {
			// x1 belong 1st week
		} else {
			// x1 belong 2nd week
			i = 1;
		}
		var k = x1-ws;
		var w1 = new Date(dateX.getFullYear(), 0, 1-k+i*7, 0, 0, 0, 0);// 1st week start date
		
		// console.log("1st week of "+x.getFullYear()+" year starts from "+this.getFormatedDate("%M %d, %Y",w1));
		
		var d7 = 604800000; // 7 days in ms, 60*60*24*7*1000
		var x2 = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate()+1, 0, 0, 0, 0); // 2nd day to get interval
		
		var wn = Math.ceil((x2.getTime()-w1.getTime())/d7);
		
		// if 1st jan coincide with 52/53'd week of prev year, get week number of 1st day of current week
		if (wn == 0) {
			var curDate = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate(), 0, 0, 0, 0);
			var firstDay = curDate.getDay()-this._wStart;
			if (firstDay < 0) firstDay = firstDay+7;
			curDate.setDate(curDate.getDate()-firstDay);
			wn = this.getWeekNumber(curDate);
		}
		
		return wn;
		
	}
	
	this.showWeekNumbers = function() {
		this.base.firstChild.className = "dhtmlxcalendar_wn";
	}
	
	this.hideWeekNumbers = function() {
		this.base.firstChild.className = "";
	}
	
	/* show/hide calendar */
	
	// public show/hide
	
	this.show = function(id) {
		// if id not set - try show in container
		if (!id && this._hasParent) {
			this._show();
			return;
		}
		
		// show by real input id, added in 5.0
		if (typeof(id) == "string") {
			var i = document.getElementById(id);
			if (i != null && typeof(i._dhtmlxcalendar_uid) != "undefined" && this.i[i._dhtmlxcalendar_uid] != null) {
				this._show(i._dhtmlxcalendar_uid);
				return;
			}
		}
		
		// if input id not specified show near first found
		// if nothing found - do not show
		if (typeof(id) == "object" && typeof(id._dhtmlxcalendar_uid) != "undefined" && this.i[id._dhtmlxcalendar_uid] == id) {
			this._show(id._dhtmlxcalendar_uid);
			return;
		}
		if (typeof(id) == "undefined") { for (var a in this.i) if (!id) id = a; }
		if (!id) return;
		this._show(id);
	}
	
	this.hide = function() {
		if (this._isVisible()) this._hide();
	}
	
	this.isVisible = function() {
		return this._isVisible();
	}
	
	
	// private show/hide
	this._activeInp = null;
	
	this.pos = "bottom";
	this.setPosition = function(x, y) {
		this._px = null;
		this._py = null;
		if (x == "right" || x == "bottom") {
			this.pos = x;
		} else {
			this.pos = "int";
			if (typeof(x) != "undefined" && !isNaN(x)) {
				this.base.style.left = x+"px";
				this._px = x;
			}
			if (typeof(y) != "undefined" && !isNaN(y)) {
				this.base.style.top = y+"px";
				this._py = y;
			}
			this._ifrSize();
		}
	}
	
	this._show = function(inpId, autoHide) {
		if (autoHide === true && this._activeInp == inpId && this._isVisible()) {
			this._hide();
			return;
		}
		this.base.style.visibility = "hidden";
		this.base.style.display = "";
		if (!inpId) {
			if (this._px != null && this._py != null) {
				this.base.style.left = this._px+"px";
				this.base.style.top = this._py+"px";
			} else {
				this.base.style.left = "0px";
				this.base.style.top = "0px";
			}
		} else {
			if (this.base.className.indexOf("dhtmlxcalendar_in_input") == -1) this.base.className += " dhtmlxcalendar_in_input";
			var i = (this.i[inpId].input||this.i[inpId].button);
			var dim = window.dhx4.screenDim();
			var inp = {top: window.dhx4.absTop(i), left: window.dhx4.absLeft(i)};
			if (this.pos == "right") {
				this.base.style.left = inp.left+i.offsetWidth+"px";
				this.base.style.top = Math.min(inp.top, dim.bottom-this.base.offsetHeight)+"px";
			} else if (this.pos == "bottom") {
				var y0 = inp.top+i.offsetHeight+1;
				if (y0+this.base.offsetHeight > dim.bottom) {
					var ny0 = inp.top-this.base.offsetHeight;
					if (ny0 >= -20) y0 = ny0;
				}
				// checi overflow from right side
				var x = inp.left;
				if (x + this.base.offsetWidth > dim.right) x = Math.max(0, inp.left+i.offsetWidth-this.base.offsetWidth);
				//
				this.base.style.left = x+"px";
				this.base.style.top = y0+"px";
			} else {
				this.base.style.left = (this._px||0)+"px";
				this.base.style.top = (this._py||0)+"px";
			}
			this._activeInp = inpId;
			i = null;
		}
		this._hideSelector();
		this.base.style.visibility = "visible";
		this.base.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this._ifrSize();
		if (this._ifr) this._ifr.style.display = "";
		this.callEvent("onShow",[]);
	}
	
	this._hide = function() {
		if (this._lastHover != null) this._clearDayHover();
		this._hideSelector();
		this.base.style.display = "none";
		window.dhx4.zim.clear(this.conf.zi);
		if (this.base.className.indexOf("dhtmlxcalendar_in_input") >= 0) this.base.className = this.base.className.replace(/\s{0,}dhtmlxcalendar_in_input/gi, "");
		this._activeInp = null;
		if (this._ifr) this._ifr.style.display = "none";
		this.callEvent("onHide",[]);
	}
	
	this._isVisible = function() {
		return (this.base.style.display!="none");
	}
	
	this._rangeActive = false;
	this._rangeFrom = null;
	this._rangeTo = null;
	this._rangeSet = {};
	
	this.setInsensitiveDays = function(d) {
		
		// !works in append mode
		var t = this._extractDates(d);
		for (var q=0; q<t.length; q++) this._rangeSet[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		
		this._drawMonth(this._activeMonth);
		
	}
	
	this.clearInsensitiveDays = function() {
		this._clearRangeSet();
		this._drawMonth(this._activeMonth);
	}
	
	this._holidays = {};
	this.setHolidays = function(r) {
		if (r == null) {
			this._clearHolidays();
		} else if (r != null) {
			var t = this._extractDates(r);
			for (var q=0; q<t.length; q++) this._holidays[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._extractDates = function(r) {
		// r = array of dates or comma-separated string list
		// return array with dates
		if (typeof(r) == "string" || r instanceof Date) r = [r];
		var t = [];
		for (var q=0; q<r.length; q++) {
			if (typeof(r[q]) == "string") {
				var e = r[q].split(",");
				for (var w=0; w<e.length; w++) t.push(this._strToDate(e[w]));
			} else if (r[q] instanceof Date) {
				t.push(r[q]);
			}
		}
		return t;
	}
	
	this._clearRange = function() {
		this._rangeActive = false;
		this._rangeType = null;
		this._rangeFrom = null;
		this._rangeTo = null;
	}
	
	this._clearRangeSet = function() {
		for (var a in this._rangeSet) {
			this._rangeSet[a] = null;
			delete this._rangeSet[a];
		}
	}
	
	this._clearHolidays = function() {
		for (var a in this._holidays) {
			this._holidays[a] = null;
			delete this._holidays[a];
		}
	}
	
	this._isOutOfRange = function(time) {
		
		if (this._rangeSet[time] == true) return true;
		
		if (this._rangeActive) {
			
			if (this._rangeType == "in" && (time<this._rangeFrom || time>this._rangeTo)) return true;
			if (this._rangeType == "out" && (time>=this._rangeFrom && time<=this._rangeTo)) return true;
			if (this._rangeType == "from" && time<this._rangeFrom)return true;
			if (this._rangeType == "to" && time>this._rangeTo) return true;
		}
		
		var t0 = new Date(time);
		
		if (this._rangeWeek) {
			if (this._rangeWeekData[t0.getDay()] === true) return true;
		}
		
		if (this._rangeMonth) {
			if (this._rangeMonthData[t0.getDate()] === true) return true;
		}
		
		if (this._rangeYear) {
			if (this._rangeYearData[t0.getMonth()+"_"+t0.getDate()] === true) return true;
		}
		
		return false;
		
	}
	
	this.clearSensitiveRange = function() {
		this._clearRange();
		this._drawMonth(this._activeMonth);
	}
	
	this.setSensitiveRange = function(from, to, ins) {
		
		var f = false;
		
		// set range
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "in";
			
			f = true;
		}
		
		// set range "from date"
		if (!f && from != null && to == null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = null;
			
			if (ins === true) this._rangeFrom++;
			
			this._rangeActive = true;
			this._rangeType = "from";
			
			f = true;
			
		}
		
		// set range "to date"
		if (!f && from == null && to != null) {
			
			if (!(to instanceof Date)) to = this._strToDate(to);
			this._rangeFrom = null;
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			
			if (ins === true) this._rangeTo--;
			
			this._rangeActive = true;
			this._rangeType = "to";
			
			f = true;
			
		}
		
		if (f) this._drawMonth(this._activeMonth);
	}
	
	this.setInsensitiveRange = function(from, to) {
		
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "out";
			
			this._drawMonth(this._activeMonth);
			return;
		}
		
		if (from != null && to == null) {
			this.setSensitiveRange(null, from, true);
			return;
		}
		
		if (from == null && to != null) {
			this.setSensitiveRange(to, null, true);
			return;
		}
		
	}
	
	//
	this.disableDays = function(mode, d) {
		
		if (mode == "week") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeWeekData) this._rangeWeekData = {};
			for (var a in this._rangeWeekData) {
				this._rangeWeekData[a] = false;
				delete this._rangeWeekData[a];
			}
			
			for (var q=0; q<d.length; q++) {
				this._rangeWeekData[d[q]] = true;
				if (d[q] == 7) this._rangeWeekData[0] = true;
			}
			this._rangeWeek = true;
		}
		
		if (mode == "month") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeMonthData) this._rangeMonthData = {};
			for (var a in this._rangeMonthData) {
				this._rangeMonthData[a] = false;
				delete this._rangeMonthData[a];
			}
			for (var q=0; q<d.length; q++) this._rangeMonthData[d[q]] = true;
			
			this._rangeMonth = true;
		}
		
		if (mode == "year") {
			
			// !! works in replace mode
			
			var t = this._extractDates(d);
			
			if (!this._rangeYearData) this._rangeYearData = {};
			for (var a in this._rangeYearData) {
				this._rangeYearData[a] = false;
				delete this._rangeYearData[a];
			}
			for (var q=0; q<t.length; q++) this._rangeYearData[t[q].getMonth()+"_"+t[q].getDate()] = true;
			
			this._rangeYear = true;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	this.enableDays = function(mode) {
		
		if (mode == "week") {
			this._rangeWeek = false;
		}
		
		if (mode == "month") {
			this._rangeMonth = false;
		}
		
		if (mode == "year") {
			this._rangeYear = false;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	
	/* tooltips */
	
	this._tipData = {};
	this._tipTM = null;
	this._tipTMTime = 400;
	this._tipEvs = false;
	this._tipPopup = null;
	this._tipCellDate = null;
	this._tipCellDim = null;
	
	this.setTooltip = function(dateX, text, showIcon, usePopup) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = { text: text, showIcon: showIcon, usePopup: usePopup };
		}
		this._drawMonth(this._activeMonth);
	}
	
	this.clearTooltip = function(dateX) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = null;
			delete this._tipData[k];
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._initTooltipPopup = function() {
		
		if (this._tipEvs) return;
		
		this.attachEvent("onMouseOver", function(d){
			var k = new Date(d.getFullYear(),d.getMonth(),d.getDate(),0,0,0,0).getTime();
			if (this._tipData[k] != null) {
				if (this._tipTM) window.clearTimeout(this._tipTM);
				this._tipCellDate = d;
				this._tipCellDim = this.getCellDimension(d);
				this._tipText = this._tipData[k].text;
				this._tipTM = window.setTimeout(this._showTooltipPopup,this._tipTMTime);
			}
		});
		
		this.attachEvent("onMouseOut", this._hideTooltipPopup);
		
		this._tipEvs = true;
	}
	this._showTooltipPopup = function(text,x,y,w,h) {
		if (!that._tipPopup) that._tipPopup = new dhtmlXPopup({mode:"top"});
		that._tipPopup.attachHTML(that._tipText);
		that._tipPopup.show(that._tipCellDim.x, that._tipCellDim.y, that._tipCellDim.w, that._tipCellDim.h);
		that.callEvent("onPopupShow",[that._tipCellDate]);
	}
	
	this._hideTooltipPopup = function() {
		if (this._tipTM) window.clearTimeout(this._tipTM);
		if (this._tipPopup != null && this._tipPopup.isVisible()) {
			this._tipPopup.hide();
			this.callEvent("onPopupHide",[this._tipCellDate]);
		}
	}
	
	this.getPopup = function() {
		return this._tipPopup;
	}
	
	this.getCellDimension = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return null;
		
		var t = new Date(dateX.getFullYear(),dateX.getMonth(),dateX.getDate(),0,0,0,0).getTime();
		
		var k = null;
		
		for (var q=0; q<this.contDates.childNodes.length; q++) {
			for (var w=0; w<this.contDates.childNodes[q].childNodes.length; w++) {
				var p = this.contDates.childNodes[q].childNodes[w];
				if (p._date != null && p._date.getTime() == t) k = { x: window.dhx4.absLeft(p), y: window.dhx4.absTop(p), w: p.offsetWidth, h: p.offsetHeight };
				p = null;
			}
		}
		
		return k;
	}
	
	/* other */
	this._updateFromInput = function(t) {
		if (this._nullInInput && ((t.value).replace(/\s/g,"")).length == 0) {
			if (this.checkEvent("onBeforeChange")) {
				if (!this.callEvent("onBeforeChange",[null])) {
					// revert value
					this._updateInp();
					return;
				}
			}
			this.setDate(null);
		} else {
			this._updateDateStr(t.value);
		}
		t = null;
	}
	
	// global events
	this._doOnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// completely close alien calendar (both selector and container) inly if any assigned input clicked
		// otherwise hide selector and container separately
		if (t._dhtmlxcalendar_uid && t._dhtmlxcalendar_uid != that._activeInp && that._isVisible() && that._activeInp) {
			that._hide();
			return;
		}
		if (!t._dhtmlxcalendar_uid || !that.i[t._dhtmlxcalendar_uid]) { // !that.i[t._dhtmlxcalendar_uid] means alien input, for several calendar instances
			if (that._isSelectorVisible()) that._hideSelector(); else if (!that._hasParent && that._isVisible()) that._hide();
		}
	}
	
	this._doOnKeyDown = function(e) {
		e = e||event;
		if (e.keyCode == 27 || e.keyCode == 13) {
			if (that._isSelectorVisible()) that._hideSelector(); else if (that._isVisible() && !that._hasParent) that._hide();
		}
	}
	
	// inputs events
	this._doOnInpClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (!that._listenerEnabled) {
			that._updateFromInput(t);
		}
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnInpKeyUp = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (e.keyCode == 13 || !t._dhtmlxcalendar_uid) return;
		// otherwise try to update calendar's date
		if (!that._listenerEnabled) that._updateFromInput(t);
	}
	
	this._doOnBtnClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (that.i[t._dhtmlxcalendar_uid].input != null) that._updateFromInput(that.i[t._dhtmlxcalendar_uid].input);
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnUnload = function() {
		if (that && that.unload) that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		document.body.addEventListener("click", that._doOnClick, false);
		window.addEventListener("keydown", that._doOnKeyDown, false);
		window.addEventListener("unload", that._doOnUnload, false);
		if (this.conf.touch == true) document.body.addEventListener("touchstart", that._doOnClick, false);
	} else {
		document.body.attachEvent("onclick", that._doOnClick);
		document.body.attachEvent("onkeydown", that._doOnKeyDown);
		window.attachEvent("onunload", that._doOnUnload);
	}
	
	this.attachObj = function(obj) {
		var a = window.dhx4.newId();
		if (typeof(obj) == "string") {
			// id
			this.i[a] = {input:document.getElementById(obj)};
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom obj
			this.i[a] = {input:obj};
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			// object
			this.i[a] = {};
			if (obj.input != null) this.i[a].input = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input);
			if (obj.button != null) this.i[a].button = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button);
		}
		this._attachEventsToObject(a);
		return a;
	}
	
	this.detachObj = function(obj) {
		var a = null;
		if (this.i[obj] != null) {
			// direct id
			a = obj;
		} else if (typeof(obj) == "string") {
			// id
			obj = document.getElementById(obj);
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom element
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			if (a == null && obj.input != null) a = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input)._dhtmlxcalendar_uid;
			if (a == null && obj.button != null) a = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button)._dhtmlxcalendar_uid;
		}
		if (a != null && this.i[a] != null) {
			this._detachEventsFromObject(a);
			for (var b in this.i[b]) {
				this.i[a][b]._dhtmlxcalendar_uid = null;
				this.i[a][b] = null;
				delete this.i[a][b];
			}
			this.i[a] = null;
			delete this.i[a];
			return true;
		}
		return false;
	}
	
	this._attachEventsToObject = function(a) {
		if (this.i[a].button != null) {
			this.i[a].button._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.addEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.addEventListener("touchstart", that._doOnBtnClick, false);
			} else {
				this.i[a].button.attachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			this.i[a].input._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.addEventListener("click", that._doOnInpClick, false);
				this.i[a].input.addEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.addEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.attachEvent("onclick", that._doOnInpClick);
				this.i[a].input.attachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	this._detachEventsFromObject = function(a) {
		if (this.i[a].button != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.removeEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.removeEventListener("touchstart", that._doOnBtnClick, false);
				
			} else {
				this.i[a].button.detachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.removeEventListener("click", that._doOnInpClick, false);
				this.i[a].input.removeEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.removeEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.detachEvent("onclick", that._doOnInpClick);
				this.i[a].input.detachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	this._updateInp = function() {
		if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
			this.i[this._activeInp].input.value = this.getFormatedDate();
		}
	}
	
	// listener
	this.enableListener = function(t) {
		if (!t) return;
		if (typeof(window.addEventListener) == "function") {
			t.addEventListener("focus", that._listenerEvFocus, false);
			t.addEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.attachEvent("onfocus", that._listenerEvFocus);
			t.attachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this.disableListener = function(t) {
		if (!t) return;
		t._f0 = false;
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(window.addEventListener) == "function") {
			t.removeEventListener("focus", that._listenerEvFocus, false);
			t.removeEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.detachEvent("onfocus", that._listenerEvFocus);
			t.detachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this._startListener = function(t) {
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(t._v1) == "undefined") t._v1 = t.value;
		if (t._v1 != t.value) {
			this._updateFromInput(t);
			t._v1 = t.value;
		}
		if (t._f0) this._tmListener = window.setTimeout(function(){that._startListener(t);},100);
	}
	
	this._listenerEvFocus = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = true;
		that._startListener(t)
		t = null;
	}
	this._listenerEvBlur = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = false;
		t = null;
	}
	
	
	//
	for (var a in this.i) this._attachEventsToObject(a);
	
	// events
	window.dhx4._eventable(this);
	
	// event wrappers
	this._evOnArrowClick = function(args) {
		return this.callEvent("onArrowClick", args);
	}
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnMouseOut = function(args) {
		return this.callEvent("onMouseOut", args);
	}
	this._evOnMouseOver = function(args) {
		return this.callEvent("onMouseOver", args);
	}
	
	
	
	/* unload */
	
	this.unload = function() {
		
		this._activeDate = null;
		this._activeDateCell = null;
		this._activeInp = null;
		this._activeMonth = null;
		this._dateFormat = null;
		this._dateFormatRE = null;
		this._lastHover = null;
		
		if (this._tmListener) window.clearTimeout(this._tmListener);
		this._tmListener = null;
		
		/* main events */
		
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("click", that._doOnClick, false);
			window.removeEventListener("keydown", that._doOnKeyDown, false);
			window.removeEventListener("unload", that._doOnUnload, false);
			if (this.conf.touch == true) document.body.removeEventListener("touchstart", that._doOnClick, false);
		} else {
			document.body.detachEvent("onclick", that._doOnClick);
			document.body.detachEvent("onkeydown", that._doOnKeyDown);
			window.detachEvent("onunload", that._doOnKeyDown);
		}
		
		this._doOnClick = null;
		this._doOnKeyDown = null;
		this._doOnUnload = null;
		
		/* assigned inputs */
		
		for (var a in this.i) {
			// marker
			this.i[a]._dhtmlxcalendar_uid = null;
			
			// events
			this._detachEventsFromObject(a);
			this.disableListener(this.i[a].input);
			
			this.i[a] = null;
			delete this.i[a];
			
		}
		
		this.i = null;
		
		this._doOnInpClick = null;
		this._doOnInpKeyUp = null;
		
		/* clear events */
		window.dhx4._eventable(this, "clear");
		
		/* months */
		
		this.contMonth.onselectstart = null;
		
		// li
		this.contMonth.firstChild.firstChild.onclick = null;
		this.contMonth.firstChild.firstChild.ontouchstart = null;
		
		// arrows
		this.contMonth.firstChild.firstChild.firstChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.firstChild.onmouseout = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseout = null;
		
		while (this.contMonth.firstChild.firstChild.childNodes.length > 0) this.contMonth.firstChild.firstChild.removeChild(this.contMonth.firstChild.firstChild.lastChild);
		
		// li
		this.contMonth.firstChild.removeChild(this.contMonth.firstChild.firstChild);
		
		// ul
		this.contMonth.removeChild(this.contMonth.firstChild);
		
		// div
		this.contMonth.parentNode.removeChild(this.contMonth);
		this.contMonth = null;
		
		/* days */
		
		// li
		while (this.contDays.firstChild.childNodes.length > 0) this.contDays.firstChild.removeChild(this.contDays.firstChild.lastChild);
		
		// ul
		this.contDays.removeChild(this.contDays.firstChild);
		
		// div
		this.contDays.parentNode.removeChild(this.contDays);
		this.contDays = null;
		
		/* dates */
		
		this.contDates.onclick = null;
		this.contDates.ontouchstart = null;
		this.contDates.onmouseover = null;
		this.contDates.onmouseout = null;
		
		while (this.contDates.childNodes.length > 0) {
			while (this.contDates.lastChild.childNodes.length > 0) {
				// li
				this.contDates.lastChild.lastChild._css_date = null;
				this.contDates.lastChild.lastChild._css_month = null;
				this.contDates.lastChild.lastChild._css_weekend = null;
				this.contDates.lastChild.lastChild._css_hover = null;
				this.contDates.lastChild.lastChild._date = null;
				this.contDates.lastChild.lastChild._q = null;
				this.contDates.lastChild.lastChild._w = null;
				this.contDates.lastChild.removeChild(this.contDates.lastChild.lastChild);
			}
			// ul
			this.contDates.removeChild(this.contDates.lastChild);
		}
		
		// div
		this.contDates.parentNode.removeChild(this.contDates);
		this.contDates = null;
		
		/* time */
		
		this.contTime.firstChild.firstChild.onclick = null;
		this.contTime.firstChild.firstChild.ontouchstart = null;
		
		// labels
		while (this.contTime.firstChild.firstChild.childNodes.length > 0) this.contTime.firstChild.firstChild.removeChild(this.contTime.firstChild.firstChild.lastChild);
		
		// li
		this.contTime.firstChild.removeChild(this.contTime.firstChild.firstChild);
		
		// ul
		this.contTime.removeChild(this.contTime.firstChild);
		
		// div
		this.contTime.parentNode.removeChild(this.contTime);
		this.contTime = null;
		
		
		this._lastHover = null;
		
		/* selector */
		
		this._unloadSelector("month");
		this._unloadSelector("year");
		this._unloadSelector("hours");
		this._unloadSelector("minutes");
		
		// selector cover
		if (this._selCover) {
			this._selCover.parentNode.removeChild(this._selCover);
			this._selCover = null;
		}
		
		// selector object
		if (this._sel) {
			
			for (var a in this._sel._ta) this._sel._ta[a] = null;
			this._sel._ta = null;
			this._sel._t = null;
			
			this._sel.onmouseover = null;
			this._sel.onmouseout = null;
			
			// td
			while (this._sel.firstChild.firstChild.firstChild.childNodes.length > 0) {
				this._sel.firstChild.firstChild.firstChild.lastChild.onclick = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseover = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseout = null;
				this._sel.firstChild.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild.lastChild);
			}
			
			// tr
			this._sel.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild);
			
			// tbody
			this._sel.firstChild.removeChild(this._sel.firstChild.firstChild);
			
			// table and arrow div
			while (this._sel.childNodes.length > 0) this._sel.removeChild(this._sel.lastChild);
			
			// object
			this._sel.parentNode.removeChild(this._sel);
			this._sel = null;
		}
		
		
		/* base */
		
		this.base.onclick = null;
		this.base.onmousedown = null;
		this.base.ontouchstart = null;
		this.base.onmouseout = null;
		this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		/* methods */
		
		this._clearDayHover = null;
		this._clearSelHover = null;
		this._doOnSelectorChange = null;
		this._doOnSelectorShow = null;
		this._drawMonth = null;
		this._fixLength = null;
		this._ifrSize = null;
		this._hide = null;
		this._hideSelector = null;
		this._initSelector = null;
		this._isSelectorVisible = null;
		this._isVisible = null;
		this._scrollYears = null;
		this._show = null;
		this._showSelector = null;
		this._strToDate = null;
		this._updateActiveHours = null;
		this._updateActiveMinutes = null;
		this._updateActiveMonth = null;
		this._updateActiveYear = null;
		this._updateCellStyle = null;
		this._updateDateStr = null;
		this._updateVisibleHours = null;
		this._updateVisibleMinutes = null;
		this._updateYearsList = null;
		this.enableIframe = null;
		this.hide = null;
		this.hideTime = null;
		this.setDate = null;
		this.setDateFormat = null;
		this.setYearsRange = null;
		this.show = null;
		this.showTime = null;
		this.unload = null;
		
		/* popup */
		if (this._tipPopup != null) {
			this._tipPopup.unload();
			this._tipPopup = null;
		}
		
		for (var a in this) delete this[a];
		
		a = that = null;
		
	}
	
	
	// set init date
	this.setDate(this._activeDate);
	
	return this;
};

dhtmlXCalendarObject.prototype.lang = "en";
dhtmlXCalendarObject.prototype.langData = {
	"en": {
		dateformat: "%Y-%m-%d",
		hdrformat: "%F %Y",
		monthesFNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
		monthesSNames: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
		daysFNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
		daysSNames: ["Su","Mo","Tu","We","Th","Fr","Sa"],
		weekstart: 1,
		weekname: "w",
		today: "Today",
		clear: "Clear"
	}
};

dhtmlXCalendarObject.prototype._buildMonthHdr = function(val) {
	var that = this;
	var z = function(t) {
		return (String(t).length==1?"0"+String(t):t);
	}
	var w = function(type, str) {
		return "<span class='dhtmlxcalendar_month_label_"+type+"'>"+str+"</span>";
	}
	var format = String(this.langData[this.lang].hdrformat||("%F %Y")).replace(/%[a-z]/gi, function(t){
		switch (t) {
			case "%m": return w("month", z(val.getMonth()+1));
			case "%n": return w("month", val.getMonth()+1);
			case "%M": return w("month", that.langData[that.lang].monthesSNames[val.getMonth()]);
			case "%F": return w("month", that.langData[that.lang].monthesFNames[val.getMonth()]);
			case "%y": return w("year", z(val.getYear()%100));
			case "%Y": return w("year", val.getFullYear());
			case "%%": return "%";
			default: return t;
		}
	});
	that = z = w = null;
	return format;
};

dhtmlXCalendarObject.prototype.enableIframe = function(mode) {
	if (mode == true) {
		if (!this._ifr) {
			this._ifr = document.createElement("IFRAME");
			this._ifr.frameBorder = 0;
			this._ifr.border = 0;
			this._ifr.setAttribute("src","javascript:false;");
			this._ifr.className = "dhtmlxcalendar_ifr";
			this._ifr.onload = function(){
				this.onload = null;
				this.contentWindow.document.open("text/html", "replace");
				this.contentWindow.document.write("<html><head><style>html,body{width:100%;height:100%;overflow:hidden;margin:0px;}</style></head><body</body></html>");
			}
			this.base.parentNode.insertBefore(this._ifr, this.base);
			this._ifrSize();
		}
	} else {
		if (this._ifr) {
			this._ifr.parentNode.removeChild(this._ifr);
			this._ifr = null;
		}
	}
};

dhtmlXCalendarObject.prototype._ifrSize = function() {
	if (this._ifr) {
		this._ifr.style.left = this.base.style.left;
		this._ifr.style.top = this.base.style.top;
		this._ifr.style.width = this.base.offsetWidth+"px";
		this._ifr.style.height = this.base.offsetHeight+"px";
	}
};

dhtmlxCalendarObject = dhtmlXCalendarObject;

dhtmlXCalendarObject.prototype._dateStrings = function() {
	var k = this.langData[this.lang];
	return {monthFullName: k.monthesFNames, monthShortName: k.monthesSNames, dayFullName: k.daysFNames, dayShortName: k.daysSNames};
};
dhtmlXCalendarObject.prototype._strToDate = function(val, format) {
	return window.dhx4.str2date(val, format||this._dateFormat, this._dateStrings());
};
dhtmlXCalendarObject.prototype._dateToStr = function(val, format) {
	return window.dhx4.date2str(val, format||this._dateFormat, this._dateStrings());
};


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

window.dhtmlxDblCalendarObject = window.dhtmlXDoubleCalendarObject = window.dhtmlXDoubleCalendar = function(parentId) {
	
	var that = this;
	
	this.leftCalendar = new dhtmlXCalendarObject(parentId);
	this.leftCalendar.hideTime();
	this.rightCalendar = new dhtmlXCalendarObject(parentId);
	this.rightCalendar.hideTime();
	
	this.leftCalendar.attachEvent("onClick", function(d){
		that._updateRange("rightCalendar", d, null);
		that._evOnClick(["left", d]);
	});
	
	this.rightCalendar.attachEvent("onClick", function(d){
		that._updateRange("leftCalendar", null, d);
		that._evOnClick(["right", d]);
	});
	
	this.leftCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["left",d]);
	});
	
	this.rightCalendar.attachEvent("onBeforeChange", function(d){
		return that._evOnBeforeChange(["right",d]);
	});
	
	this.show = function() {
		this.leftCalendar.show();
		this.rightCalendar.base.style.marginLeft=this.leftCalendar.base.offsetWidth-1+"px";
		this.rightCalendar.show();
	}
	
	this.hide = function() {
		this.leftCalendar.hide();
		this.rightCalendar.hide();
	}
	
	this.setDateFormat = function(t) {
		this.leftCalendar.setDateFormat(t);
		this.rightCalendar.setDateFormat(t);
	}
	
	this.setDates = function(d0, d1) {
		if (d0 != null) this.leftCalendar.setDate(d0);
		if (d1 != null) this.rightCalendar.setDate(d1);
		this._updateRange();
	}
	
	this._updateRange = function(obj, from, to) {
		if (arguments.length == 3) {
			(obj=="leftCalendar"?this.leftCalendar:this.rightCalendar).setSensitiveRange(from, to);
		} else {
			this.leftCalendar.setSensitiveRange(null, this.rightCalendar.getDate());
			this.rightCalendar.setSensitiveRange(this.leftCalendar.getDate(), null);
		}
	}
	
	this.getFormatedDate = function() {
		return this.leftCalendar.getFormatedDate.apply(this.leftCalendar, arguments);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		this.leftCalendar.unload();
		this.rightCalendar.unload();
		this.leftCalendar = this.rightCalendar = null;
		
		this._updateRange = null;
		this._evOnClick = null;
		this._evOnBeforeChange = null;
		this.show = null;
		this.hide = null;
		this.setDateFormat = null;
		this.setDates = null;
		this.getFormatedDate = null;
		this.unload = null;
		
		that = null;
	}
	
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnBeforeChange = function(args) {
		return this.callEvent("onBeforeChange", args);
	}
	
	window.dhx4._eventable(this);
	
	return this;
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCombo(parentId, formName, width, optionType, tabIndex) {
	
	// console.info("allow html in options?");
	// console.info("add placeholder?");
	// console.info("iframe for IE6");
	
	var that = this;
	var apiObj = null;
	var skin = null;
	if (typeof(parentId) == "object" && !parentId.tagName) {
		apiObj = parentId;
		parentId = apiObj.parent;
		width = apiObj.width;
		formName = apiObj.name;
		optionType = apiObj.mode;
		skin = apiObj.skin;
	}
	
	this.cont = (typeof(parentId)=="string"?document.getElementById(parentId):parentId);
	
	this.conf = {
		skin: null,
		form_name: formName||"dhxcombo",
		combo_width: (parseInt(width)||this.cont.offsetWidth||120)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0),
		combo_image: false,
		combo_focus: false,
		opts_type: (typeof(optionType)=="string" && typeof(this.modes[optionType]) !="undefined" ? optionType : "option"),
		opts_count: 8, // count of visible items
		opts_count_min: 3, // min count of visible items (when near screen edge)
		opts_width: null,
		item_h: null,
		list_zi_id: window.dhx4.newId(), // "dhxcombo_list_"+window.dhx4.newId(), // z-index id
		allow_free_text: true,
		allow_empty_value: true, // allow empty value in combo (when free_text not allowed)
		free_text_empty: false, // when free text not allowed and incorrect value entered restore last selected value or reset to empty
		enabled: true,
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0), // 1 for IE8-
		// search in r/o mode
		ro_mode: false,
		ro_text: "",
		ro_tm: null,
		ro_tm_time: 750,
		// images
		img_path: "",
		img_def: "",
		img_def_dis: true, // if set to true - img_def used for disabled
		// templates
		template: {
			header: true,    // render header in multicolumn mode, added in 4.5.1
			input:  "#text#",// template for top-input
			option: "#text#" // template for option text
		},
		// filtering
		f_func: null,
		f_mode: false, // "start", "between"
		f_url: false,
		f_cache: false,
		f_cache_data: {},
		f_dyn: false,
		f_dyn_end: false, // check if last response have opts
		f_mask: "", // last loaded mask from server
		f_ac: true, // autocomplete if f_mode:"start" filtering mode
		f_ac_text: "",
		f_server_tm: null,
		f_server_last: "",
		f_loading: false,
		// scroll tm
		s_tm: null,
		s_time: 200,
		s_mode: "select", // type of subload request calling, 'select' last item or 'scroll' to last item
		// hover-selected
		last_hover: null,
		last_selected: null,
		last_match: null,
		last_text: "",
		last_value: "",
		tm_hover: null,
		tm_confirm_blur: null,
		// nav settings
		clear_click: false,
		clear_blur: false,
		clear_bsp: false,
		clear_key: false,
		// skin params
		i_ofs: 23, // top-image offset
		sp: {
			dhx_skyblue: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			dhx_web: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 0},
			dhx_terrace: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			material: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 1}
		},
		// autowidth for columns mode
		col_w: null
	};
	
	this.conf.combo_image = (this.modes[this.conf.opts_type].image==true);
	
	this.t = {}; // options will here
	
	this.base = document.createElement("DIV");
	//this.base.className = "dhxcombo_"+this.conf.skin;
	
	this.base.style.width = this.conf.combo_width+"px";
	this.base.innerHTML = "<input type='text' class='dhxcombo_input' style='width:"+(this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0))+"px;"+(this.conf.combo_image?"margin-left:"+this.conf.i_ofs+"px;":"")+"' autocomplete='off'>"+
				"<input type='hidden' value=''>"+ // value
				"<input type='hidden' value='false'>"+ // new_value
				"<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div>"+
				(this.conf.combo_image?"<div class='dhxcombo_top_image'>"+this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled)+"</div>":"");
	this.cont.appendChild(this.base);
	
	this.list = document.createElement("DIV");
	this.list._listId = window.dhx4.newId(); // used when combo attached to popup
	this.list.style.display = "none";
	document.body.insertBefore(this.list, document.body.firstChild);
	
	// auto-subload logic
	this._doOnListScroll = function() {
		if (that.conf.s_tm != null) window.clearTimeout(that.conf.s_tm);
		that.conf.s_tm = window.setTimeout(that._doOnListScrollAction, that.conf.s_time);
	}
	this._doOnListScrollAction = function() {
		that.conf.s_tm = null;
		if (that.conf.s_mode == "scroll" && that.list.scrollHeight - that.list.scrollTop - 10 < that.list.clientHeight) {
			that._subloadRequest();
		}
	}
	if (typeof(window.addEventListener) == "function") {
		this.list.addEventListener("scroll", this._doOnListScroll, false);
	} else {
		this.list.attachEvent("onscroll", this._doOnListScroll);
	}
	
	// apply skin
	this.setSkin(skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxcombo")||"material");
	
	this._updateTopImage = function(id) {
		
		if (!this.conf.combo_image) return;
		
		if (id != null) {
			this.base.lastChild.innerHTML = this.t[id].obj.getTopImage(this.t[id].item, this.conf.enabled);
		} else {
			this.base.lastChild.innerHTML = this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled);
		}
		 
	}
	
	/* filtering */
	
	this._filterOpts = function(hiddenMode) {
		
		if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
		
		var k = String(this.base.firstChild.value).replace(new RegExp(this._fixRE(this.conf.f_ac_text)+"$","i"),"");
		
		
		if (this.conf.f_server_last == k.toLowerCase()) {
			this._checkForMatch();
			return;
		}
		
		// check if user-filter specified
		if (this.conf.f_url != null && this.checkEvent("onDynXLS")) {
			this.conf.f_server_last = k.toLowerCase();
			this.callEvent("onDynXLS", [k]);
			return;
		}
		
		if (this.conf.f_url != null) {
			// server
			if (k.length == 0) {
				this.conf.f_server_last = k.toLowerCase();
				this.clearAll();
				return;
			}
			// check cache
			if (this.conf.f_cache == true && this.conf.f_cache_data[k] != null) {
				// load from cache
				this.clearAll();
				this.conf.f_server_last = k.toLowerCase();
				for (var q=0; q<this.conf.f_cache_data[k].data.length; q++) {
					this.load(this.conf.f_cache_data[k].data[q]);
				}
				if (this.conf.f_dyn) {
					this.conf.f_dyn_end = this.conf.f_cache_data[k].dyn_end;
					this.conf.f_mask = this.conf.f_cache_data[k].mask;
				}
				if (hiddenMode !== true) {
					this._showList(true);
					this._checkForMatch();
				}
			} else {
				this.conf.f_server_tm = window.setTimeout(function(){
					that.conf.f_server_last = k.toLowerCase();
					that.conf.f_mask = k;
					var params = "mask="+encodeURIComponent(k);
					if (that.conf.f_dyn) {
						params += "&pos=0";
						that.conf.f_dyn_end = false;
					}
					var callBack = function(r) {
						// cache
						if (that.conf.f_cache) {
							if (!that.conf.f_cache_data[k]) that.conf.f_cache_data[k] = {data:[],dyn_end:false,mask:k};
							that.conf.f_cache_data[k].data.push(r.xmlDoc.responseXML);
						}
						// load opts
						that.clearAll();
						that.load(r.xmlDoc.responseXML);
						
						var v = (that.base.offsetWidth > 0 && that.base.offsetHeight > 0);
						if (v == true && that.conf.enabled == true && that.conf.combo_focus == true && hiddenMode !== true) {
							// autocomplete if any
							if (that.conf.f_ac && that.conf.f_mode == "start" && that.conf.clear_bsp == false && that.list.firstChild != null) {
								// autocomplete
								var sid = that.list.firstChild._optId;
								var text = String(that.t[sid].obj.getText(that.list.firstChild, true));
								if (k == that.base.firstChild.value && String(text).toLowerCase().indexOf(String(k).toLowerCase()) === 0) {
									that.base.firstChild.value = text;
									that.conf.f_ac_text = text.substr(k.length);
									that._selectRange(k.length, text.length);
								}
							}
							that._showList(true);
							that._checkForMatch();
						}
						callBack = null;
					}
					if (window.dhx4.ajax.method == "post") {
						window.dhx4.ajax.post(that.conf.f_url, params, callBack);
					} else if (window.dhx4.ajax.method == "get") {
						window.dhx4.ajax.get(that.conf.f_url+(String(that.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
					}
				},200);
			}
		} else {
			// client
			this.conf.f_server_last = k.toLowerCase();
			
			var r = (k.length==0?true:new RegExp((this.conf.f_mode=="start"?"^":"")+this._fixRE(k),"i"));
			
			var acText = null;
			
			for (var a in this.t) {
				var t = false;
				if (r !== true) {
					if (this.conf.f_func != null) {
						var option = this._getOption(this.t[a].item._optId, q);
						t = (this.conf.f_func.apply(window, [k, option]) == true);
					} else {
						var text = this.t[a].obj.getText(this.t[a].item, true);
						t = (r.test(text) == true);
					}
				}
				if (r === true || t == true) {
					this.t[a].item.style.display = "";
					if (acText == null && k.length > 0) acText = String(this.t[a].obj.getText(this.t[a].item, true));
				} else {
					this.t[a].item.style.display = "none";
				}
			}
			
			if (this.conf.f_ac && this.conf.f_mode == "start" && this.conf.clear_bsp == false && acText != null) {
				this.conf.f_ac_text = acText.replace(new RegExp("^"+k,"i"),"");
				this.base.firstChild.value = acText;
				this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
			}
			
			// if any text selected and backspace pressed - clear highlight
			// usefull for "between" mode
			if (this.conf.f_mode == "between" && this.conf.clear_bsp == true) {
				this._checkForMatch(true);
			}
			
			if (hiddenMode !== true) {
				this._showList(true);
				this._checkForMatch();
			}
		}
	}
	
	this._searchRO = function(s) {
		if (this.conf.ro_tm) window.clearTimeout(this.conf.ro_tm);
		this.conf.ro_text += s;
		this._showList();
		for (var q=0; q<this.list.childNodes.length; q++) {
			var sid = this.list.childNodes[q]._optId;
			var text = String(this.t[sid].obj.getText(this.list.childNodes[q], true)).toLowerCase();
			if (text.indexOf(this.conf.ro_text) === 0) {
				this._setSelected(sid, true, true);
				this._confirmSelect("script", false);
				break;
			}
		}
		this.conf.ro_tm = window.setTimeout(function(){that.conf.ro_text="";}, this.conf.ro_tm_time);
	}
	
	this._fixRE = function(t) {
		return String(t).replace(/[\\\^\$\*\+\?\.\(\)\|\{\}\[\]]/gi, "\\$&");
	}
	
	// data loading
	this._initObj = function(data) {
		if (typeof(data.template) != "undefined") this.setTemplate(data.template);
		if (data.add != true && this.conf.f_loading != true) this.clearAll(false);
		this.addOption(data.options);
	}
	
	this._xmlToObj = function(data, selectToObj, selectedIndex) {
		
		/*
		xml format:
		<complete add="true">
			<template>
				<input>...</input>
				<option>...</option>
				<header>false</header> <!-- do not render header for multi-column mode, in 4.5.1 -->
				<columns>
					<column width="..." css="option css optional">
						<header>text in header</header>
						<option>template for text in option cell</option>
					</column>
				</columns>
			</template>
			<option value="xx" selected="1" img_src="icon_url" checked="1" css="some text">option text</option>
		</complete>
		
		img_src - also add the 4th parameter to combobox constructor - "image"
		checked - checkbox state, for combo with "checkbox" type, 0 by default
		*/
		
		var t = {add:false,options:[]};
		
		var root = (selectToObj==true?data:data.getElementsByTagName("complete"));
		
		if (root.length > 0) {
			if (window.dhx4.s2b(root[0].getAttribute("add")) == true) t.add = true;
			var nodes = root[0].childNodes;
			for (var q=0; q<nodes.length; q++) {
				if (typeof(nodes[q].tagName) != "undefined") {
					
					// template
					if (String(nodes[q].tagName).toLowerCase() == "template") {
						
						var template = {};
						
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							
							var n = nodes[q].childNodes[w];
							
							if (n.tagName != null) {
								
								// default values
								var k = n.tagName;
								if (typeof(this.conf.template[k]) != "undefined") {
									template[k] = window.dhx4._xmlNodeValue(n);
								}
								
								// columns if any
								if (k == "columns") {
									for (var e=0; e<n.childNodes.length; e++) {
										
										var col = n.childNodes[e];
										
										if (col.tagName != null && col.tagName == "column") {
											
											var colData = {};
											
											// attrs
											// <column width="xx" css="xx" header="xx" option="xx"/>
											for (var a in {width:1, css:1, header:1, option:1}) {
												if (col.getAttribute(a) != null) colData[a] = col.getAttribute(a);
											}
											
											// extra header and option if any
											// <column><option><header>..</header><option>..</option></column>
											for (var a in {header:1, option:1}) {
												var h = col.getElementsByTagName(a);
												if (h[0] != null && h[0].firstChild != null) colData[a] = window.dhx4._xmlNodeValue(h[0]);
											}
											
											if (template.columns == null) template.columns = [];
											template.columns.push(colData);
											
										}
										
										col = null;
										
									}
									
								}
							}
							n = null;
						}
						this.setTemplate(template);
					}
					// option
					if (String(nodes[q].tagName).toLowerCase() == "option") {
						var optSelected = false;
						if (selectToObj == true) {
							optSelected = (t.options.length==selectedIndex);
						} else {
							optSelected = window.dhx4.s2b(nodes[q].getAttribute("selected"));
						}
						var opt = {
							value: nodes[q].getAttribute("value"),
							text: window.dhx4._xmlNodeValue(nodes[q]),
							selected: optSelected,
							checked: window.dhx4.s2b(nodes[q].getAttribute("checked"))
						};
						// images
						for (var a in {img:1,img_dis:1,img_src:1,img_src_dis:1,css:1}) {
							if (nodes[q].getAttribute(a) != null) opt[a] = nodes[q].getAttribute(a);
						}
						// text
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							if (nodes[q].childNodes[w].tagName != null && String(nodes[q].childNodes[w].tagName).toLowerCase() == "text") {
								opt.text = {};
								var n = nodes[q].childNodes[w];
								for (var e=0; e<n.childNodes.length; e++) {
									if (n.childNodes[e].tagName != null) {
										opt.text[n.childNodes[e].tagName] = window.dhx4._xmlNodeValue(n.childNodes[e]);
									}
								}
							}
						}
						t.options.push(opt);
					}
				}
			}
			root = nodes = null;
		}
		return t;
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "complete", {data:true});
	window.dhx4._eventable(this);
	
	
	this._getNearItem = function(item, dir) {
		// return nearest next/prev visible item or null
		var sid = null;
		while (item != null) {
			item = item[dir<0?"previousSibling":"nextSibling"];
			if (sid == null && item != null && item.style.display == "" && item._optId != null) {
				sid = item;
				item = null;
			}
		}
		return sid;
	}
	
	this.setName(this.conf.form_name);
	
	// list hightlight/select
	this._doOnListMouseMove = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
				that._setSelected(t._optId, false, false, true);
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseDown = function(e) {
		e = e||event;
		e.cancelBubble = true;
		that.conf.clear_click = true;
		window.setTimeout(function(){that.base.firstChild.focus();},1);
	}
	
	this._doOnListMouseUp = function(e) {
		// select new item
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				var r = true;
				if (typeof(that.t[t._optId].obj.optionClick) == "function" && that.t[t._optId].obj.optionClick(t, e, that) !== true) r = false;
				if (r) {
					that._setSelected(t._optId, null, true);
					that._confirmSelect("click");
				}
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseOut = function(e) {
		// when cursor out of item - clear hover or highlight selected
		if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
		that.conf.tm_hover = window.setTimeout(function(){
			// select last selected
			var sId = that.conf.last_match||that.conf.last_selected;
			if (that.conf.last_match == null && that.t[sId] != null) {
				// but if no match found, check if entered text is same as in option
				if (that.base.firstChild.value != that.t[sId].obj.getText(that.t[sId].item, true)) sId = null;
			}
			that._setSelected(sId, null, true, true);
		},1);
	}
	
	this._doOnBaseMouseDown = function(e) {
		
		if (!that.conf.enabled) return;
		
		that.conf.clear_click = true;
		
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		
		var t = e.target||e.srcElement;
		if (t != this.firstChild) {
			// focus input if list opened by clicking on arrow
			window.setTimeout(function(){that.base.firstChild.focus();},1);
			
			// top-image click?
			var p = t;
			while (p != this && p != null) {
				if (p == this.lastChild) {
					if (typeof(that.modes[that.conf.opts_type].topImageClick) == "function") {
						var t_id = (that.conf.last_hover||that.conf.last_selected);
						var t_item = (t_id != null?that.t[t_id].item:null);
						if (that.modes[that.conf.opts_type].topImageClick(t_item, that) !== true) {
							t_id = t_item = null;
							return;
						}
					}
					p = null;
				} else {
					p = p.parentNode;
				}
			}
			
		}
		
		if (that._isListVisible()) {
			that._hideList();
		} else {
			if (t != this.firstChild) that.conf.clear_blur = true;
			that._showList();
			that._setSelected(that.conf.last_selected, true, true);
		}
		t = null;
	}
	
	// body click -> hide list if any
	this._doOnBodyMouseDown = function() {
		if (that.conf.clear_click) {
			that.conf.clear_click = false;
			return;
		}
		that._confirmSelect("blur");
	}
	
	// input focus/blur
	this._doOnInputFocus = function() {
		that.conf.clear_blur = false;
		// if forus back to input - cancel confirm (occured when user clicked on arrow while list opened)
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		// ev
		if (that.conf.combo_focus == false) {
			that.conf.combo_focus = true;
			if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) == null) {
				that.base.className += " dhxcombo_actv";
			}
			that.callEvent("onFocus",[]);
		}
	}
	this._doOnInputBlur = function() {
		if (that.conf.clear_blur == true) {
			that.conf.clear_blur = false;
			return;
		}
		// start confirm tm
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		that.conf.tm_confirm_blur = window.setTimeout(function(){
			if (that.conf.clear_click == false) {
				// if (that._isListVisible()) that._hideList();
				that._confirmSelect("blur");
				that.conf.combo_focus = false;
				if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) != null) {
					that.base.className = that.base.className.replace(/\s*dhxcombo_actv/gi, "");
				}
				that.callEvent("onBlur",[]);
			}
		},20);
	}
	
	// input events, typing/filtering
	this._doOnInputKeyUp = function(e) {
		
		e = e||event;
		
		if (that.conf.f_mode != false) {
			that.conf.clear_bsp = (e.keyCode==8||e.keyCode==46); // backspace(8) and delete(46)
			that._filterOpts();
			return;
		} else {
			that._checkForMatch();
		}
	}
	
	this._doOnInputKeyDown = function(e) {
		
		e = e||event;
		
		// console.log("onkeypress ", e.keyCode, " ", e.charCode)
		
		// up (38) /down (40)
		if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._keyOnUpDown(e.keyCode==38?-1:1);
		}
		
		// F2
		if (e.keyCode == 113) {
			if (!that._isListVisible()) {
				that._showList();
				if (that.base.firstChild.value == that.conf.last_text) {
					that._setSelected(that.conf.last_selected, true, true);
					that.base.firstChild.value = that.conf.last_text;
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
				} else {
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
					if (that.conf.f_mode == false) that._checkForMatch();
				}
			} else {
				
			}
		}
		
		// esc
		if (e.keyCode == 27) {
			// cancel operation, restore last value
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._cancelSelect();
		}
		
		// enter
		if (e.keyCode == 13) {
			if (e.preventDefault) e.preventDefault(); // if combo attached to form
			that._confirmSelect("kbd");
		}
		
		// selection in r/o mode
		if (that.conf.ro_mode == true && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 65 && e.keyCode <= 90))) {
			that._searchRO(String.fromCharCode(e.keyCode).toLowerCase());
			e.cancelBubble = true;
		}
		
		that.conf.clear_key = true;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._doOnInputKeyPress = function(e) {
		if (that.conf.clear_key) {
			that.conf.clear_key = false;
			return;
		}
		e = e||event;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._keyOnUpDown = function(dir) {
		
		// select(just hover) next/prev item in a list
		
		var item = null;
		if (this.conf.last_hover) {
			item = this.t[this.conf.last_hover].item;
		} else if (this.conf.last_selected) {
			item = this.t[this.conf.last_selected].item;
		}
		
		if (!item && this._getListVisibleCount() == 0) return;
		if (item != null && item.style.display != "") item = null;
		
		this._showList();
		
		if (item != null) {
			// check if item highlighted
			if (this.t[item._optId].obj.isSelected(item)) item = this._getNearItem(item, dir);
		} else {
			item = this.list.firstChild;
			if (item.style.display != "") item = this._getNearItem(item, 1);
		}
		
		if (item == null) return; // first/last
		
		this._setSelected(item._optId, true, true);
		
		if (this.conf.f_mode == false) {
			this.base.firstChild.value = this.t[item._optId].obj.getText(item, true);
		} else {
			var text = String(this.t[item._optId].obj.getText(item, true));
			if (this.conf.f_mode == "start" && this.conf.f_ac == true) {
				if (text.toLowerCase().indexOf(this.conf.f_server_last) === 0) {
					// try to find match and select part of text
					this.conf.f_ac_text = text.substring(this.conf.f_server_last.length, text.length);
					this.base.firstChild.value = text;
					this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
				} else {
					// insert all text and select
					this.base.firstChild.value = text;
					this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
					this._selectRange(0, this.base.firstChild.value.length);
				}
			} else {
				// just insert text into main input
				this.base.firstChild.value = text;
				this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			}
		}
		
		//
		item = null;
	}
	
	this.conf.evs_nodes = [
		{node: document.body, evs: {mousedown: "_doOnBodyMouseDown"}},
		{node: this.base, evs: {mousedown: "_doOnBaseMouseDown"}},
		{node: this.base.firstChild, evs: {keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur"}},
		{node: this.list, evs: {mousemove: "_doOnListMouseMove", mousedown: "_doOnListMouseDown", mouseup: "_doOnListMouseUp", mouseout: "_doOnListMouseOut"}}
	];
	for (var q=0; q<this.conf.evs_nodes.length; q++) {
		for (var a in this.conf.evs_nodes[q].evs) {
			if (typeof(window.addEventListener) == "function") {
				this.conf.evs_nodes[q].node.addEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
			} else {
				this.conf.evs_nodes[q].node.attachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
			}
		}
	}
	
	
	this.unload = function() {
		
		// remove options
		this.clearAll();
		this.t = null;
		
		// detach dom events
		for (var q=0; q<this.conf.evs_nodes.length; q++) {
			for (var a in this.conf.evs_nodes[q].evs) {
				if (typeof(window.addEventListener) == "function") {
					this.conf.evs_nodes[q].node.removeEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
				} else {
					this.conf.evs_nodes[q].node.detachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
				}
				this.conf.evs_nodes[q].evs[a] = null;
				delete this.conf.evs_nodes[q].evs[a];
			}
			this.conf.evs_nodes[q].node = null;
			this.conf.evs_nodes[q].evs = null;
			delete this.conf.evs_nodes[q].node;
			delete this.conf.evs_nodes[q].evs;
			this.conf.evs_nodes[q] = null;
		}
		
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this._mcDetachHeader();
		
		// depr
		this.DOMelem_input = this.DOMelem_button = this.DOMlist = this.DOMelem = this.DOMParent = null;
		
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		this.conf = null;
		
		if (typeof(window.addEventListener) == "function") {
			this.list.removeEventListener("scroll", this._doOnListScroll, false);
		} else {
			this.list.detachEvent("onscroll", this._doOnListScroll);
		}
		
		this.base.parentNode.removeChild(this.base);
		this.list.parentNode.removeChild(this.list);
		this.base = this.list = this.cont = null;
		
		this.modes = null;
		
		for (var a in this) {
			if (typeof(this[a]) == "function") this[a] = null;
		}
		
		that = null;
		
	};
	
	// DEPRECATED props
	this.DOMelem_input = this.base.firstChild; // 3.6 compat, use getInput()
	this.DOMelem_button = this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)]; // 3.6 compat, use getButton()
	this.DOMlist = this.list; // 3.6 compat, use getList()
	this.DOMelem = this.base; // 3.6 compat, use getBase()
	this.DOMParent = parentId; // 3.0 compat, use getParent()
	parentId = null;
	
	// check for object api init details
	if (apiObj != null) {
		// filter
		if (apiObj.filter != null) {
			if (typeof(apiObj.filter) == "string") {
				this.enableFilteringMode(true, apiObj.filter, window.dhx4.s2b(apiObj.filter_cache), window.dhx4.s2b(apiObj.filter_sub_load));
			} else {
				this.enableFilteringMode(true);
			}
		}
		// imgs
		if (apiObj.image_path != null) this.setImagePath(apiObj.image_path);
		if (apiObj.default_image != null || apiObj.default_image_dis != null) this.setDefaultImage(apiObj.default_image, apiObj.default_image_dis);
		// opts
		if (apiObj.items || apiObj.options) this.addOption(apiObj.items||apiObj.options);
		if (apiObj.xml || apiObj.json) this.load(apiObj.xml||apiObj.json);
		// misc
		if (typeof(apiObj.readonly) != "undefined") this.readonly(apiObj.readonly);
		//
		apiObj = null;
	}
	
	return this;
	
};

function dhtmlXComboFromSelect(selectId) {
	
	// <select mode="checkbox">
	
	if (typeof(selectId) == "string") selectId = document.getElementById(selectId);
	
	// collect params
	var comboWidth = selectId.offsetWidth;
	var formName = selectId.getAttribute("name")||null;
	
	// add node
	var comboNode = document.createElement("SPAN");
	selectId.parentNode.insertBefore(comboNode, selectId);
	
	// combo mode
	var comboMode = selectId.getAttribute("mode")||selectId.getAttribute("opt_type")||"option";
	
	// init combo
	var combo = new dhtmlXCombo(comboNode, formName, comboWidth, comboMode);
	comboNode = null;
	
	var imagePath = selectId.getAttribute("imagePath");
	if (imagePath) combo.setImagePath(imagePath);
	
	var defImg = selectId.getAttribute("defaultImage");
	var defImgDis = selectId.getAttribute("defaultImageDis");
	if (window.dhx4.s2b(defImgDis) == true) defImgDis = true;
	if (defImg != null || defImgDis != null) combo.setDefaultImage(defImg, defImgDis);
	
	// options
	var opts = combo._xmlToObj([selectId], true, selectId.selectedIndex);
	if (opts.options.length > 0) combo.addOption(opts.options);
	opts = null;
	
	// remove select
	selectId.parentNode.removeChild(selectId);
	selectId = null;
	
	return combo;
};

/* common funcs */
dhtmlXCombo.prototype.setName = function(name) { // change name for form
	this.conf.form_name = name;
	this.base.childNodes[1].name = name;
	this.base.childNodes[2].name = name.replace(/(\[.*)?$/, "_new_value$1");
};

dhtmlXCombo.prototype.readonly = function(mode) { // enable/disable readonly mode
	if (window.dhx4.s2b(mode)) {
		this.base.firstChild.setAttribute("readOnly", "true");
		this.conf.ro_mode = true;
	} else {
		this.base.firstChild.removeAttribute("readOnly");
		this.conf.ro_mode = false;
	}
};

dhtmlXCombo.prototype.setPlaceholder = function(text) { // new in 4.0, limited support
	if (typeof(text) == "undefined" || text == null) text = "";
	this.base.firstChild.setAttribute("placeholder", String(text));
};

dhtmlXCombo.prototype.setTemplate = function(tpl) {
	for (var a in tpl) {
		if (typeof(this.conf.template[a]) != "undefined") {
			if (a == "header") {
				this.conf.template[a] = window.dhx4.s2b(tpl[a]);
			} else {
				this.conf.template[a] = String(tpl[a]);
			}
		}
	};
	
	// columns
	if (tpl.columns != null) {
		this._mcMakeTemplate(tpl.columns);
	} else {
		this._mcDetachHeader();
	}
	
	// template changed, update combo text and update rendered options
	for (var a in this.t) {
		this.t[a].obj.setText(this.t[a].item, this.t[a].item._conf.text);
	};
	this._confirmSelect();
};

dhtmlXCombo.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	this.conf.skin = skin;
	this.base.className = "dhxcombo_"+this.conf.skin+(this.conf.enabled?"":" dhxcombo_disabled");
	this.list.className = "dhxcombolist_"+this.conf.skin+(this.hdr!=null?" dhxcombolist_multicolumn":"");
	if (this.hdr != null) this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
	this.conf.i_ofs = (skin == "material"?26:23);
	this._adjustBase();
};

dhtmlXCombo.prototype.getInput = function() { // returns input, new in 4.0
	return this.base.firstChild;
};
dhtmlXCombo.prototype.getButton = function() { // returns button, new in 4.0
	return this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)];
};
dhtmlXCombo.prototype.getList = function() { // do we need it?
	return this.list;
};
dhtmlXCombo.prototype.getBase = function() { // do we need it?
	return this.base;
};

dhtmlXCombo.prototype.getParent = function() { // do we need it?
	return this.DOMParent;
};

dhtmlXCombo.prototype.forEachOption = function(handler) { // iterator, new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		handler.apply(window, [this._getOption(this.list.childNodes[q]._optId, q)]);
	}
};

dhtmlXCombo.prototype.setFocus = function() {
	if (this.conf.enabled) this.base.firstChild.focus();
};
dhtmlXCombo.prototype.setFontSize = function(sizeInp, sizeList) {
	// "11px" or" "0.9em"
	if (sizeInp != null) this.base.firstChild.style.fontSize = sizeInp;
	if (sizeList != null) this.list.style.fontSize = sizeList;
};

/* options */
dhtmlXCombo.prototype.getOption = function(value) { // option by value
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getValue(this.t[a].item) == value) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getOptionByIndex = function(index) { // option by index
	if (index < 0) return null;
	if (this.list.childNodes[index] == null) return null;
	return this._getOption(this.list.childNodes[index]._optId, index);
};

dhtmlXCombo.prototype.getOptionByLabel = function(text) { // rename to getOptionByText ?
	// option by label
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getText(this.t[a].item, true) == text) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getSelectedIndex = function() { // gets index of selected option
	return this._getOptionProp(this.conf.last_selected, "index", -1);
};

dhtmlXCombo.prototype.getSelectedText = function() { // gets text of selected option
	return this._getOptionProp(this.conf.last_selected, "text", "");
};

dhtmlXCombo.prototype.getSelectedValue = function() { // gets value of selected item
	return this._getOptionProp(this.conf.temp_selected||this.conf.last_selected, "value", null);
};

dhtmlXCombo.prototype.getActualValue = function() { // gets value which will be sent with form
	return this.base.childNodes[1].value;
};
dhtmlXCombo.prototype.getComboText = function() { // gets current text in combobox
	return this.base.childNodes[0].value;
};

dhtmlXCombo.prototype.getIndexByValue = function(value) { // returns index of item by value
	var t = this.getOption(value);
	return (t!=null?t.index:-1);
};

dhtmlXCombo.prototype.setComboText = function(text) {
	// sets text in combobox, reset selected option
	if (this.conf.allow_free_text != true) return;
	
	this.unSelectOption();
	this.conf.last_text = this.base.firstChild.value = text;
	this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	
};

dhtmlXCombo.prototype.setComboValue = function(value) {
	// sets text in combobox, only text
	var t = this.getOption(value);
	if (t != null) {
		this.selectOption(t.index);
	} else {
		this.conf.last_value = value;
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "true";
	}
};

dhtmlXCombo.prototype.selectOption = function(index, filter, conf) { // selects option
	if (index < 0 || index >= this.list.childNodes.length) return;
	var id = this.list.childNodes[index]._optId;
	this._setSelected(id, this._isListVisible(), true);
	this._confirmSelect("script");
};

dhtmlXCombo.prototype.unSelectOption = function() { // unselects option
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
	}
	
	this.base.firstChild.value = "";
	
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	this._hideList();
	this._updateTopImage(null);
	
	this._confirmSelect("script");
	
};

dhtmlXCombo.prototype.confirmValue = function() {
	this._confirmSelect("script");
};

/* enable/disable */
dhtmlXCombo.prototype.enable = function(mode) {
	
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	if (this.conf.enabled == mode) return;
	
	this.conf.enabled = mode;
	
	if (mode) {
		this.base.className = "dhxcombo_"+this.conf.skin;
		this.base.firstChild.removeAttribute("disabled");
	} else {
		this._hideList();
		this.base.className = "dhxcombo_"+this.conf.skin+" dhxcombo_disabled";
		this.base.firstChild.setAttribute("disabled","true");
	}
	
	// update disabled image if any
	this._updateTopImage(this.conf.last_selected);
};

dhtmlXCombo.prototype.disable = function(mode) {
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.enable(!mode);
};

dhtmlXCombo.prototype.isEnabled = function() {
	return (this.conf.enabled==true);
};

/* visibility */
dhtmlXCombo.prototype.show = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.base.style.display = (mode==true?"":"none");
};

dhtmlXCombo.prototype.hide = function(mode) {
	if (typeof(mode) == "undefined") mode = true;
	this.show(!mode);
};

dhtmlXCombo.prototype.isVisible = function() {
	return (this.base.style.display=="");
};


/* filtering */
dhtmlXCombo.prototype.setFilterHandler = function(f) {
	if (typeof(f) == "function") {
		this.conf.f_func = f;
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else if (typeof(f) == "string" && typeof(window[f]) == "function") {
		this.conf.f_func = window[f];
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else {
		this.conf.f_func = null;
	}
};
dhtmlXCombo.prototype.enableFilteringMode = function(mode, url, cache, dyn) {
	if (mode == true || mode == "between") {
		this.conf.f_mode = (mode==true?"start":"between");
		if (url != null) {
			this.conf.f_url = url;
			this.conf.f_cache = window.dhx4.s2b(cache);
			this.conf.f_dyn = window.dhx4.s2b(dyn);
		} else {
			this.conf.f_url = null;
			this.conf.f_cache = false;
			this.conf.f_dyn = false;
		}
	} else {
		this.conf.f_mode = false;
		this.conf.f_url = null;
		this.conf.f_cache = false;
		this.conf.f_dyn = false;
	}
};

dhtmlXCombo.prototype.filter = function(handler, showList) { // new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		var k = handler.apply(window, [this._getOption(this.list.childNodes[q]._optId,q)]);
		this.list.childNodes[q].style.display = (k===true?"":"none");
	}
	if (typeof(showList) == "undefined" || showList == true) {
		this._showList(true);
	}
};

dhtmlXCombo.prototype.sort = function(mode) { // new in 4.0
	var r = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		var id = this.list.childNodes[q]._optId;
		r.push([id, this._getOption(id, q)]);
	}
	// sort
	if (mode == "asc" || mode == "desc") {
		k = true;
		r.sort(function(a,b){
			a = a[1].text_option.toLowerCase();
			b = b[1].text_option.toLowerCase();
			var r = (mode=="asc"?1:-1);
			return (a>b?r:-1*r);
		});
	} else if (typeof(mode) == "function" || typeof(window[mode]) == "function") {
		if (typeof(window[mode]) == "function") mode = window[mode];
		r.sort(function(a,b){
			return mode.apply(window, [a[1],b[1]]);
		});
	}
	// reorder
	while (this.list.childNodes.length > 0) this.list.removeChild(this.list.lastChild);
	for (var q=0; q<r.length; q++) this.list.appendChild(this.t[r[q][0]].item);
};

dhtmlXCombo.prototype.enableAutocomplete = function(mode) { // autocomplete for f_mode:start, enabled by default
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.conf.f_ac = mode;
};
dhtmlXCombo.prototype.disableAutocomplete = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.enableAutocomplete(!mode);
};

dhtmlXCombo.prototype.allowFreeText = function(mode, resetToEmpty) { // new in 4.0
	this.conf.allow_free_text = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.conf.free_text_empty = (typeof(resetToEmpty)=="undefined"?false:window.dhx4.s2b(resetToEmpty)); // 4.5.1
};

dhtmlXCombo.prototype._checkForMatch = function(forceClear) {
	// check if text matched to any opt_text for opt_hover while user entered text
	var k = window.dhx4.trim(this.base.firstChild.value).toLowerCase();
	var id = null;
	var item = this.list.firstChild;
	while (item != null) {
		if (item.style.display == "" && item._optId != null) {
			var text = window.dhx4.trim(this.t[item._optId].obj.getText(item, true)).toLowerCase();
			if (k == text) {
				id = item._optId;
				item = null;
			}
		}
		if (item != null) item = item.nextSibling;
	}
	// match found, hover item
	if (this.conf.last_match == null) {
		if (id != null) {
			// 1st match
			this._setSelected(id, true, true);
			this.conf.last_match = id;
		} else {
			// nothing found
			// clear current selection if any
			if (this.conf.f_mode != "between" || forceClear == true) {
				this._setSelected(null, true, true);
				this.conf.last_match = null;
			}
		}
	} else {
		if (id != null) {
			// another match, check if same or new
			if (id != this.conf.last_match) {
				this._setSelected(id, true, true);
				this.conf.last_match = id;
			}
		} else {
			// nothing found clear last match if hovered and selection not changed
			this._setSelected(null, true, true);
			this.conf.last_match = null;
		}
	}
	
};

dhtmlXCombo.prototype._selectRange = function(from, to) {
	if (this.conf.combo_focus == true) window.dhx4.selectTextRange(this.base.firstChild, from, to);
};

/* show/hide select list */
dhtmlXCombo.prototype.openSelect = function() { // opens list of options
	if (!this._isListVisible()) this._showList();
};

dhtmlXCombo.prototype.closeAll = function() {
	this._hideList();
};

dhtmlXCombo.prototype._showList = function(autoHide) {
	
	if (this._getListVisibleCount() == 0) {
		if (autoHide && this._isListVisible()) this._hideList();
		return;
	}
	
	if (this._isListVisible()) {
		this._checkListHeight();
		return;
	}
	
	this.list.style.zIndex = window.dhx4.zim.reserve(this.conf.list_zi_id); // get new z-index
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.zIndex = Number(this.list.style.zIndex)+1;
	
	this.list.style.visibility = "hidden";
	this.list.style.display = "";
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.visibility = this.list.style.visibility;
		this.hdr.style.display = this.list.style.display;
	}
	
	// position
	var h0 = (this.hdr != null && this.conf.template.header == true ? this.hdr.offsetHeight : 0);
	
	this.list.style.width = Math.max(this.conf.opts_width||this.conf.col_w||0, this.conf.combo_width)+"px";
	this.list.style.top = window.dhx4.absTop(this.base)+h0+this.base.offsetHeight-1+"px";
	this.list.style.left = window.dhx4.absLeft(this.base)+"px";
	
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.width = this.list.style.width;
		this.hdr.style.left = this.list.style.left;
		this.hdr.style.top = parseInt(this.list.style.top)-h0+"px";
	}
	
	// height
	this._checkListHeight();
	
	// check bottom overlay
	this.list.style.visibility = "visible";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.visibility = "visible";
	
	this.callEvent("onOpen",[]);
	
};

dhtmlXCombo.prototype._hideList = function() {
	
	if (!this._isListVisible()) return;
	
	window.dhx4.zim.clear(this.conf.list_zi_id); // clear z-index
	this.list.style.display = "none";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.display = "none";
	
	this.conf.clear_click = false;
	
	this.callEvent("onClose",[]);
	
};

dhtmlXCombo.prototype._isListVisible = function() {
	return (this.list.style.display=="");
};

dhtmlXCombo.prototype._getListVisibleCount = function() {
	var k = 0;
	for (var q=0; q<this.list.childNodes.length; q++) k += (this.list.childNodes[q].style.display==""?1:0);
	return k;
};

dhtmlXCombo.prototype._checkListHeight = function() {
	
	if (!this._isListVisible()) return;
	
	if (this.conf.item_h == null) {
		var item = this.list.firstChild;
		while (item != null) {
			if (item.style.display == "") {
				this.conf.item_h = item.offsetHeight + (this.hdr != null ? -1 : 0); // multicol rows have -1px margin
				item = null;
			} else {
				item = item.nextSibling;
			}
		}
		item = null;
	}
	
	var s = window.dhx4.screenDim();
	var by = window.dhx4.absTop(this.base);
	var bh = this.base.offsetHeight;
	var hh = (this.hdr!=null&&this.conf.template.header==true?this.hdr.offsetHeight:0); // header_height
	
	var onTop = Math.max(0, Math.floor((by+hh-s.top)/this.conf.item_h));
	var onBottom = Math.max(0, Math.floor((s.bottom-(by+bh+hh))/this.conf.item_h));
	
	var itemsCount = this._getListVisibleCount();
	
	// top/bottom detect
	if (onBottom < Math.min(this.conf.opts_count_min, itemsCount) && onTop > onBottom) onBottom = null;
	
	var itemsToShow = Math.min((onBottom==null?onTop:onBottom), this.conf.opts_count, itemsCount);
	var h = (itemsToShow<itemsCount?(itemsToShow*this.conf.item_h)+"px":"");
	
	var ofs = this.conf.sp[this.conf.skin][this.hdr!=null&&this.conf.template.header==true?"hdr_ofs":"list_ofs"];
	
	this.list.style.height = h;
	this.list.style.top = (onBottom==null?by-this.list.offsetHeight+ofs:by+bh+hh-ofs)+"px";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.top = (onBottom==null?by-hh-this.list.offsetHeight+ofs:by+bh-ofs)+"px";
	
};

dhtmlXCombo.prototype._scrollToItem = function(id) {
	
	var y1 = this.t[id].item.offsetTop;
	var y2 = y1+this.t[id].item.offsetHeight;
	var a1 = this.list.scrollTop;
	var a2 = a1+this.list.clientHeight;
	
	if (y1 < a1) {
		// on top
		this.list.scrollTop = y1+(this.hdr!=null&&this.conf.template.header==true?1:0);
	} else if (y2 > a2) {
		// on bottom
		this.list.scrollTop = y2-this.list.clientHeight+(this.hdr!=null&&this.conf.template.header==true?-this.conf.sp[this.conf.skin].scr_ofs:0);
	}
	
};

/* in-list selection/highlighting */
dhtmlXCombo.prototype._setSelected = function(id, scrollToItem, updateImg, mouseMove) {
	
	this.conf.temp_selected = null;
	
	if (updateImg) this._updateTopImage(id);
	
	if (id != null && this.conf.last_hover == id) {
		if (scrollToItem) this._scrollToItem(id);
		return;
	}
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
		if (id == null) this.callEvent("onSelectionChange", []);
	}
	
	if (id != null) {
		
		this.t[id].obj.setSelected(this.t[id].item, true);
		this.conf.last_hover = id;
		
		if (mouseMove != true) {
			this.conf.temp_selected = id;
			this.callEvent("onSelectionChange", []);
		}
		
		// last item selected, try subload
		if (this.conf.s_mode == "select" && this.t[id].item == this.t[id].item.parentNode.lastChild) this._subloadRequest();
		
		if (scrollToItem) this._scrollToItem(id);
		
	}
	
};

// auto-subload
dhtmlXCombo.prototype._subloadRequest = function() {
	
	if (this.conf.f_url != null && this.conf.f_dyn == true && this.conf.f_dyn_end == false) {
		
		var params = "mask="+encodeURIComponent(this.conf.f_mask)+"&pos="+this.list.childNodes.length;
		var t = this;
		var callBack = function(r){
			
			// cache
			if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].data.push(r.xmlDoc.responseXML);
			var k = t.list.childNodes.length;
			
			// skip clear opts w/o add='true'
			t.conf.f_loading = true;
			t.load(r.xmlDoc.responseXML);
			t.conf.f_loading = false;
			
			// if no more opts left on server, stop dyn requests
			if (k == t.list.childNodes.length) {
				t.conf.f_dyn_end = true;
				if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].dyn_end = true;
			}
			callBack = t = null;
		}
		if (window.dhx4.ajax.method == "post") {
			window.dhx4.ajax.post(this.conf.f_url, params, callBack);
		} else if (window.dhx4.ajax.method == "get") {
			window.dhx4.ajax.get(this.conf.f_url+(String(this.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
		}
	}
};

/* add / remove options */
dhtmlXCombo.prototype.addOption = function(value, text, css, img, selected) {
	
	// selected added in 4.0
	
	/*
	
	single option, 4 params
	z.addOption(value, text, css, img_src);
	value, text, css (css string attached to the option, optional), img_src (path to the option icon image, just for "image" combo type)
	
	several options, array of array (in this case you can't use 4th parameter img_src - improve?)
	z.addOption([["a","option A", "color:red;"],[],[],...]);
	
	several options, as an array of objects (you can use 4 parameters)
	z.addOption([{value: "a", text: "option A", img_src: "../images/blue.gif", css:"color:red;"},{},{}...]);
	
	*/
	
	var toSelect = null;
	
	if (!(value instanceof Array)) {
		// single option
		var id = this._renderOption({value:value, text:text, css:css, img:img});
		if (toSelect == null && window.dhx4.s2b(selected) == true) toSelect = id;
		
	} else {
		// array with opts
		for (var q=0; q<value.length; q++) {
			if (typeof(value[q]) == "undefined") continue;
			if (value[q] instanceof Array) {
				id = this._renderOption({value:value[q][0], text:value[q][1], css:value[q][2], img:value[q][3]});
				if (toSelect == null && window.dhx4.s2b(value[q][4]) == true) toSelect = id;
			} else {
				var id = this._renderOption(value[q]);
				if (toSelect == null && window.dhx4.s2b(value[q].selected) == true) toSelect = id;
			}
		}
	}
	
	if (toSelect != null) {
		this._setSelected(toSelect, this._isListVisible(), true);
		this._confirmSelect("onInit");
	}
};

dhtmlXCombo.prototype.updateOption = function(oldValue, newValue, newText, newCss) {
	var id = this._getOptionId(oldValue);
	if (id == null) return;
	this.t[id].obj.update(this.t[id].item, {value: newValue, text: newText, css: newCss});
	if (this.conf.last_selected == id) {
		this.conf.last_text = this.base.firstChild.value = this.t[id].obj.getText(this.t[id].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	}
};

dhtmlXCombo.prototype.deleteOption = function(value) { // deletes option by value
	
	for (var a in this.t) {
		var v = this.t[a].obj.getValue(this.t[a].item);
		if (v == value) this._removeOption(a);
	}
	
	if (this._isListVisible()) this._showList(true); // resize if any or hide if no more items left
	
};

dhtmlXCombo.prototype.clearAll = function(hideList) { // remove all options
	
	hideList = (typeof(hideList)=="undefined"?true:window.dhx4.s2b(hideList));
	for (var a in this.t) this._removeOption(a);
	
	// props
	if (this.conf.tm_hover) window.clearTimeout(this.conf.tm_hover);
	this.conf.last_hover = null;
	this.conf.last_selected = null;
	
	this.list.scrollTop = 0;
	if (hideList == true) this._hideList();
	
};

dhtmlXCombo.prototype._renderOption = function(data) {
	
	var id = window.dhx4.newId();
	var item = document.createElement("DIV");
	
	item._optId = id;
	item._tpl = this.conf.template;
	
	// wrapper for img_src/img_src_dis
	if (typeof(data.img) == "undefined" && typeof(data.img_src) != "undefined") {
		data.img = data.img_src;
		delete data.img_src;
	}
	if (typeof(data.img_dis) == "undefined" && typeof(data.img_src_dis) != "undefined") {
		data.img_dis = data.img_src_dis;
		delete data.img_src_dis;
	}
	
	data.img_path = this.conf.img_path;
	data.img_def = this.conf.img_def;
	data.img_def_dis = this.conf.img_def_dis;
	
	this.list.appendChild(item);
	
	var v = (this._isListVisible() && window.dhx4.isFF == true);
	if (v == true) {
		var k = this.list.scrollTop;
		this.list.scrollTop -= 1;
	}
	
	// if multicolumn
	if (this.hdr != null) data.multicol = true;
	
	this.t[item._optId] = {
		obj: this.modes[this.conf.opts_type].render(item, data),
		item: item,
		conf: {
			type: this.conf.opts_type
		}
	};
	item = null;
	
	if (v == true) this.list.scrollTop += 1;
	
	return id;
};

dhtmlXCombo.prototype._removeOption = function(id) {
	this.t[id].obj.destruct(this.t[id].item);
	this.t[id].obj = null;
	this.t[id].item.parentNode.removeChild(this.t[id].item);
	this.t[id].item = null;
	this.t[id].conf = null;
	this.t[id] = null;
	delete this.t[id];
	
	if (this.conf.last_hover == id) this.conf.last_hover = null;
	if (this.conf.last_selected == id) {
		this.conf.last_selected = null;
		this._confirmSelect("onDelete");
	}
};

dhtmlXCombo.prototype._confirmSelect = function(mode, hideList) {
	
	var wasChanged = false;
	if (typeof(hideList) == "undefined") hideList = true;
	
	if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
	
	// confirm selection
	// if any item hovered - select, if not - just apply entered value
	if (this.conf.last_hover != null) {
		// select value
		wasChanged = wasChanged||(this.conf.last_value != this._getOptionValue(this.conf.last_hover));
		this.conf.last_match = this.conf.last_selected = this.conf.last_hover;
		this.conf.last_value = this._getOptionValue(this.conf.last_selected);
		this.conf.last_text = this.base.firstChild.value = this.t[this.conf.last_selected].obj.getText(this.t[this.conf.last_selected].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
		// inputs
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "false";
	} else {
		// just a text,
		// check if free text allowed
		if (this.conf.allow_free_text || (this.base.firstChild.value == "" && this.conf.allow_empty_value)) {
			wasChanged = wasChanged||(this.conf.last_text != this.base.firstChild.value);
			this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
			this.conf.last_text = this.base.firstChild.value;
			this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			// inputs
			this.base.childNodes[1].value = this.conf.last_text;
			this.base.childNodes[2].value = "true";
		} else {
			this._cancelSelect(true);
			this._updateTopImage(this.conf.last_selected);
			return;
		}
	}
	
	if (this.conf.f_ac && this.conf.f_mode == "start") {
		this.conf.f_ac_text = "";
		if (mode != "blur") {
			this._selectRange(this.base.firstChild.value.length, this.base.firstChild.value.length);
		}
	}
	
	if (hideList) this._hideList();
	
	if (wasChanged == true && mode != "onInit" && mode != "onDelete") {
		this.callEvent("onSelectionChange", []);
		this.callEvent("onChange", [this.conf.last_value, this.conf.last_text]);
	}
	
};

dhtmlXCombo.prototype._cancelSelect = function(freeTextReset) {
	
	this._hideList();
	
	if (freeTextReset == true && this.conf.allow_free_text == false && this.conf.free_text_empty == true) {
		this.conf.f_server_last = this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
		this.base.childNodes[1].value = this.conf.last_text = this.base.firstChild.value = "";
		this.base.childNodes[2].value = "false";
	} else {
		this.base.firstChild.value = this.conf.last_text;
	}
	
	// restore filters if any
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	
};


/* option object operations */
dhtmlXCombo.prototype._getOption = function(id, index) {
	
	if (!this.t[id]) return null;
	
	// autodetect index if any
	if (typeof(index) == "undefined") index = -1;
	if (index < 0) {
		for (var q=0; q<this.list.childNodes.length; q++) {
			if (index < 0 && this.list.childNodes[q]._optId == id) index = q;
		}
	}
	
	// comon data
	var t = {
		value: this.t[id].obj.getValue(this.t[id].item),
		text: this.t[id].obj.getText(this.t[id].item),
		text_input: this.t[id].obj.getText(this.t[id].item, true),
		text_option: this.t[id].obj.getText(this.t[id].item, null, true),
		css: this.t[id].obj.getCss(this.t[id].item),
		selected: (id==this.conf.last_selected),
		index: index
	};
	
	// extra data if any, for example "checked" for checkbox
	if (typeof(this.t[id].obj.getExtraData) == "function") {
		var k = this.t[id].obj.getExtraData(this.t[id].item);
		for (var a in k) { if (typeof(t[a]) == "undefined") t[a] = k[a]; }
	}
	
	return t;
};

dhtmlXCombo.prototype._getOptionProp = function(id, prop, def) { // get any property of any option
	if (id != null) {
		var t = this._getOption(id);
		if (t != null) return t[prop];
	}
	return def;
};
dhtmlXCombo.prototype._getOptionId = function(value) {
	var id = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var p = this.list.childNodes[q]._optId;
			if (value == this.t[p].obj.getValue(this.t[p].item)) id = p;
		}
	}
	return id;
};
dhtmlXCombo.prototype._getOptionValue = function(id) {
	return this._getOptionProp(id, "value", null);
};


dhtmlXCombo.prototype.setSize = function(width) { // changes control size
	this.conf.combo_width = parseInt(width)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0);
	this.base.style.width = Math.max(0, this.conf.combo_width)+"px";
	this._adjustBase();
};

dhtmlXCombo.prototype._adjustBase = function() {
	this.base.firstChild.style.width = Math.max(0, (this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0)))+"px";
	this.base.firstChild.style.marginLeft = (this.conf.combo_image?this.conf.i_ofs+"px":"0px");
};

dhtmlXCombo.prototype.setOptionWidth = function(w) { // sets width of combo list
	this.conf.opts_width = (parseInt(w)||null);
};

dhtmlXCombo.prototype.setOptionIndex = function(value, index) { // added in 4.1
	
	if (isNaN(index) || index < 0) return;
	
	var p = this.getOption(value);
	if (p == null) return;
	
	if (index == p.index) return;
	
	var t = this.list.childNodes[p.index];
	t.parentNode.removeChild(t);
	
	if (this.list.childNodes[index] != null) {
		this.list.insertBefore(t, this.list.childNodes[index]);
	} else {
		this.list.appendChild(t);
	}
	t = null;
	
};

dhtmlXCombo.prototype.getOptionsCount = function() { // added in 4.1
	return this.list.childNodes.length;
};

// multicolumn feature
dhtmlXCombo.prototype._mcMakeTemplate = function(cols) {
	
	var h = "";
	var t = "";
	
	this.conf.col_w = 0;
	
	for (var q=0; q<cols.length; q++) {
		
		var w = Number(parseInt(cols[q].width)||50);
		var css = (cols[q].css||"");
		var cssIE = (q == 0 && window.dhx4.isIE6 == true ? "_first":"");
		
		t += "<div class='dhxcombo_cell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_cell_text'>"+(cols[q].option||"&nbsp;")+"</div></div>";
		h += "<div class='dhxcombo_hdrcell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_hdrcell_text'>"+(cols[q].header||"&nbsp;")+"</div></div>";
		//
		this.conf.col_w += w+1;
	}
	
	var w = 500;
	var k = document.createElement("DIV");
	k.style.position = "absolute";
	k.style.top = "10px";
	k.style.left = -w*2+"px";
	k.style.width = w+"px";
	k.style.height = "50px";
	k.style.overflowY = "scroll";
	k.innerHTML = "<div>&nbsp;</div>";
	document.body.appendChild(k);
	
	this.conf.col_w += w-k.firstChild.offsetWidth+10;
	
	k.parentNode.removeChild(k);
	k = null;
	
	this.conf.template.option = t;
	this._mcAttachHeader(h);
	
	this.list.className += " dhxcombolist_multicolumn";
};

dhtmlXCombo.prototype._mcAttachHeader = function(text) {
	
	if (this.hdr == null) {
		
		this.hdr = document.createElement("DIV");
		this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
		this.hdr.style.display = "none";
		
		this.list.parentNode.insertBefore(this.hdr, this.list);
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.addEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.attachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		// remove top-image from input
		if (this.conf.opts_type == "checkbox" && this.conf.combo_image == true) {
			this.conf.combo_image = false;
			if (this.base.lastChild.className.match(/dhxcombo_top_image/) != null) this.base.removeChild(this.base.lastChild);
			this._adjustBase();
		}
	}
	
	this.hdr.innerHTML = "<div class='dhxcombo_hdrtext'>"+text+"</div>";
	
};

dhtmlXCombo.prototype._mcDetachHeader = function() {
	
	if (this.hdr != null) {
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.removeEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.detachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		this.hdr.parentNode.removeChild(this.hdr);
		this.hdr = null;
	}
	
	this.conf.col_w = null;
	this.conf.item_h = null;
	
};


/****************************************************************************************************************************************************************************************************************/

/* options */
dhtmlXCombo.prototype.modes = {}; // option types

dhtmlXCombo.prototype.doWithItem = function(index, method, param1, param2) { // wrapper to perform opts operations from combo
	
	// get option inner id
	var id = (index >= 0 && index < this.list.childNodes.length ? this.list.childNodes[index]._optId : null);
	if (id == null) return null; // opt no found
	if (typeof(this.t[id].obj[method]) != "function") return null; // function not found
	
	// generate params
	var params = [this.t[id].item];
	for (var q=2; q<arguments.length; q++) params.push(arguments[q]);
	
	// call method
	return this.t[id].obj[method].apply(this.t[id].obj, params);
	
};

function dhtmlXComboExtend(to, from) {
	for (var a in dhtmlXCombo.prototype.modes[from]) {
		if (typeof(dhtmlXCombo.prototype.modes[to][a]) == "undefined") {
			dhtmlXCombo.prototype.modes[to][a] = dhtmlXCombo.prototype.modes[from][a];
		}
	};
};
/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.option = {
	
	image: false, // top-level image prev-to input
	html: false,
	option_css: "dhxcombo_option_text",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText = data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		
		return this;
	},
	
	destruct: function(item) {
		item._conf = null;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
	},
	
	setText: function(item, text, skip) {
		item._conf.text = text;
		var t = (typeof(text) == "object" ? window.dhx4.template(item._tpl.option, this.replaceHtml(item._conf.text, skip), true) : window.dhx4.trim(this.replaceHtml(item._conf.text, skip)||""));
		item.lastChild.innerHTML = (t.length==0?"&nbsp;":t);
	},
	
	getText: function(item, asStringInput, asStringOption) {
		if (window.dhx4.s2b(asStringInput) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.input, item._conf.text, true);
		if (window.dhx4.s2b(asStringOption) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.option, item._conf.text, true);
		return item._conf.text;
	},
	
	getValue: function(item) {
		return item._conf.value;
	},
	
	getCss: function(item) {
		return item._conf.css;
	},
	
	setSelected: function(item, state) {
		item.className = "dhxcombo_option"+(state?" dhxcombo_option_selected":"");
	},
	
	isSelected: function(item) {
		return String(item.className).indexOf("dhxcombo_option_selected") >= 0;
	},
	
	getExtraData: function(item) {
		// optional function,
		// adds extra data to option object returned by getOption()
		return {type: "option"};
	},
	
	replaceHtml: function(text, skip) {
		if (this.html == true) return text;
		if (typeof(skip) == "undefined" || skip == null) skip = {};
		if (typeof(text) == "object") {
			var t = {};
			for (var a in text) {
				t[a] = (skip[a]==true?text[a]:this.replaceHtml(text[a]));
			}
		} else {
			var t = (text||"").replace(/[\<\>\&\s]/g, function(t){
				switch (t) {
					case "<": return "&lt;";
					case ">": return "&gt;";
					case "&": return "&amp;";
					case " ": return "&nbsp;";
				}
				return t;
			});
		}
		return t;
	}
	
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.checkbox = {
	
	image: true, // disable in code if multicolumn
	html: false,
	image_css: "dhxcombo_checkbox dhxcombo_chbx_#state#",
	option_css: "dhxcombo_option_text dhxcombo_option_text_chbx",
	
	render: function(item, data) {
		
		if (this.image_css_regexp == null) this.image_css_regexp = new RegExp(this.image_css.replace("#state#","\\d*"));
		
		item._conf = {value: data.value, css: "", checked: window.dhx4.s2b(data.checked)};
		
		item.className = "dhxcombo_option";
		
		var skip = {}; // skip html replace
		
		if (data.multicol == true) {
			data.text.checkbox = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>&nbsp;";
			skip.checkbox = true;
			item.innerHTML = "<div class='"+dhtmlXCombo.prototype.modes.option.option_css+"'></div>";
		} else {
			item.innerHTML = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>"+
					"<div class='"+this.option_css+"'>&nbsp;</div>";
		}
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text, skip);
		
		return this;
	},
	
	setChecked: function(item, state) {
		item._conf.checked = window.dhx4.s2b(state);
		var css = String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"));
		this._changeChbxCss(item.childNodes, css);
	},
	
	_changeChbxCss: function(nodes, css) {
		for (var q=0; q<nodes.length; q++) {
			if (nodes[q].tagName != null && nodes[q].className != null && nodes[q].className.match(this.image_css_regexp) != null) {
				nodes[q].className = css;
			} else if (nodes[q].childNodes.length > 0) {
				this._changeChbxCss(nodes[q].childNodes, css);
			}
		}
	},
	
	isChecked: function(item) {
		return (item._conf.checked==true);
	},
	
	getExtraData: function(item) {
		return {type: "checkbox", checked: item._conf.checked};
	},
	
	optionClick: function(item, ev, combo) {
		// called when option clicked, return true allows selection+confirm, return false - not
		var r = true;
		var t = (ev.target||ev.srcElement);
		while (r == true && t != null && t != item && t.className != null) {
			if (t.className.match(this.image_css_regexp) != null) {
				var args = [item._conf.value, !item._conf.checked];
				if (combo.callEvent("onBeforeCheck", args) === true) {
					this.setChecked(item, !this.isChecked(item));
					combo.callEvent("onCheck", args);
				};
				r = false;
				args = null;
			} else {
				t = t.parentNode;
			}
		}
		t = combo = item = null;
		return r;
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		// enabled specify if combo enabled
		return "";
	},
	
	topImageClick: function(item, combo) {
		// called when user clicked on top-image,
		// return true/false to allow defailt action (open/close list) ot not
		// for checkbox - perform default action
		return true;
	}
	
};

dhtmlXComboExtend("checkbox", "option");

dhtmlXCombo.prototype.setChecked = function(index, mode) {
	this.doWithItem(index, "setChecked", mode);
};

dhtmlXCombo.prototype.getChecked = function(index) {
	// return checked values
	var t = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (this.isChecked(q)) t.push(this._getOptionProp(this.list.childNodes[q]._optId, "value", ""));
	}
	return t;
};

dhtmlXCombo.prototype.isChecked = function(index) {
	return this.doWithItem(index, "isChecked");
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.image = {
	
	image: true,
	html: false,
	image_css: "dhxcombo_image",
	option_css: "dhxcombo_option_text dhxcombo_option_text_image",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.image_css+"'></div>"+
				"<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
		
		return this;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
	},
	
	setImage: function(item, img, img_dis, path, def, def_dis) {
		
		// image
		if (img != null && img.length > 0) {
			img = path+img;
		} else if (def != null && def.length > 0) {
			img = path+def;
		} else {
			img = null;
		}
		
		// image
		if (img_dis != null && img_dis.length > 0) {
			img_dis = path+img_dis;
		} else if (def_dis != null && def_dis.length > 0) {
			img_dis = path+def_dis;
		} else if (def_dis == true) {
			img_dis = img;
		} else {
			img_dis = null;
		}
		
		item._conf.img = img;
		item._conf.img_dis = img_dis;
		
		item.firstChild.style.backgroundImage = (img!=null?"url("+img+")":"none");
	},
	
	getExtraData: function(item) {
		return {type: "image"};
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		var a = (enabled?"img":"img_dis");
		if (item != null && item._conf[a] != null) return "<div class='"+this.image_css+"' style='background-image:url("+item._conf[a]+");'></div>";
		return "";
	}
	
};

dhtmlXComboExtend("image", "option");

dhtmlXCombo.prototype.setDefaultImage = function(img, imgDis) {
	// sets default image
	// set imgDis to tru to use the same image as for enabled combo, default
	if (img != null) this.conf.img_def = img;
	if (imgDis != null) this.conf.img_def_dis = imgDis;
};
dhtmlXCombo.prototype.setImagePath = function(path) {
	this.conf.img_path = path;
};


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXMenuObject(base, skin) {
	
	var that = this;
	
	// iframe
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxmenu")||"material"),
		mode: "web",
		align: "left",
		is_touched: false,
		selected: -1,
		last_click: -1,
		fixed_pos: false, // should be used for frameset in IE
		rtl: false,
		icons_path: "",
		icons_css: false, // use css for icons or direct img links, added in 5.0
		arrow_ff_fix: (navigator.userAgent.indexOf("MSIE") >= 0 && document.compatMode=="BackCompat"), // border fixer for FF for arrows polygons
		live_id: window.dhx4.newId(),
		tags: {
			root: "menu",
			item: "item",
			text_ext: "itemtext",
			userdata: "userdata",
			tooltip: "tooltip",
			hotkey: "hotkey",
			href: "href"
		},
		autoload: {},
		hide_tm: {},
		// shows sublevel polygons from toplevel items with delay
		top_mode: true,
		top_tmtime: 200,
		// visible area
		v_enabled: false,
		v: {x1: null, x2: null, y1: null, y2: null},
		// open direction
		dir_toplv: "bottom",
		dir_sublv: "right",
		// overflow
		auto_overflow: false,
		overflow_limit: 0,
		of_utm: null, // scroll up - tm
		of_utime: 20, // scroll up - time
		of_ustep: 3, // scroll up - step
		of_dtm: null,
		of_dtime: 20,
		of_dstep: 3,
		of_ah: {dhx_skyblue: 24, dhx_web: 25, dhx_terrace: 27, material: 25}, // arrow height+oplygon top/bottom padding
		of_ih: {dhx_skyblue: 24, dhx_web: 24, dhx_terrace: 24, material: 30}, // item height
		// hide
		tm_sec: 400,
		tm_handler: null,
		// dyn load
		dload: false,
		dload_url: "",
		dload_icon: false, // show loading icon
		dload_params: {action: "loadMenu"}, // extra params
		dload_pid: "parentId", // parentId param name
		// skinbased offsets
		tl_botmarg: 1, // top level bottom margin
		tl_rmarg: 0, // right margin
		tl_ofsleft: 1, // offset left
		// context menu
		context: false,
		ctx_zoneid: false,
		ctx_autoshow: true, // default open action
		ctx_autohide: true, // default close action
		ctx_hideall: true, // true will hide all opened contextual menu polygons on mouseout, false - all except topleft
		ctx_zones: {},
		ctx_baseid: null, // add baseId as context zone
		// selected subitems
		selected_sub: [],
		opened_poly: []
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.visible_area) {
			this.conf.v_enabled = true;
			this.conf.v = {
				x1: base.visible_area.x1,
				x2: base.visible_area.x2,
				y1: base.visible_area.y1,
				y2: base.visible_area.y2
			};
		}
			
		for (var a in {json:1,xml:1,items:1,top_text:1,align:1,open_mode:1,overflow:1,dynamic:1,dynamic_icon:1,context:1,onload:1,onclick:1,oncheckboxclick:1,onradioclick:1,iconset:1}) {
			if (base[a] != null) this.conf.autoload[a] = base[a];
		}
		
		base = base.parent;
	}
	
	if (base == null) {
		this.base = document.body;
	} else {
		var baseObj = (typeof(base)=="string"?document.getElementById(base):base);
		if (baseObj != null) {
			this.base = baseObj;
			if (!this.base.id) this.base.id = "menuBaseId_"+new Date().getTime();
			this.base.className += " dhtmlxMenu_"+this.conf.skin+"_Middle dir_left";
			this.base._autoSkinUpdate = true;
			 // preserv default oncontextmenu for future restorin in case of context menu
			if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
			//
			this.conf.ctx_baseid = this.base.id;
			this.base.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
			this.base.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		} else {
			this.base = document.body;
		}
	}
	
	this.idPrefix = "";
	this.topId = "dhxWebMenuTopId";
	
	this.idPull = {};
	this.itemPull = {};
	this.userData = {};
	this.radio = {};
	//
	this.setSkin = function(skin) {
		var oldSkin = this.conf.skin;
		this.conf.skin = skin;
		switch (this.conf.skin){
			case "dhx_skyblue":
			case "dhx_web":
				this.conf.tl_botmarg = 2;
				this.conf.tl_rmarg = 1;
				this.conf.tl_ofsleft = 1;
				break;
			case "dhx_terrace":
			case "material":
				this.conf.tl_botmarg = 0;
				this.conf.tl_rmarg = 0;
				this.conf.tl_ofsleft = 0;
				break;
		}
		if (this.base._autoSkinUpdate) {
			this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.conf.skin+"_Middle";
		}
		
		for (var a in this.idPull) {
			this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.conf.skin);
			
		}
	}
	this.setSkin(this.conf.skin);
	//
	
	this._addSubItemToSelected = function(item, polygon) {
		var t = true;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = false; } }
		if (t == true) { this.conf.selected_sub.push(new Array(item, polygon)); }
		return t;
	}
	this._removeSubItemFromSelected = function(item, polygon) {
		var m = new Array();
		var t = false;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = true; } else { m[m.length] = this.conf.selected_sub[q]; } }
		if (t == true) { this.conf.selected_sub = m; }
		return t;
	}
	this._getSubItemToDeselectByPolygon = function(polygon) {
		var m = new Array();
		for (var q=0; q<this.conf.selected_sub.length; q++) {
			if (this.conf.selected_sub[q][1] == polygon) {
				m[m.length] = this.conf.selected_sub[q][0];
				m = m.concat(this._getSubItemToDeselectByPolygon(this.conf.selected_sub[q][0]));
				var t = true;
				for (var w=0; w<this.conf.opened_poly.length; w++) { if (this.conf.opened_poly[w] == this.conf.selected_sub[q][0]) { t = false; } }
				if (t == true) { this.conf.opened_poly[this.conf.opened_poly.length] = this.conf.selected_sub[q][0]; }
				this.conf.selected_sub[q][0] = -1;
				this.conf.selected_sub[q][1] = -1;
			}
		}
		return m;
	}
	
	this._hidePolygon = function(id) {
		if (this.idPull["polygon_" + id] != null) {
			// clear z-index
			if (this.idPull["polygon_"+id]._zId != null) {
				window.dhx4.zim.clear(this.idPull["polygon_"+id]._zId);
			}
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._hidePolygonEffect("polygon_"+id);
			} else {
				// already hidden
				if (this.idPull["polygon_"+id].style.display == "none") return;
				//
				this.idPull["polygon_"+id].style.display = "none";
				if (this.idPull["arrowup_"+id] != null) this.idPull["arrowup_"+id].style.display = "none";
				if (this.idPull["arrowdown_"+id] != null) this.idPull["arrowdown_"+id].style.display = "none";
				this._updateItemComplexState(id, true, false);
				// hide ie6 cover
				if (window.dhx4.isIE6 && this.idPull["polygon_"+id+"_ie6cover"] != null) this.idPull["polygon_"+id+"_ie6cover"].style.display = "none";
			}
			// call event
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onHide", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, true);
			}
			
		}
	}
	
	this._showPolygon = function(id, openType) {
		
		var itemCount = this._countVisiblePolygonItems(id);
		if (itemCount == 0) return;
		var pId = "polygon_"+id;
		if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {
			
			if (this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
				if (!this.idPull[id]._mouseOver && openType == this.conf.dir_toplv) return;
			}
			
			// detect visible area
			if (!this.conf.fixed_pos) this._autoDetectVisibleArea();
			
			// show arrows
			var arrUpH = 0;
			var arrDownH = 0;
			//
			var arrowUp = null;
			var arrowDown = null;
			
			// show polygon
			if (this.idPull[pId]._zId == null) {
				this.idPull[pId]._zId = window.dhx4.newId();
			}
			this.idPull[pId]._zInd = window.dhx4.zim.reserve(this.idPull[pId]._zId);
			
			this.idPull[pId].style.visibility = "hidden";
			this.idPull[pId].style.left = "0px";
			this.idPull[pId].style.top = "0px";
			this.idPull[pId].style.display = "";
			this.idPull[pId].style.zIndex = this.idPull[pId]._zInd;
			
			//
			if (this.conf.auto_overflow) {
				if (this.idPull[pId].childNodes[1].childNodes[0].offsetHeight > this.conf.v.y2-this.conf.v.y1) {
					var t0 = Math.max(Math.floor((this.conf.v.y2-this.conf.v.y1-this.conf.of_ah[this.conf.skin]*2)/this.conf.of_ih[this.conf.skin]),1); // (y2-y1-arrow_height*2)/item_height
					this.conf.overflow_limit = t0;
				} else {
					this.conf.overflow_limit = 0;
					
					if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
					if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
				}
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				
				// add overflow arrows if they not exists
				if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
				if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));
				
				// configure up arrow
				arrowUp = this.idPull["arrowup_"+id];
				arrowUp.style.display = "none";
				//arrUpH = arrowUp.offsetHeight;
				
				// configure bottom arrow
				arrowDown = this.idPull["arrowdown_"+id];
				arrowDown.style.display = "none";
				//arrDownH = arrowDown.offsetHeight;
				
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				// set fixed size
				this.idPull[pId].childNodes[1].style.height = this.conf.of_ih[this.conf.skin]*this.conf.overflow_limit+"px";
				arrowUp.style.width = arrowDown.style.width = this.idPull[pId].childNodes[1].style.width = this.idPull[pId].childNodes[1].childNodes[0].offsetWidth+"px";
				this.idPull[pId].childNodes[1].scrollTop = 0;
				
				arrowUp.style.display = "";
				arrUpH = arrowUp.offsetHeight;
				
				arrowDown.style.display = "";
				arrDownH = arrowDown.offsetHeight;
					
			} else {
				// remove fixed size
				this.idPull[pId].childNodes[1].style.height = "";
				this.idPull[pId].childNodes[1].style.width = "";
			}
			
			
			if (this.itemPull[id] != null) {
				var parPoly = "polygon_"+this.itemPull[id]["parent"];
			} else if (this.conf.context) {
				var parPoly = this.idPull[this.idPrefix+this.topId];
			}
			
			// define position
			var srcX = (this.idPull[id].tagName != null ? window.dhx4.absLeft(this.idPull[id]) : this.idPull[id][0]);
			var srcY = (this.idPull[id].tagName != null ? window.dhx4.absTop(this.idPull[id]) : this.idPull[id][1]);
			var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
			var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);
			
			var x = 0;
			var y = 0;
			var w = this.idPull[pId].offsetWidth;
			var h = this.idPull[pId].offsetHeight;
			
			// pos
			if (openType == "bottom") {
				if (this.conf.rtl) {
					x = srcX + (srcW!=null?srcW:0) - w;
				} else {
					if (this.conf.align == "right") {
						x = srcX + srcW - w;
					} else {
						x = srcX - 1 + (openType==this.conf.dir_toplv?this.conf.tl_rmarg:0);
					}
				}
				y = srcY - 1 + srcH + this.conf.tl_botmarg;
			}
			if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
			if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
			if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }
			
			// overflow check
			if (this.conf.fixed_pos) {
				// use fixed document.body/window dimension if required
				var mx = 65536;
				var my = 65536;
			} else {
				var mx = (this.conf.v.x2!=null?this.conf.v.x2:0);
				var my = (this.conf.v.y2!=null?this.conf.v.y2:0);
				
				if (mx == 0) {
					if (window.innerWidth) {
						mx = window.innerWidth;
						my = window.innerHeight;
					} else {
						mx = document.body.offsetWidth;
						my = document.body.scrollHeight;
					}
				}
			}
			if (x+w > mx && !this.conf.rtl) {
				// no space on right, open to left
				x = srcX - w + 2;
			}
			if (x < this.conf.v.x1 && this.conf.rtl) {
				// no space on left, open to right
				x = srcX + srcW - 2;
			}
			if (x < 0) {
				// menu floats left
				x = 0;
			}
			if (y+h > my && this.conf.v.y2 != null) {
				y = Math.max(srcY + srcH - h + 2, (this.conf.v_enabled?this.conf.v.y1+2:2));
				// open from top level
				if (this.conf.context && this.idPrefix+this.topId == id && arrowDown != null) {
					// autoscroll prevent because menu mouse pointer will right over downarrow
					y = y-2;
				}
				if (this.itemPull[id] != null && !this.conf.context) {
					if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
				}
			}
			//
			this.idPull[pId].style.left = x+"px";
			//this.idPull[pId].style.top = y+arrUpH+"px";
			this.idPull[pId].style.top = y+"px";
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._showPolygonEffect(pId);
			} else {
				this.idPull[pId].style.visibility = "";
				
				if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
					this.idPull[pId].childNodes[1].scrollTop = 0;
					this._checkArrowsState(id);
				}
				
				// show ie6 cover
				if (window.dhx4.isIE6) {
					var pIdIE6 = pId+"_ie6cover";
					if (this.idPull[pIdIE6] == null) {
						var ifr = document.createElement("IFRAME");
						ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.conf.skin;
						ifr.frameBorder = 0;
						ifr.setAttribute("src", "javascript:false;");
						document.body.insertBefore(ifr, document.body.firstChild);
						this.idPull[pIdIE6] = ifr;
					}
					this.idPull[pIdIE6].style.left = x+"px";
					this.idPull[pIdIE6].style.top = y+"px";
					this.idPull[pIdIE6].style.width = this.idPull[pId].offsetWidth+"px";
					this.idPull[pIdIE6].style.height = this.idPull[pId].offsetHeight+"px";
					this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
					this.idPull[pIdIE6].style.display = "";
				}
			}
			
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onShow", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, false);
			}
			
		}
	}
	
	this._redistribSubLevelSelection = function(id, parentId) {
		// clear previosly selected items
		while (this.conf.opened_poly.length > 0) this.conf.opened_poly.pop();
		// this.conf.opened_poly = new Array();
		var i = this._getSubItemToDeselectByPolygon(parentId);
		this._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
		// hide polygons
		for (var q=0; q<this.conf.opened_poly.length; q++) { if (this.conf.opened_poly[q] != parentId) { this._hidePolygon(this.conf.opened_poly[q]); } }
		// add new selection into list new
		if (this.itemPull[id]["state"] == "enabled") {
			this.idPull[id].className = "sub_item_selected";
			if (this.itemPull[id]["complex"] && this.conf.dload && (this.itemPull[id]["loaded"]=="no")) {
				if (this.conf.dload_icon == true) { this._updateLoaderIcon(id, true); }
				this.itemPull[id].loaded = "get";
				var xmlParentId = id.replace(this.idPrefix,"");
				this._dhxdataload.onBeforeXLS = function() {
					var p = {params:{}};
					p.params[this.conf.dload_pid] = xmlParentId;
					for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
					return p;
				};
				this.loadStruct(this.conf.dload_url);
			}
			// show
			if (this.itemPull[id]["complex"] || (this.conf.dload && (this.itemPull[id]["loaded"] == "yes"))) {
				// make arrow over
				if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
					this._updateItemComplexState(id, true, true);
					this._showPolygon(id, this.conf.dir_sublv);
				}
			}
			this._addSubItemToSelected(id, parentId);
			this.conf.selected = id;
		}
	}
	
	this._doOnClick = function(id, type, casState) {
		this.conf.last_click = id;
		// href
		if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
			var form = document.createElement("FORM");
			var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
			form.action = k[0];
			if (k[1] != null) {
				var p = String(k[1]).split("&");
				for (var q=0; q<p.length; q++) {
					var j = String(p[q]).split("=");
					var m = document.createElement("INPUT");
					m.type = "hidden";
					m.name = (j[0]||"");
					m.value = (j[1]||"");
					form.appendChild(m);
				}
			}
			if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
			form.style.display = "none";
			document.body.appendChild(form);
			form.submit();
			if (form != null) {
				document.body.removeChild(form);
				form = null;
			}
			return;
		}
		//
		// some fixes
		if (type.charAt(0)=="c") return; // can't click on complex item
		if (type.charAt(1)=="d") return; // can't click on disabled item
		if (type.charAt(2)=="s") return; // can't click on separator
		//
		if (this.checkEvent("onClick")) {
			this.callEvent("onClick", [id, this.conf.ctx_zoneid, casState]);
		} else {
			if ((type.charAt(1) == "d") || (this.conf.mode == "win" && type.charAt(2) == "t")) return;
		}
		if (this.conf.context && this._isContextMenuVisible() && this.conf.ctx_autohide) {
			this._hideContextMenu();
		} else {
			// if menu unloaded from click event
			if (this._clearAndHide) this._clearAndHide();
		}
	}
	// onTouchMenu action - select topLevel item
	this._doOnTouchMenu = function(id) {
		if (this.conf.is_touched == false) {
			this.conf.is_touched = true;
			if (this.checkEvent("onTouch")) {
				this.callEvent("onTouch", [id]);
			}
		}
	}
	
	// return menu array of all nested objects
	this._searchMenuNode = function(node, menu) {
		var m = new Array();
		for (var q=0; q<menu.length; q++) {
			if (typeof(menu[q]) == "object") {
				if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
				var j = this._searchMenuNode(node, menu[q]);
				if (j.length > 0) { m = j; }
			}
		}
		return m;
	}
	// return array of subitems for single menu object
	this._getMenuNodes = function(node) {
		var m = new Array;
		for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
		return m;
	}
	// generate random string with specified length
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	this.getItemType = function(id) {
		id = this.idPrefix+id;
		if (this.itemPull[id] == null) { return null; }
		return this.itemPull[id]["type"];
	}
	
	this.forEachItem = function(handler) {
		for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
	}
	
	// clear selection and hide menu on onbody click event
	this._clearAndHide = function() {
		that.conf.selected = -1;
		that.conf.last_click = -1;
		while (that.conf.opened_poly.length > 0) { that.conf.opened_poly.pop(); }
		for (var q=0; q<that.conf.selected_sub.length; q++) {
			var id = that.conf.selected_sub[q][0];
			// clear all selection
			if (that.idPull[id] != null) {
				if (that.itemPull[id]["state"] == "enabled") {
					if (that.idPull[id].className == "sub_item_selected") that.idPull[id].className = "sub_item";
					if (that.idPull[id].className == "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected") {
						// custom css
						if (that.itemPull[id]["cssNormal"] != null) {
							that.idPull[id].className = that.itemPull[id]["cssNormal"];
						} else {
							// default css
							that.idPull[id].className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
						}
					}
				}
			}
			that._hidePolygon(id);
		}
		
		that.conf.is_touched = false;
		
		// hide all contextmenu polygons on mouseout
		if (that.conf.context && that.conf.ctx_hideall) that._hidePolygon(that.idPrefix+that.topId);
		
	}
	
	/* show sublevel item */
	this._showSubLevelItem = function(id,back) {
		if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
	}
	/* hide sublevel item */
	this._hideSubLevelItem = function(id) {
		this._showSubLevelItem(id,true)
	}
	// generating id prefix
	this.idPrefix = this._genStr(12)+"_";
	
	/* attach body events */
	this._bodyClick = function(e) {
		e = e||event;
		if (e.button == 2 || (window.dhx4.isOpera && e.ctrlKey == true)) return;
		if (that.conf.context) {
			if (that.conf.ctx_autohide && (!window.dhx4.isOpera || (that._isContextMenuVisible() && window.dhx4.isOpera))) that._hideContextMenu();
		} else {
			if (that._clearAndHide) that._clearAndHide();
		}
	}
	this._bodyContext = function(e) {
		e = e||event;
		var t = String((e.srcElement||e.target).className);
		if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
		var toHide = true;
		var testZone = e.target || e.srcElement;
		while (testZone != null) {
			if (testZone.id != null) if (that.isContextZone(testZone.id)) toHide = false;
			if (testZone == document.body) toHide = false;
			testZone = testZone.parentNode;
		}
		if (toHide) that.hideContextMenu();
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("click", this._bodyClick, false);
		window.addEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.attachEvent("onclick", this._bodyClick);
		document.body.attachEvent("oncontextmenu", this._bodyContext);
	}
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		// remove menu from global store
		dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = null;
		try { delete dhtmlXMenuObject.prototype.liveInst[this.conf.live_id]; } catch(e) {}
		this.conf.live_id = null;
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("click", this._bodyClick, false);
			window.removeEventListener("contextmenu", this._bodyContext, false);
		} else {
			document.body.detachEvent("onclick", this._bodyClick);
			document.body.detachEvent("oncontextmenu", this._bodyContext);
		}
		this._bodyClick = null;
		this._bodyContext = null;
		
		// will recursively remove all items
		this.removeItem(this.idPrefix+this.topId, true);
		
		this.itemPull = null;
		this.idPull = null;
		
		// clear context zones
		if (this.conf.context) for (var a in this.conf.ctx_zones) this.removeContextZone(a);
		
		if (this.cont != null) {
			this.cont.className = "";
			this.cont.parentNode.removeChild(this.cont);
			this.cont = null;
		}
		
		if (this.base != null) {
			if (!this.conf.context) this.base.className = "";
			if (!this.conf.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
			this.base.onselectstart = null;
			this.base = null;
		}
		
		for (var a in this) this[a] = null;
		that = null;
		
	}
	
	// register instance
	dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = this;
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", this.conf.tags.root, {struct:true});
	window.dhx4._eventable(this);
	
	// autoload
	if (window.dhx4.s2b(this.conf.autoload.context) == true) this.renderAsContextMenu();
	
	if (this.conf.autoload.dynamic != null) {
		this.enableDynamicLoading(this.conf.autoload.dynamic, window.dhx4.s2b(this.conf.autoload.dynamic_icon));
	} else if (this.conf.autoload.items != null) {
		this.loadStruct(this.conf.autoload.items, this.conf.autoload.onload);
	} else if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	}
	
	for (var a in {onclick:1,oncheckboxclick:1,onradioclick:1}) {
		if (this.conf.autoload[a] != null) {
			if (typeof(this.conf.autoload[a]) == "function") {
				this.attachEvent(a, this.conf.autoload[a]);
			} else if (typeof(window[this.conf.autoload[a]]) == "function") {
				this.attachEvent(a, window[this.conf.autoload[a]]);
			}
		}
	}
	
	if (this.conf.autoload.top_text != null) this.setTopText(this.conf.autoload.top_text);
	if (this.conf.autoload.align != null) this.setAlign(this.conf.autoload.align);
	if (this.conf.autoload.open_mode != null) this.setOpenMode(this.conf.autoload.open_mode);
	if (this.conf.autoload.overflow != null) this.setOverflowHeight(this.conf.autoload.overflow);
	
	if (this.conf.autoload.iconset == "awesome") {
		this.conf.icons_css = true;
	}
	
	//
	for (var a in this.conf.autoload) {
		this.conf.autoload[a] = null;
		delete this.conf.autoload[a];
	}
	this.conf.autoload = null;
	
	//
	return this;
	
};

dhtmlXMenuObject.prototype._init = function() {
	if (this._isInited == true) return;
	if (this.conf.dload) {
		this._dhxdataload.onBeforeXLS = function() {
			var p = {params:{}};
			for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
			return p;
		};
		this.loadStruct(this.conf.dload_url);
	} else {
		this._initTopLevelMenu();
		this._isInited = true;
	}
};

dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {
	
	var count = 0;
	
	for (var a in this.itemPull) {
		
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (this.idPull[a] != null) {
			if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
				count++;
			}
		}
	}
	return count;
};

dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
	// alert(id)
	if (this.idPrefix+this.topId == id) { return; }
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		var u = this._countVisiblePolygonItems(id);
		if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
		if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
	}
};

dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
	// 0.2 FIX :: topLevel's items can have complex items with arrow
	if ((!this.conf.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
		// 30.06.2008 fix > complex state for top level item, state only, no arrow
		this.itemPull[id]["complex"] = state;
		return;
	}
	if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
	// 0.2 FIX :: end
	this.itemPull[id]["complex"] = state;
	// fixed in 0.4 for context
	if (id == this.idPrefix+this.topId) return;
	// end fix
	// try to retrieve arrow img object
	var arrowObj = null;
	
	
	var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
	if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];
	
	if (this.itemPull[id]["complex"]) {
		// create arrow
		if (arrowObj == null) {
			arrowObj = document.createElement("DIV");
			arrowObj.className = "complex_arrow";
			arrowObj.id = "arrow_"+id;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(arrowObj);
		}
		// over state added in 0.4
		
		if (this.conf.dload && (this.itemPull[id].loaded == "get") && this.conf.dload_icon) {
			// change arrow to loader
			if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
		} else {
			arrowObj.className = "complex_arrow";
		}
		
		return;
	}
	
	if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
		item.removeChild(arrowObj);
		if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
	}
	
};

dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
	return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
};

dhtmlXMenuObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};

/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
	// search existsing image
	id = this.idPrefix+id;
	
	var tp = this.itemPull[id]["type"];
	if (tp == "checkbox" || tp == "radio") return;
	
	var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context);
	
	// search existing image
	var imgObj = null;
	if (isTopLevel) {
		for (var q=0; q<this.idPull[id].childNodes.length; q++) {
			if (imgObj == null && (this.idPull[id].childNodes[q].className || "") == "dhtmlxMenu_TopLevel_Item_Icon" || (this.idPull[id].childNodes[q].tagName||"").toLowerCase() == "i") {
				imgObj = this.idPull[id].childNodes[q];
			}
		}
	} else {
		try { var imgObj = this.idPull[id].childNodes[this.conf.rtl?2:0].childNodes[0]; } catch(e) { }
		if (!(imgObj != null && typeof(imgObj.className) != "undefined" && (imgObj.className == "sub_icon" || imgObj.tagName.toLowerCase() == "i"))) imgObj = null;
	}
	
	var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	
	if (imgSrc.length > 0) {
		if (imgObj != null) {
			if (this.conf.icons_css == true) {
				imgObj.className = this.conf.icons_path+imgSrc;
			} else {
				imgObj.src = this.conf.icons_path+imgSrc;
			}
		} else {
			if (isTopLevel) {
				if (this.conf.icons_css == true) {
					var imgObj = document.createElement("i");
					imgObj.className = this.conf.icons_path+imgSrc;
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
				}
				if (!this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);				
			} else {
				if (this.conf.icons_css == true) {
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					item.innerHTML = "<i class='"+this.conf.icons_path+imgSrc+"'></i>";
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "sub_icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
					item.appendChild(imgObj);
				}
			}
		}
	} else {
		if (imgObj != null) {
			if (isTopLevel) {
				imgObj.parentNode.removeChild(imgObj);
				imgObj = null;
			} else {
				var p = imgObj.parentNode;
				p.removeChild(imgObj);
				p.innerHTML = "&nbsp;";
				p = imgObj = null;
			}
		}
	}
};

// collect parents for remove complex item
dhtmlXMenuObject.prototype._getAllParents = function(id) {
	var parents = new Array();
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == id) {
			parents[parents.length] = this.itemPull[a]["id"];
			if (this.itemPull[a]["complex"]) {
				var t = this._getAllParents(this.itemPull[a]["id"]);
				for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
			}
		}
	}
	return parents;
};

// visible area
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
	if (this.conf.v_enabled) return;
	var d = window.dhx4.screenDim();
	this.conf.v.x1 = d.left;
	this.conf.v.x2 = d.right;
	this.conf.v.y1 = d.top;
	this.conf.v.y2 = d.bottom;
};

dhtmlXMenuObject.prototype.getItemPosition = function(id) {
	id = this.idPrefix+id;
	var pos = -1;
	if (this.itemPull[id] == null) return pos;
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
	return pos;
};

dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
	id = this.idPrefix+id;
	if (this.idPull[id] == null) { return; }
	// added in 0.4
	var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
	//
	var itemData = this.idPull[id];
	var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	obj.removeChild(obj.childNodes[itemPos]);
	if (pos < 0) pos = 0;
	// added in 0.4
	if (isOnTopLevel && pos < 1) { pos = 1; }
	//
	if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
};

dhtmlXMenuObject.prototype.getParentId = function(id) {
	id = this.idPrefix+id;
	if (this.itemPull[id] == null) { return null; }
	return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
};


// hide any opened polygons
dhtmlXMenuObject.prototype.hide = function() {
	this._clearAndHide();
};
dhtmlXMenuObject.prototype.clearAll = function() {
	this.removeItem(this.idPrefix+this.topId, true);
	this._isInited = false;
	this.idPrefix = this._genStr(12)+"_";
	this.itemPull = {};
};

// dhtmlxmenu global store
if (typeof(dhtmlXMenuObject.prototype.liveInst) == "undefined") {
	dhtmlXMenuObject.prototype.liveInst = {};
};

dhtmlXMenuObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name == "awesome");
};
// redistrib selection in case of top node in real-time mode
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
	// kick polygons and decelect before selected menues
	var i = this._getSubItemToDeselectByPolygon("parent");
	this._removeSubItemFromSelected(-1, -1);
	for (var q=0; q<i.length; q++) {
		if (i[q] != id) { this._hidePolygon(i[q]); }
		if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
	}
	// check if enabled
	if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
		this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_Selected";
		//
		this._addSubItemToSelected(this.idPrefix+id, "parent");
		this.conf.selected = (this.conf.mode=="win"?(this.conf.selected!=-1?id:this.conf.selected):id);
		if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.conf.selected != -1)) { this._showPolygon(this.idPrefix+id, this.conf.dir_toplv); }
	}
};

dhtmlXMenuObject.prototype._initTopLevelMenu = function() {
	
	this.conf.dir_toplv = "bottom";
	this.conf.dir_sublv = (this.conf.rtl?"left":"right");
	if (this.conf.context) {
		this.idPull[this.idPrefix+this.topId] = new Array(0,0);
		this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
	} else {
		var m = this._getMenuNodes(this.idPrefix + this.topId);
		for (var q=0; q<m.length; q++) {
			if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
			if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
		}
	}
};

// add top menu item, complex define that submenues are in presence
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
	var that = this;
	var m = document.createElement("DIV");
	m.id = id;
	// custom css
	if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
		m.className = this.itemPull[id]["cssNormal"];
	} else {
		m.className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
	}
	
	// text
	if (this.itemPull[id]["title"] != "") {
		var t1 = document.createElement("DIV");
		t1.className = "top_level_text";
		t1.innerHTML = this.itemPull[id]["title"];
		m.appendChild(t1);
	}
	// tooltip
	if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
	//
	// image in top level
	if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
		var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
		if (imgTop) {
			if (this.conf.icons_css == true) {
				var i = document.createElement("i");
				i.className = this.conf.icons_path+imgTop;
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(i, m.childNodes[0]); else m.appendChild(i);
			} else {
				var img = document.createElement("IMG");
				img.border = "0";
				img.id = "image_"+id;
				img.src = this.conf.icons_path+imgTop;
				img.className = "dhtmlxMenu_TopLevel_Item_Icon";
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
			}
		}
	}
	m.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	m.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// add container for top-level items if not exists yet
	if (!this.cont) {
		this.cont = document.createElement("DIV");
		this.cont.dir = "ltr";
		this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		this.base.appendChild(this.cont);
	}
	// insert
	
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
	if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);
	
	this.idPull[m.id] = m;
	// create submenues
	if (this.itemPull[id]["complex"] && (!this.conf.dload)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
	// events
	m.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// kick polygons and decelect before selected menues
		var i = that._getSubItemToDeselectByPolygon("parent");
		that._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) {
			if (i[q] != this.id) { that._hidePolygon(i[q]); }
			if ((that.idPull[i[q]] != null) && (i[q] != this.id)) {
				// custom css
				if (that.itemPull[i[q]]["cssNormal"] != null) {
					that.idPull[i[q]].className = that.itemPull[i[q]]["cssNormal"];
				} else {
					if (that.idPull[i[q]].className == "sub_item_selected") that.idPull[i[q]].className = "sub_item";
					that.idPull[i[q]].className = that.idPull[i[q]].className.replace(/Selected/g, "Normal");
				}
			}
		}
		// check if enabled
		if (that.itemPull[this.id]["state"] == "enabled") {
			this.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected";
			//
			that._addSubItemToSelected(this.id, "parent");
			that.conf.selected = (that.conf.mode=="win"?(that.conf.selected!=-1?this.id:that.conf.selected):this.id);
			if (that.conf.dload) {
				if (that.itemPull[this.id].loaded == "no") {
					this._dynLoadTM = new Date().getTime();
					that.itemPull[this.id].loaded = "get";
					var xmlParentId = this.id.replace(that.idPrefix,"");
					that._dhxdataload.onBeforeXLS = function() {
						var p = {params:{}};
						p.params[this.conf.dload_pid] = xmlParentId;
						for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
						return p;
					};
					that.loadStruct(that.conf.dload_url);
				}
				if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
					this._mouseOver = true;
				}
			}
			if ((!that.conf.dload) || (that.conf.dload && (!that.itemPull[this.id]["loaded"] || that.itemPull[this.id]["loaded"]=="yes"))) {
				if ((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) {
					if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
						this._mouseOver = true;
						var showItemId = this.id;
						this._menuOpenTM = window.setTimeout(function(){that._showPolygon(showItemId, that.conf.dir_toplv);}, that.conf.top_tmtime);
					} else {
						that._showPolygon(this.id, that.conf.dir_toplv);
					}
				}
			}
		}
		that._doOnTouchMenu(this.id.replace(that.idPrefix, ""));
	}
	m.onmouseout = function() {
		if (!((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) && (that.itemPull[this.id]["state"]=="enabled")) {
			// custom css
			
			if (that.itemPull[this.id]["cssNormal"] != null) {
				// alert(1)
				m.className = that.itemPull[this.id]["cssNormal"];
			} else {
				// default css
				m.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
			}
		}
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
			this._mouseOver = false;
			window.clearTimeout(this._menuOpenTM);
		}
	}
	m.onclick = function(e) {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// fix, added in 0.4
		if (that.conf.mode != "web" && that.itemPull[this.id]["state"] == "disabled") { return; }
		//
		e = e || event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.conf.mode == "win") {
			if (that.itemPull[this.id]["complex"]) {
				if (that.conf.selected == this.id) { that.conf.selected = -1; var s = false; } else { that.conf.selected = this.id; var s = true; }
				if (s) { that._showPolygon(this.id, that.conf.dir_toplv); } else { that._hidePolygon(this.id); }
			}
		}
		var tc = (that.itemPull[this.id]["complex"]?"c":"-");
		var td = (that.itemPull[this.id]["state"]!="enabled"?"d":"-");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"t", cas);
		return false;
	}
	
	if (this.conf.skin == "dhx_terrace") {
		this._improveTerraceSkin();
	}
};

// recursively creates and adds submenu polygon
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
	var s = this._renderSublevelPolygon(id, parentId);
	var j = this._getMenuNodes(parentId);
	for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
	if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
	for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
};

// inner: add single subpolygon/item/separator
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
	var s = document.createElement("DIV");
	s.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Polygon "+(this.conf.rtl?"dir_right":"");
	s.dir = "ltr";
	s.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
	s.id = "polygon_" + parentId;
	s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
	s.style.display = "none";
	document.body.insertBefore(s, document.body.firstChild);
	//
	
	s.innerHTML = '<div style="position:relative;"></div>'+'<div style="position: relative; overflow:hidden;"></div>'+'<div style="position:relative;"></div>';
	
	var tbl = document.createElement("TABLE");
	tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
	tbl.cellSpacing = 0;
	tbl.cellPadding = 0;
	tbl.border = 0;
	var tbd = document.createElement("TBODY");
	tbl.appendChild(tbd);
	
	s.childNodes[1].appendChild(tbl);
	
	s.tbl = tbl;
	s.tbd = tbd;
	// polygon
	this.idPull[s.id] = s;
	if (this.sxDacProc != null) {
		this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
		if (window.dhx4.isIE) {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
		} else {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
		}
	}
	return s;
};

dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
	var that = this;
	
	var tr = document.createElement("TR");
	tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");
	
	// icon
	var t1 = document.createElement("TD");
	t1.className = "sub_item_icon";
	var tp = this.itemPull[id]["type"];
	var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	if (icon != "") {
		if (tp=="checkbox"||tp=="radio") {
			var img = document.createElement("DIV");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon "+icon;
			t1.appendChild(img);
		}
		if (!(tp=="checkbox"||tp=="radio")) {
			if (this.conf.icons_css == true) {
				t1.innerHTML = "<i class='"+this.conf.icons_path+icon+"'></i>";
			} else {
				var img = document.createElement("IMG");
				img.id = "image_"+this.itemPull[id]["id"];
				img.className = "sub_icon";
				img.src = this.conf.icons_path+icon;
				t1.appendChild(img);
			}
		}
	} else {
		t1.innerHTML = "&nbsp;";
	}
	
	// text
	var t2 = document.createElement("TD");
	t2.className = "sub_item_text";
	if (this.itemPull[id]["title"] != "") {
		var t2t = document.createElement("DIV");
		t2t.className = "sub_item_text";
		t2t.innerHTML = this.itemPull[id]["title"];
		t2.appendChild(t2t);
	} else {
		t2.innerHTML = "&nbsp;";
	}
	
	// hotkey/sublevel arrow
	var t3 = document.createElement("TD");
	t3.className = "sub_item_hk";
	if (this.itemPull[id]["complex"]) {
		
		var arw = document.createElement("DIV");
		arw.className = "complex_arrow";
		arw.id = "arrow_"+this.itemPull[id]["id"];
		t3.appendChild(arw);
		
	} else {
		if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
			var t3t = document.createElement("DIV");
			t3t.className = "sub_item_hk";
			t3t.innerHTML = this.itemPull[id]["hotkey"];
			t3.appendChild(t3t);
		} else {
			t3.innerHTML = "&nbsp;";
		}
	}
	tr.appendChild(this.conf.rtl?t3:t1);
	tr.appendChild(t2);
	tr.appendChild(this.conf.rtl?t1:t3);
	
	
	//
	tr.id = this.itemPull[id]["id"];
	tr.parent = this.itemPull[id]["parent"];
	// tooltip, added in 0.4
	if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
	//
	tr.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	tr.onmouseover = function(e) {
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		if (that.conf.mode == "web") window.clearTimeout(that.conf.tm_handler);
		if (!this._visible) that._redistribSubLevelSelection(this.id, this.parent); // if not visible
		this._visible = true;
	}
	tr.onmouseout = function() {
		if (that.conf.mode == "web") {
			if (that.conf.tm_handler) window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){if(that&&that._clearAndHide)that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		var k = this;
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		that.conf.hide_tm[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
	}
	tr.onclick = function(e) {
		// added in 0.4, preven complex closing if user event not defined
		if (!that.checkEvent("onClick") && that.itemPull[this.id]["complex"]) return;
		//
		e = e || event; e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		tc = (that.itemPull[this.id]["complex"]?"c":"-");
		td = (that.itemPull[this.id]["state"]=="enabled"?"-":"d");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		switch (that.itemPull[this.id]["type"]) {
			case "checkbox":
				that._checkboxOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "radio":
				that._radioOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "item":
				that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
		}
		return false;
	}
	// add
	var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
	if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
	this.idPull[tr.id] = tr;
};

dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
	var level = (this.conf.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
	if (level == "TopLevel" && this.conf.context) return;
	
	var that = this;
	
	if (level != "TopLevel") {
		var tr = document.createElement("TR");
		tr.className = "sub_sep";
		var td = document.createElement("TD");
		td.colSpan = "3";
		tr.appendChild(td);
	}
	
	var k = document.createElement("DIV");
	k.id = "separator_"+id;
	k.className = (level=="TopLevel"?"top_sep":"sub_sep");
	k.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	k.onclick = function(e) {
		e = e || event; e.cancelBubble = true;
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace("separator_" + that.idPrefix, ""), "--s", cas);
	}
	if (level == "TopLevel") {
		if (pos != null) {
			pos++; if (pos < 0) { pos = 0; }
			// if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
			if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
		} else {
			// add as a last item
			// var last = this.base.childNodes[this.base.childNodes.length-1];
			var last = this.cont.childNodes[this.cont.childNodes.length-1];
			// if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
			if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
		}
		this.idPull[k.id] = k;
	} else {
		var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
		if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
		if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
		td.appendChild(k);
		this.idPull[k.id] = tr;
	}
};

dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) {
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+this.getParentId(nextToId);
	
	this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
	this._renderSeparator(itemId, this.getItemPosition(nextToId));
};


dhtmlXMenuObject.prototype._initObj = function(items, nested, parentId) {
	
	if (!(items instanceof Array)) {
		parentId = items.parentId;
		if (parentId != null && String(parentId).indexOf(this.idPrefix) !== 0) parentId = this.idPrefix+String(parentId);
		items = items.items;
	}
	
	for (var q=0; q<items.length; q++) {
		
		// api-init, items w/o id
		if (typeof(items[q].id) == "undefined" || items[q].id == null) {
			items[q].id = this._genStr(24);
		}
		
		// empty text fix
		if (items[q].text == null) items[q].text = "";
		
		// api-init, add idPrefix
		if (String(items[q].id).indexOf(this.idPrefix) !== 0) {
			items[q].id = this.idPrefix+String(items[q].id);
		}
		
		var k = {type: "item", tip: "", hotkey: "", state: "enabled", imgen: "", imgdis: ""};
		for (var a in k) { if (typeof(items[q][a]) == "undefined") items[q][a] = k[a]; }
		
		//
		if (items[q].imgen == "" && items[q].img != null) items[q].imgen = items[q].img;
		if (items[q].imgdis == "" && items[q].img_disabled != null) items[q].imgdis = items[q].img_disabled;
		if (items[q].title == null && items[q].text != null) items[q].title = items[q].text;
		
		// hrefs
		if (items[q].href != null) {
			if (items[q].href.link != null) items[q].href_link = items[q].href.link;
			if (items[q].href.target != null) items[q].href_target = items[q].href.target;
		}
		
		// userdata
		if (items[q].userdata != null) {
			for (var a in items[q].userdata) this.userData[items[q].id+"_"+a] = items[q].userdata[a];
		}

		
		// en/dis
		if (typeof(items[q].enabled) != "undefined" && window.dhx4.s2b(items[q].enabled) == false) {
			items[q].state = "disabled";
		} else if (typeof(items[q].disabled) != "undefined" && window.dhx4.s2b(items[q].disabled) == true) {
			items[q].state = "disabled";
		}
		
		//
		if (typeof(items[q].parent) == "undefined") {
			items[q].parent = (parentId != null ? parentId : this.idPrefix+this.topId);
		}
		
		
		// checkbox
		if (items[q].type == "checkbox") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "chbx_"+(items[q].checked?"1":"0"); // set classname
		}
		// radio
		if (items[q].type == "radio") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "rdbt_"+(items[q].checked?"1":"0");
			// group
			if (typeof(items[q].group) == "undefined" || items[q].group == null) items[q].group = this._genStr(24);
			if (this.radio[items[q].group] == null) this.radio[items[q].group] = [];
			this.radio[items[q].group].push(items[q].id);
		}
		
		//
		this.itemPull[items[q].id] = items[q];
		if (items[q].items != null && items[q].items.length > 0) {
			this.itemPull[items[q].id].complex = true;
			this._initObj(items[q].items, true, items[q].id);
		} else if (this.conf.dload && items[q].complex == true) {
			this.itemPull[items[q].id].loaded = "no";
		}
		this.itemPull[items[q].id].items = null;
		
	}
	
	if (nested !== true) {
		if (this.conf.dload == true) {
			if (parentId == null) {
				this._initTopLevelMenu();
			} else {
				this._addSubMenuPolygon(parentId, parentId);
				if (this.conf.selected == parentId) {
					var isTop = (this.itemPull[parentId].parent == this.idPrefix+this.topId);
					var level = (isTop && !this.conf.context ? this.conf.dir_toplv:this.conf.dir_sublv);
					var isShow = false;
					if (isTop && this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
						var item = this.idPull[parentId];
						if (item._mouseOver == true) {
							var delay = this.conf.top_tmtime - (new Date().getTime()-item._dynLoadTM);
							if (delay > 1) {
								var pId = parentId;
								var that = this;
								item._menuOpenTM = window.setTimeout(function(){
									that._showPolygon(pId, level);
									that = pId = null;
								}, delay);
								isShow = true;
							}
						}
					}
					if (!isShow) this._showPolygon(parentId, level);
				}
				
				this.itemPull[parentId].loaded = "yes";
				if (this.conf.dload_icon == true) this._updateLoaderIcon(parentId, false);
			}
		} else {
			this._init();
		}
	}
	
};

dhtmlXMenuObject.prototype._xmlToJson = function(xml, parentId) {
	
	var items = [];
	
	if (parentId == null) {
		var root = xml.getElementsByTagName(this.conf.tags.root);
		if (root == null || (root != null && root.length == 0)) return {items:[]};
		root = root[0];
	} else {
		root = xml;
	}
	
	if (root.getAttribute("parentId") != null) {
		parentId = this.idPrefix+root.getAttribute("parentId");
	}
	
	for (var q=0; q<root.childNodes.length; q++) {
		if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == this.conf.tags.item) {
			var r = root.childNodes[q];
			var item = {
				// basic
				id: this.idPrefix+(r.getAttribute("id")||this._genStr(24)),
				title: r.getAttribute("text")||"",
				// images
				imgen: r.getAttribute("img")||"",
				imgdis: r.getAttribute("imgdis")||"",
				tip: "",
				hotkey: "",
				//
				type: r.getAttribute("type")||"item"
			};
			// custom css
			if (r.getAttribute("cssNormal") != null) {
				item.cssNormal = r.getAttribute("cssNormal");
			}
			// checkbox
			if (item.type == "checkbox") item.checked = r.getAttribute("checked");
			// radio
			if (item.type == "radio") {
				item.checked = r.getAttribute("checked");
				item.group = r.getAttribute("group");
			}
			// en/dis
			item.state = "enabled";
			if (r.getAttribute("enabled") != null && window.dhx4.s2b(r.getAttribute("enabled")) == false) {
				item.state = "disabled";
			} else if (r.getAttribute("disabled") != null && window.dhx4.s2b(r.getAttribute("disabled")) == true) {
				item.state = "disabled";
			}
			
			item.parent = (parentId != null ? parentId : this.idPrefix+this.topId);
			// is complex item
			if (this.conf.dload) {
				item.complex = (r.getAttribute("complex") != null);
				if (item.complex) item.loaded = "no";
			} else {
				var i = this._xmlToJson(r, item.id);
				item.items = i.items;
				item.complex = (item.items.length > 0);
			}
			
			// misc
			for (var w=0; w<r.childNodes.length; w++) {
				if (typeof(r.childNodes[w].tagName) != "undefined") {
					var t = String(r.childNodes[w].tagName||"").toLowerCase();
					// userdata
					if (t == this.conf.tags.userdata) {
						var d = r.childNodes[w];
						if (d.getAttribute("name") != null) {
							this.userData[item.id+"_"+d.getAttribute("name")] = (d.firstChild != null && d.firstChild.nodeValue != null ? d.firstChild.nodeValue : "");
						}
					}
					// extended text
					if (t == this.conf.tags.text_ext) {
						item.title = r.childNodes[w].firstChild.nodeValue;
					}
					// tooltips
					if (t == this.conf.tags.tooltip) {
						item.tip = r.childNodes[w].firstChild.nodeValue;
					}
					// hotkeys
					if (t == this.conf.tags.hotkey) {
						item.hotkey = r.childNodes[w].firstChild.nodeValue;
					}
					// hrefs
					if (t == this.conf.tags.href && item.type == "item") {
						item.href_link = r.childNodes[w].firstChild.nodeValue;
						if (r.childNodes[w].getAttribute("target") != null) {
							item.href_target = r.childNodes[w].getAttribute("target");
						}
					}
				}
			}
			items.push(item);
		}
	}
	
	var r = {
		parentId: parentId,//(root.getAttribute("parentId")||null),
		items: items
	};
	
	return r;
};

// dynload
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
	this.conf.dload = true;
	this.conf.dload_url = url;
	this.conf.dload_sign = (String(this.conf.dload_url).search(/\?/)==-1?"?":"&");
	this.conf.dload_icon = icon;
	this._init();
};

dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {
	
	if (this.idPull[id] == null) return;
	if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
	// get arrow
	var ind = (this.conf.rtl?0:2);
	if (!this.idPull[id].childNodes[ind]) return;
	if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
	var aNode = this.idPull[id].childNodes[ind].childNodes[0];
	if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

};



// add/remove
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);
	
	this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if ((parentId == this.idPrefix+this.topId) && (!this.conf.context)) {
		this._renderToplevelItem(id, this.getItemPosition(nextToId));
	} else {
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	}
};

dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	if (parentId == null) {
		if (this.conf.context) {
			parentId = this.topId;
		} else {
			this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
			if (pos != null) this.setItemPosition(itemId, pos);
			return;
		}
	}
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	// remove hotkey, added in 0.4
	if (this.setHotKey) this.setHotKey(parentId, "");
	//
	parentId = this.idPrefix+parentId;
	this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
	this._renderSublevelItem(itemId, pos-1);
	
	this._redefineComplexState(parentId);
};

dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
	if (!_isTId) id = this.idPrefix + id;
	
	var pId = null;
	
	if (id != this.idPrefix+this.topId) {
		
		if (this.itemPull[id] == null) return;
		
		// effects
		if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);
		
		// separator top
		var t = this.itemPull[id]["type"];
		
		if (t == "separator") {
			var item = this.idPull["separator_"+id];
			if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
				item.onclick = null;
				item.onselectstart = null;
				item.id = null;
				item.parentNode.removeChild(item);
			} else {
				item.childNodes[0].childNodes[0].onclick = null;
				item.childNodes[0].childNodes[0].onselectstart = null;
				item.childNodes[0].childNodes[0].id = null;
				item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
				item.removeChild(item.childNodes[0]);
				item.parentNode.removeChild(item);
			}
			this.idPull["separator_"+id] = null;
			this.itemPull[id] = null;
			delete this.idPull["separator_"+id];
			delete this.itemPull[id];
			item = null;
		} else {
			// item checkbox radio
			pId = this.itemPull[id]["parent"];
			var item = this.idPull[id];
			item.onclick = null;
			item.oncontextmenu = null;
			item.onmouseover = null;
			item.onmouseout = null;
			item.onselectstart = null;
			item.id = null;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.parentNode.removeChild(item);
			this.idPull[id] = null;
			this.itemPull[id] = null;
			delete this.idPull[id];
			delete this.itemPull[id];
			item = null;
			
		}
		t = null;
	}
	
	// clear nested items
	for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);
	
	// check if empty polygon left
	var p2 = new Array(id);
	if (pId != null && !_recCall) {
		if (this.idPull["polygon_"+pId] != null) {
			if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
				p2.push(pId);
				this._updateItemComplexState(pId, false, false);
			}
		}
	}
	
	// delete nested polygons and parent's if any
	for (var q=0; q<p2.length; q++) {
		if (this.idPull["polygon_"+p2[q]]) {
			var p = this.idPull["polygon_"+p2[q]];
			p.onclick = null;
			p.oncontextmenu = null;
			p.tbl.removeChild(p.tbd);
			p.tbd = null;
			p.childNodes[1].removeChild(p.tbl);
			p.tbl = null;
			p.id = null;
			p.parentNode.removeChild(p);
			p = null;
			if (window.dhx4.isIE6) {
				var pc = "polygon_"+p2[q]+"_ie6cover";
				if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
			}
			if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
			if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
			//
			this.idPull["polygon_"+p2[q]] = null;
			delete this.idPull["polygon_"+p2[q]];
		}
	}
	p2 = null;
	
	// update corners
	if (this.conf.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();
	
};


// add item to storage
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
	var item = {
		id:	itemId,
		title:	itemText,
		imgen:	(img!=null?img:""),
		imgdis:	(imgDis!=null?imgDis:""),
		type:	itemType,
		state:	(disabled==true?"disabled":"enabled"),
		parent:	itemParentId,
		complex:false,
		hotkey:	"",
		tip:	""};
	this.itemPull[item.id] = item;
};

dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
	this.conf.context = true;
	if (this.base._autoSkinUpdate == true) {
		this.base.className = this.base.className.replace("dhtmlxMenu_"+this.conf.skin+"_Middle","");
		this.base._autoSkinUpdate = false;
	}
	if (this.conf.ctx_baseid != null) { this.addContextZone(this.conf.ctx_baseid); }
};

dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
	if (zoneId == document.body) {
		zoneId = "document.body."+this.idPrefix;
		var zone = document.body;
	} else if (typeof(zoneId) == "string") {
		var zone = document.getElementById(zoneId);
	} else {
		var zone = zoneId;
	}
	var zoneExists = false;
	for (var a in this.conf.ctx_zones) { zoneExists = zoneExists || (a == zoneId) || (this.conf.ctx_zones[a] == zone); }
	if (zoneExists == true) return false;
	this.conf.ctx_zones[zoneId] = zone;
	var that = this;
	if (window.dhx4.isOpera) {
		this.operaContext = function(e){ that._doOnContextMenuOpera(e, that); }
		zone.addEventListener("mouseup", this.operaContext, false);
		//
	} else {
		if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
		zone.oncontextmenu = function(e) {
			// autoclose any other opened context menues
			for (var q in dhtmlXMenuObject.prototype.liveInst) {
				if (q != that.conf.live_id) {
					if (dhtmlXMenuObject.prototype.liveInst[q].context) {
						dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
					}
				}
			}
			//
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that._doOnContextBeforeCall(e, this);
			return false;
		}
	}
};
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, that) {
	// autoclose any other opened context menues
	for (var q in dhtmlXMenuObject.prototype.liveInst) {
		if (q != that.conf.live_id) {
			if (dhtmlXMenuObject.prototype.liveInst[q].context) {
				dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
			}
		}
	}
	//
	e.cancelBubble = true;
	if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	if (e.button == 0 && e.ctrlKey == true) { that._doOnContextBeforeCall(e, this); }
	return false;
};

dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
	if (!this.isContextZone(zoneId)) return false;
	if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
	var zone = this.conf.ctx_zones[zoneId];
	if (window.dhx4.isOpera) {
		zone.removeEventListener("mouseup", this.operaContext, false);
	} else {
		zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
		zone._oldContextMenuHandler = null;
	}
	try {
		this.conf.ctx_zones[zoneId] = null;
		delete this.conf.ctx_zones[zoneId];
 	} catch(e){}
	return true;
};

dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
	if (zoneId == document.body && this.conf.ctx_zones["document.body."+this.idPrefix] != null) return true;
	var isZone = false;
	if (this.conf.ctx_zones[zoneId] != null) { if (this.conf.ctx_zones[zoneId] == document.getElementById(zoneId)) isZone = true; }
	return isZone;
};
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
};
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
	// hide any opened context menu/polygons
	this._clearAndHide();
	// open
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	window.clearTimeout(this.conf.tm_handler);
	this.idPull[this.idPrefix+this.topId] = new Array(x, y);
	this._showPolygon(this.idPrefix+this.topId, "bottom");
	this.callEvent("onContextMenu", [zoneId]);
};
dhtmlXMenuObject.prototype._hideContextMenu = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	this._clearAndHide();
	this._hidePolygon(this.idPrefix+this.topId);
};

dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
	this.conf.ctx_zoneid = cZone.id;
	this._clearAndHide();
	this._hideContextMenu();
	
	// scroll settings
	if (window.dhx4.isChrome == true || window.dhx4.isEdge == true || window.dhx4.isOpera == true || window.dhx4.isIE11 == true) {
		var mx = window.dhx4.absLeft(e.target)+e.offsetX;
		var my = window.dhx4.absTop(e.target)+e.offsetY;
	} else if (window.dhx4.isIE6 == true || window.dhx4.isIE7 == true || window.dhx4.isIE == true) { // old IE or emulation
		var mx = window.dhx4.absLeft(e.srcElement)+e.x||0;
		var my = window.dhx4.absTop(e.srcElement)+e.y||0;
	} else { // the rest
		var p = (e.srcElement||e.target);
		var px = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetX:e.layerX);
		var py = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetY:e.layerY);
		var mx = window.dhx4.absLeft(p)+px;
		var my = window.dhx4.absTop(p)+py;
	}
	
	if (this.checkEvent("onBeforeContextMenu")) {
		if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
			if (this.conf.ctx_autoshow) {
				this._showContextMenu(mx, my, cZone.id);
				this.callEvent("onAfterContextMenu", [cZone.id,e]);
			}
		}
	} else {
		if (this.conf.ctx_autoshow) {
			this._showContextMenu(mx, my, cZone.id);
			this.callEvent("onAfterContextMenu", [cZone.id]);
		}
	}
};

dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
	this._showContextMenu(x, y, false);
};

dhtmlXMenuObject.prototype.hideContextMenu = function() {
	this._hideContextMenu();
};

dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
	this.conf.ctx_autoshow = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
	this.conf.ctx_autohide = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
	this.conf.ctx_hideall = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
	return this.conf.ctx_hideall;
};

dhtmlXMenuObject.prototype._improveTerraceSkin = function() {
	
	for (var a in this.itemPull) {
		
		if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator
			
			var bl = false;
			var br = false;
			
			// left side, first item, not sep
			if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
				bl = true;
			}
			
			// right side, last item, not sep
			if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
				br = true;
			}
			
			// check siblings
			for (var b in this.itemPull) {
				if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
					if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
						br = true;
					}
					if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
						bl = true;
					}
				}
			}
			
			this.idPull[a].style.borderLeftWidth = (bl?"1px":"0px");
			this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"3px":"0px");
			
			this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"3px":"0px");
			
			this.idPull[a]._bl = bl;
			this.idPull[a]._br = br;
			
		}
	}
	
};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
	if (state) {
		this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "3px" : "0px");
		this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "3px" : "0px");
	} else {
		this.idPull[id].style.borderBottomLeftRadius = "0px";
		this.idPull[id].style.borderBottomRightRadius = "0px";
	}
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_menu = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_menu_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]); // before toolbar or before cont, 0=hdr
		
		this.conf.ofs_nodes.t.menu = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	};
	
	dhtmlXCellObject.prototype.attachMenu = function(conf) {
		
		if (this.dataNodes.menu) return; // return this.dataNodes.menu?
		
		this.callEvent("_onBeforeContentAttach", ["menu"]);
		
		if (typeof(conf) == "undefined") conf = {};
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("menu").firstChild;
		
		this.dataNodes.menu = new dhtmlXMenuObject(conf);
		this._adjustCont(this._idd);
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.menu;
		
	};
	
	dhtmlXCellObject.prototype.detachMenu = function() {
		
		if (this.dataNodes.menu == null) return;
		
		if (typeof(this.dataNodes.menu.unload) == "function") this.dataNodes.menu.unload();
		this.dataNodes.menu = null;
		delete this.dataNodes.menu;
		
		this._detachObject("menu");
		
	};
	
	dhtmlXCellObject.prototype.showMenu = function() {
		this._mtbShowHide("menu", "");
	};
	
	dhtmlXCellObject.prototype.hideMenu = function() {
		this._mtbShowHide("menu", "none");
	};
	
	dhtmlXCellObject.prototype.getAttachedMenu = function() {
		return this.dataNodes.menu;
	};
	
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// enable/disable

dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
	this._changeItemState(id, "enabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
	this._changeItemState(id, "disabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
};

// enable/disable sublevel item
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
	var t = false;
	var j = this.idPrefix + id;
	if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
		if (this.itemPull[j]["state"] != newState) {
			this.itemPull[j]["state"] = newState;
			if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
				this.idPull[j].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
			} else {
				this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
			}
			
			this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
			this._updateItemImage(id, levelType);
			// if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
			if ((this.idPrefix + this.conf.last_click == j) && (levelType != "TopLevel")) {
				this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
			}
			if (levelType == "TopLevel" && !this.conf.context) { // rebuild style.left and show nested polygons
				// this._redistribTopLevelSelection(id, "parent");
			}
		}
	}
	return t;
};


// set-get text
dhtmlXMenuObject.prototype.getItemText = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
};

dhtmlXMenuObject.prototype.setItemText = function(id, text) {
	id = this.idPrefix + id;
	if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
		this._clearAndHide();
		this.itemPull[id]["title"] = text;
		if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
			// top level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes.length; q++) {
				try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj != null) tObj.parentNode.removeChild(tObj);
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "top_level_text";
					if (this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		} else {
			// sub level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
				if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj) {
					tObj.parentNode.removeChild(tObj);
					tObj = null;
					this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
				}
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "sub_item_text";
					this.idPull[id].childNodes[1].innerHTML = "";
					this.idPull[id].childNodes[1].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		}
	}
};

// load from html
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoad) {
	
	var t = this.conf.tags.item;
	this.conf.tags.item = "div";
	
	var node = (typeof(objId)=="string"?document.getElementById(objId):objId);
	var items = this._xmlToJson(node, this.idPrefix+this.topId);
	this._initObj(items);
	
	this.conf.tags.item = t;
	
	if (clearAfterAdd) node.parentNode.removeChild(node);
	node = objOd = null;
	
	if (onload != null) {
		if (typeof(onLoad) == "function") {
			onLoad();
		} else if (typeof(window[onLoad]) == "function") {
			window[onLoad]();
		}
	}
};

// show/hide items
dhtmlXMenuObject.prototype.hideItem = function(id) {
	this._changeItemVisible(id, false);
};

dhtmlXMenuObject.prototype.showItem = function(id) {
	this._changeItemVisible(id, true);
};

dhtmlXMenuObject.prototype.isItemHidden = function(id) {
	var isHidden = null;
	if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
	return isHidden;
};

dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
	var itemId = this.idPrefix+id;
	if (this.itemPull[itemId] == null) return;
	if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
	if (this.idPull[itemId] == null) return;
	this.idPull[itemId].style.display = (visible?"":"none");
	this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
};

// userdata
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
	this.userData[this.idPrefix+id+"_"+name] = value;
};

dhtmlXMenuObject.prototype.getUserData = function(id, name) {
	return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
};

// open-mode (win/web)
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
	this.conf.mode = (mode=="win"?"win":"web");
};

// web-mode timeout
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
	this.conf.tm_sec = (!isNaN(tm)?tm:400);
};

// icons
dhtmlXMenuObject.prototype.getItemImage = function(id) {
	var imgs = new Array(null, null);
	id = this.idPrefix+id;
	if (this.itemPull[id]["type"] == "item") {
		imgs[0] = this.itemPull[id]["imgen"];
		imgs[1] = this.itemPull[id]["imgdis"];
	}
	return imgs;
};

dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
	if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
	this.itemPull[this.idPrefix+id]["imgen"] = img;
	this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
	this._updateItemImage(id, this._getItemLevelType(id));
};

dhtmlXMenuObject.prototype.clearItemImage = function(id) {
	this.setItemImage(id, "", "");
};

// visible area
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
	this.conf.v_enabled = true;
	this.conf.v.x1 = x1;
	this.conf.v.x2 = x2;
	this.conf.v.y1 = y1;
	this.conf.v.y2 = y2;
};

// tooltips
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
	id = this.idPrefix+id;
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	this.idPull[id].title = (tip.length > 0 ? tip : null);
	this.itemPull[id]["tip"] = tip;
};

dhtmlXMenuObject.prototype.getTooltip = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["tip"];
};



dhtmlXMenuObject.prototype.setTopText = function(text) {
	if (this.conf.context) return;
	if (this._topText == null) {
		this._topText = document.createElement("DIV");
		this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.rtl?"left":(this.conf.align=="left"?"right":"left"));
		this.base.appendChild(this._topText);
	}
	this._topText.innerHTML = text;
};

dhtmlXMenuObject.prototype.setAlign = function(align) {
	if (this.conf.align == align) return;
	if (align == "left" || align == "right") {
		// if (this.setRTL) this.setRTL(false);
		this.conf.align = align;
		if (this.cont) this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.align=="left"?"right":"left");
	}
};

dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	this.itemPull[this.idPrefix+itemId]["href_link"] = href;
	if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
};

dhtmlXMenuObject.prototype.clearHref = function(itemId) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	delete this.itemPull[this.idPrefix+itemId]["href_link"];
	delete this.itemPull[this.idPrefix+itemId]["href_target"];
};
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/

dhtmlXMenuObject.prototype.getCircuit = function(id) {
	var parents = new Array(id);
	while (this.getParentId(id) != this.topId) {
		id = this.getParentId(id);
		parents[parents.length] = id;
	}
	return parents.reverse();
};

// checkboxes
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["checked"];
};

dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
	if (this.itemPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["checked"] = state;
};

dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
	if (this.idPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
	this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
	try { this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
};

dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d") return;
	if (this.itemPull[this.idPrefix+id] == null) return;
	var state = this._getCheckboxState(id);
	if (this.checkEvent("onCheckboxClick")) {
		if (this.callEvent("onCheckboxClick", [id, state, this.conf.ctx_zoneid, casState])) {
			this.setCheckboxState(id, !state);
		}
	} else {
		this.setCheckboxState(id, !state);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
	this._setCheckboxState(id, state);
	this._updateCheckboxImage(id);
};

dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
	return this._getCheckboxState(id);
};

dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
	// checks
	if (this.conf.context && nextToId == this.topId) {
		// adding checkbox as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	//
	var img = "chbx_"+(state?"1":"0");
	var imgDis = img;
	//
	
	if (mode == "sibling") {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
};


// hot-keys
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {
	
	id = this.idPrefix+id;
	
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) return;
	if (this.itemPull[id]["complex"]) return;
	var t = this.itemPull[id]["type"];
	if (!(t == "item" || t == "checkbox" || t == "radio")) return;
	
	// retrieve obj
	var hkObj = null;
	try { if (this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0]; } catch(e){}
	
	if (hkey.length == 0) {
		// remove if exists
		this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
		this.itemPull[id]["hotkey"] = "";
		if (hkObj != null) hkObj.parentNode.removeChild(hkObj);
		
	} else {
		
		// add if needed or change
		this.itemPull[id]["hotkey"] = hkey;
		this.itemPull[id]["hotkey_backup"] = null;
		//
		if (hkObj == null) {
			hkObj = document.createElement("DIV");
			hkObj.className = "sub_item_hk";
			var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(hkObj);
		}
		hkObj.innerHTML = hkey;

	}
};

dhtmlXMenuObject.prototype.getHotKey = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["hotkey"];
};


// overflow control
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
	var subIds = this._getSubItemToDeselectByPolygon(polygon);
	// hide opened polygons and selected items
	for (var q=0; q<this.conf.opened_poly.length; q++) {
		if (this.conf.opened_poly[q] != polygon) this._hidePolygon(this.conf.opened_poly[q]);
	}
	for (var q=0; q<subIds.length; q++) {
		if (this.idPull[subIds[q]] != null && this.itemPull[subIds[q]]["state"] == "enabled") {
			this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Item_Normal";
		}
	}
};

// define normal/disabled arrows in polygon
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	var arrowUp = this.idPull["arrowup_"+id];
	var arrowDown = this.idPull["arrowdown_"+id];
	if (polygon.scrollTop == 0) {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp_Disabled";
	} else {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
	}
	if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
	} else {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown_Disabled";
	}
	polygon = arrowUp = arrowDown = null;
};

// add up-limit-arrow
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowup_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Over";
		this.over = true;
		that._canScrollUp = true;
		that._doScrollUp(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollUp = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp";
		window.clearTimeout(that.conf.of_utm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[0].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._addDownArrow = function(id) {
	
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowdown_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Over";
		this.over = true;
		that._canScrollDown = true;
		that._doScrollDown(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollDown = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown";
		window.clearTimeout(that.conf.of_dtm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[2].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
	var fullId = "arrowup_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
	var fullId = "arrowdown_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
	var arrow = this.idPull[fullId];
	arrow.onselectstart = null;
	arrow.oncontextmenu = null;
	arrow.onmouseover = null;
	arrow.onmouseout = null;
	arrow.onclick = null;
	if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
	arrow = null;
	this.idPull[fullId] = null;
	try { delete this.idPull[fullId]; } catch(e) {}
};

dhtmlXMenuObject.prototype._isArrowExists = function(id) {
	if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
	return false;
};

// scroll down
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollUp && polygon.scrollTop > 0) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop - this.conf.of_ustep;
		if (nextScrollTop < 0) {
			theEnd = true;
			nextScrollTop = 0;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_utm = window.setTimeout(function() {
				that._doScrollUp(id, false);
				that = null;
			}, this.conf.of_utime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollUp = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop + this.conf.of_dstep;
		if (nextScrollTop + polygon.offsetHeight >= polygon.scrollHeight) {
			theEnd = true;
			nextScrollTop = polygon.scrollHeight - polygon.offsetHeight;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_dtm = window.setTimeout(function() {
				that._doScrollDown(id, false);
				that = null;
			}, this.conf.of_dtime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollDown = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
	var count = 0;
	for (var a in this.itemPull) {
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
	}
	return count;
};

dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {
	
	// set auto overflow mode
	if (itemsNum === "auto") {
		this.conf.overflow_limit = 0;
		this.conf.auto_overflow = true;
		return;
	}
	
	// no existing limitation, now new limitation
	if (this.conf.overflow_limit == 0 && itemsNum <= 0) return;
	
	// hide menu to prevent visible changes
	this._clearAndHide();
	
	// redefine existing limitation, arrows will added automatically with showPlygon
	if (this.conf.overflow_limit >= 0 && itemsNum > 0) {
		this.conf.overflow_limit = itemsNum;
		return;
	}
	
	// remove existing limitation
	if (this.conf.overflow_limit > 0 && itemsNum <= 0) {
		for (var a in this.itemPull) {
			if (this._isArrowExists(a)) {
				var b = String(a).replace(this.idPrefix, "");
				this._removeUpArrow(b);
				this._removeDownArrow(b);
				// remove polygon's height
				this.idPull["polygon_"+a].childNodes[1].style.height = "";
			}
		}
		this.conf.overflow_limit = 0;
		return;
	}
};


// radiobuttons
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
	try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
	return imgObj;
};

dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
	// if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
	var imgObj = this._getRadioImgObj(id);
	if (imgObj != null) {
		// fix, added in 0.4
		var rObj = this.itemPull[this.idPrefix+id];
		rObj["checked"] = state;
		rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
		rObj["imgdis"] = rObj["imgen"];
		imgObj.className = "sub_icon "+rObj["imgen"];
	}
};

dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
	// deselect all from the same group
	var group = this.itemPull[this.idPrefix+id]["group"];
	if (this.checkEvent("onRadioClick")) {
		if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.conf.ctx_zoneid, casState])) {
			this.setRadioChecked(group, id);
		}
	} else {
		this.setRadioChecked(group, id);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
	var id = null;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		var imgObj = this._getRadioImgObj(itemId);
		if (imgObj != null) {
			var checked = (imgObj.className).match(/rdbt_1$/gi);
			if (checked != null) id = itemId;
		}
	}
	return id;
};

dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
	if (this.radio[group] == null) return;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		this._setRadioState(itemId, (itemId==id));
	}
}

dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
	// radiobutton
	if (this.conf.context && nextToId == this.topId) {
		// adding radiobutton as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var img = "rdbt_"+(state?"1":"0");
	var imgDis = img;
	//
	if (mode == "sibling") {
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
	//
	var gr = (group!=null?group:this._genStr(24));
	this.itemPull[id]["group"] = gr;
	//
	if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
	this.radio[gr][this.radio[gr].length] = id;
	//
	if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
};


// serialize
dhtmlXMenuObject.prototype.serialize = function() {
	var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
	return xml;
};

dhtmlXMenuObject.prototype._readLevel = function(parentId) {
	var xml = "";
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == parentId) {
			var imgEn = "";
			var imgDis = "";
			var hotKey = "";
			var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
			var itemType = "";
			var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
			var itemState = "";
			if (this.itemPull[a]["type"] == "item") {
				if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
				if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
				if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
			}
			if (this.itemPull[a]["type"] == "separator") {
				itemType = ' type="separator"';
			} else {
				if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
			}
			if (this.itemPull[a]["type"] == "checkbox") {
				itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			if (this.itemPull[a]["type"] == "radio") {
				itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
			xml += hotKey;
			if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
			xml += "</item>";
		}
	}
	return xml;
};


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// effects: opacity, slide
dhtmlXMenuObject.prototype.enableEffect = function(name, maxOpacity, effectSpeed) {
	
	this._menuEffect = (name=="opacity"||name=="slide"||name=="slide+"?name:false);
	
	this._pOpStyleIE = (navigator.userAgent.search(/MSIE\s[678]\.0/gi)>=0); // opacity was added in IE9
	
	for (var a in this.idPull) {
		if (a.search(/polygon/) === 0) {
			this._pOpacityApply(a,(this._pOpStyleIE?100:1));
			this.idPull[a].style.height = "";
		}
		
	}
	
	// opacity max value
	this._pOpMax = (typeof(maxOpacity)=="undefined"?100:maxOpacity)/(this._pOpStyleIE?1:100);
	
	// opacity css styles
	this._pOpStyleName = (this._pOpStyleIE?"filter":"opacity");
	this._pOpStyleValue = (this._pOpStyleIE?"progid:DXImageTransform.Microsoft.Alpha(Opacity=#)":"#");
	
	
	// count of steps to open full polygon
	this._pSlSteps = (this._pOpStyleIE?10:20);
	
	// timeout to open polygon
	this._pSlTMTimeMax = effectSpeed||50;
	
};

// extended show
dhtmlXMenuObject.prototype._showPolygonEffect = function(pId) {
	this._pShowHide(pId, true);
};

// extended hide
dhtmlXMenuObject.prototype._hidePolygonEffect = function(pId) {
	this._pShowHide(pId, false);
};

// apply opacity css
dhtmlXMenuObject.prototype._pOpacityApply = function(pId, val) {
	this.idPull[pId].style[this._pOpStyleName] = String(this._pOpStyleValue).replace("#", val||this.idPull[pId]._op);
};

dhtmlXMenuObject.prototype._pShowHide = function(pId, mode) {
	
	if (!this.idPull) return;
	
	// check if mode in progress
	if (this.idPull[pId]._tmShow != null) {
		if ((this.idPull[pId]._step_h > 0 && mode == true) || (this.idPull[pId]._step_h < 0 && mode == false)) return;
		window.clearTimeout(this.idPull[pId]._tmShow);
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._max_h = null;
	}
	
	if (mode == false && (this.idPull[pId].style.visibility == "hidden" || this.idPull[pId].style.display == "none")) return;
	
	if (mode == true && this.idPull[pId].style.display == "none") {
		this.idPull[pId].style.visibility = "hidden";
		this.idPull[pId].style.display = "";
	}
	
	// init values or show-hide revert
	if (this.idPull[pId]._max_h == null) {
		
		this.idPull[pId]._max_h = parseInt(this.idPull[pId].offsetHeight);
		this.idPull[pId]._h = (mode==true?0:this.idPull[pId]._max_h);
		this.idPull[pId]._step_h = Math.round(this.idPull[pId]._max_h/this._pSlSteps)*(mode==true?1:-1);
		if (this.idPull[pId]._step_h == 0) return;
		this.idPull[pId]._step_tm = Math.round(this._pSlTMTimeMax/this._pSlSteps);
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId].op_tm = this.idPull[pId]._step_tm;
			this.idPull[pId].op_step = (this._pOpMax/this._pSlSteps)*(mode==true?1:-1);
			if (this._pOpStyleIE) this.idPull[pId].op_step = Math.round(this.idPull[pId].op_step);
			this.idPull[pId]._op = (mode==true?0:this._pOpMax);
			this._pOpacityApply(pId);
		} else {
			this.idPull[pId]._op = (this._pOpStyleIE?100:1);
			this._pOpacityApply(pId);
		}
		
		// show first time
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "0px";
		this.idPull[pId].style.visibility = "visible";
		
	}
	
	// run cycle
	this._pEffectSet(pId, this.idPull[pId]._h+this.idPull[pId]._step_h);
	
};

dhtmlXMenuObject.prototype._pEffectSet = function(pId, t) {
	
	if (!this.idPull) return;
	
	if (this.idPull[pId]._tmShow) window.clearTimeout(this.idPull[pId]._tmShow);
	
	// check and apply next step
	this.idPull[pId]._h = Math.max(0,Math.min(t,this.idPull[pId]._max_h));
	if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = this.idPull[pId]._h+"px";
	
	t += this.idPull[pId]._step_h;
	
	if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
		this.idPull[pId]._op = Math.max(0,Math.min(this._pOpMax,this.idPull[pId]._op+this.idPull[pId].op_step));
		this._pOpacityApply(pId);
	}
	
	if ((this.idPull[pId]._step_h > 0 && t <= this.idPull[pId]._max_h) || (this.idPull[pId]._step_h < 0 && t >= 0)) {
		// continue
		var k = this;
		this.idPull[pId]._tmShow = window.setTimeout(function(){k._pEffectSet(pId,t);}, this.idPull[pId]._step_tm);
	} else {
		
		// clear height
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "";
		
		// hide completed
		if (this.idPull[pId]._step_h < 0) this.idPull[pId].style.visibility = "hidden";
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId]._op = (this.idPull[pId]._step_h<0?(this._pOpStyleIE?100:1):this._pOpMax);
			this._pOpacityApply(pId);
		}
		
		// clear values
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._h = null;
		this.idPull[pId]._max_h = null;
		///this.idPull[pId]._step_h = null;
		this.idPull[pId]._step_tm = null;
	}
	
};



/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXToolbarObject(base, skin) {
	
	var main_self = this;
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtoolbar")||"material"),
		align: "left",
		align_autostart: "left",
		icons_path: "",
		icons_css: false,
		iconSize: 18,
		sel_ofs_x: 0,
		sel_ofs_y: 0,
		xml_autoload: null,
		items_autoload: null,
		cssShadow: (dhx4.isIE6||dhx4.isIE7||dhx4.isIE8?"":" dhx_toolbar_shadow") // for material
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.icons_size != null) this.conf.icons_size_autoload = base.icons_size;
		if (base.iconset != null) this.conf.icons_css = (base.iconset == "awesome");
		if (base.json != null) this.conf.json_autoload = base.json;
		if (base.xml != null) this.conf.xml_autoload = base.xml;
		if (base.onload != null) this.conf.onload_autoload = base.onload;
		if (base.onclick != null || base.onClick != null) this.conf.auto_onclick = (base.onclick|| base.onClick);
		if (base.items != null) this.conf.items_autoload = base.items;
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.align != null) this.conf.align_autostart = base.align;
		base = base.parent;
	}
	
	this.cont = (typeof(base)!="object")?document.getElementById(base):base;
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	
	base = null;
	
	this.cont.dir = "ltr";
	
	this.base = document.createElement("DIV");
	this.base.className = "dhxtoolbar_float_left";
	this.cont.appendChild(this.base);
	
	this.cont.ontouchstart = function(e){
		e = e||event;
		if ((String(e.target.tagName||"").toLowerCase()=="input")) return true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	this.setSkin(this.conf.skin);
	
	this.objPull = {};
	this.anyUsed = null;
	
	/* random prefix */
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	this.rootTypes = new Array("button", "buttonSelect", "buttonTwoState", "separator", "label", "slider", "text", "buttonInput");
	this.idPrefix = this._genStr(12);
	//
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", "toolbar", {struct:true});
	window.dhx4._eventable(this);
	//
	// return obj if exists by tagname
	this._getObj = function(obj, tag) {
		var targ = null;
		for (var q=0; q<obj.childNodes.length; q++) {
			if (obj.childNodes[q].tagName != null) {
				if (String(obj.childNodes[q].tagName).toLowerCase() == String(tag).toLowerCase()) targ = obj.childNodes[q];
			}
		}
		return targ;
	}
	// create and return image object
	this._addImgObj = function(obj) {
		var imgObj = document.createElement(this.conf.icons_css==true?"I":"IMG");
		if (obj.childNodes.length > 0) obj.insertBefore(imgObj, obj.childNodes[0]); else obj.appendChild(imgObj);
		return imgObj;
	}
	// set/clear item image/imagedis
	this._setItemImage = function(item, url, dis) {
		if (dis == true) item.imgEn = url; else item.imgDis = url;
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		if (this.conf.icons_css == true) {
			var imgObj = this._getObj(item.obj, "i");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.className = this.conf.icons_path+url;
		} else {
			var imgObj = this._getObj(item.obj, "img");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.src = this.conf.icons_path+url;
		}
	}
	this._clearItemImage = function(item, dis) {
		if (dis == true) item.imgEn = ""; else item.imgDis = "";
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
	}
	// set/get item text
	this._setItemText = function(item, text) {
		var txtObj = this._getObj(item.obj, "div");
		if (text == null || text.length == 0) {
			if (txtObj != null) txtObj.parentNode.removeChild(txtObj);
			return;
		}
		if (txtObj == null) {
			txtObj = document.createElement("DIV");
			txtObj.className = "dhxtoolbar_text";
			item.obj.appendChild(txtObj);
		}
		txtObj.innerHTML = text;
	}
	this._getItemText = function(item) {
		var txtObj = this._getObj(item.obj, "div");
		if (txtObj != null) return txtObj.innerHTML;
		return "";
	}
	
	// enable/disable btn
	this._enableItem = function(item) {
		if (item.state) return;
		item.state = true;
		if (this.objPull[item.id]["type"] == "buttonTwoState" && this.objPull[item.id]["obj"]["pressed"] == true) {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
			item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
		} else {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			item.obj.renderAs = item.obj.className; 
		}
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgEn != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgEn;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
	}
	this._disableItem = function(item) {
		if (!item.state) return;
		item.state = false;
		item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.objPull[item.id]["type"]=="buttonTwoState"&&item.obj.pressed?"pres_":"")+"dis";
		item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgDis != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgDis;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
		// if (this.objPull[item.id]["type"] == "buttonTwoState") this.objPull[item.id]["obj"]["pressed"] = false;
		// hide opened polygon if any
		if (item.polygon != null) {
			if (item.polygon.style.display != "none") {
				window.dhx4.zim.clear(item.polygon._idd);
				item.polygon.style.display = "none";
				if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
				// fix border
				if (this.conf.skin == "dhx_terrace") this._improveTerraceButtonSelect(item.id, true);
				// event
				this.callEvent("onButtonSelectHide", [item.obj.idd]);
			}
		}
		this.anyUsed = null;
	}
	
	this.clearAll = function() {
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
	}
	
	
	//
	this._doOnClick = function(e) {
		if (main_self && main_self.forEachItem) {
			main_self.forEachItem(function(itemId){
				if (main_self.objPull[main_self.idPrefix+itemId].type == "buttonSelect") {
					// hide any opened buttonSelect's polygons, clear selection if any
					var item = main_self.objPull[main_self.idPrefix+itemId];
					if (item.arw._skip === true) {
						item.arw._skip = false;
					} else if (item.polygon.style.display != "none") {
						item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
						item.obj.className = item.obj.renderAs;
						item.arw.className = String(item.obj.renderAs).replace("btn","arw");
						main_self.anyUsed = null;
						main_self.conf.touch_id = null;
						window.dhx4.zim.clear(item.polygon._idd);
						item.polygon.style.display = "none";
						if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
						// fix border
						if (main_self.conf.skin == "dhx_terrace") main_self._improveTerraceButtonSelect(item.id, true);
						// event
						main_self.callEvent("onButtonSelectHide", [item.obj.idd]);
					}
				}
			});
		}
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("mousedown", this._doOnClick, false);
		window.addEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.attachEvent("onmousedown", this._doOnClick);
	}
	
	if (this.conf.icons_size_autoload != null) {
		this.setIconSize(this.conf.icons_size_autoload);
		this.conf.icons_size_autoload = null;
	}
	
	if (this.conf.items_autoload != null) {
		this.loadStruct(this.conf.items_autoload, this.conf.onload_autoload);
		this.conf.items_autoload = null;
	} else if (this.conf.json_autoload != null) {
		this.loadStruct(this.conf.json_autoload, this.conf.onload_autoload);
		this.conf.json_autoload = null;
	} else if (this.conf.xml_autoload != null) {
		this.loadStruct(this.conf.xml_autoload, this.conf.onload_autoload);
		this.conf.xml_autoload = null;
	}
	
	if (this.conf.align_autostart != this.conf.align) {
		this.setAlign(this.conf.align_autostart);
		this.conf.align_autostart = null;
	}
	
	if (typeof(this.conf.auto_onclick) == "function") {
		this.attachEvent("onClick", this.conf.auto_onclick);
	} else if (typeof(this.conf.auto_onclick) == "string" && typeof(window[this.conf.auto_onclick]) == "function") {
		this.attachEvent("onClick", window[this.conf.auto_onclick]);
	}
	
	//
	return this;
}
dhtmlXToolbarObject.prototype.addSpacer = function(nextToId) {
	var nti = this.idPrefix+nextToId;
	if (this._spacer != null) {
		// spacer already at specified position
		if (this._spacer.idd == nextToId) return;
		// if current spacer contain nextToId item
		// move all items from first to nextToId to this.base
		if (this._spacer == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			while (doMove) {
				var idd = this._spacer.childNodes[0].idd;
				this.base.appendChild(this._spacer.childNodes[0]);
				if (idd == nextToId || this._spacer.childNodes.length == 0) {
					if (this.objPull[nti].arw != null) this.base.appendChild(this.objPull[nti].arw);
					doMove = false;
				}
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		// if this.base contain nextToId item, move (insertBefore[0])
		if (this.base == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			var chArw = (this.objPull[nti].arw!=null);
			while (doMove) {
				var q = this.base.childNodes.length-1;
				if (chArw == true) if (this.base.childNodes[q] == this.objPull[nti].arw) doMove = false;
				if (this.base.childNodes[q].idd == nextToId) doMove = false;
				if (doMove) { if (this._spacer.childNodes.length > 0) this._spacer.insertBefore(this.base.childNodes[q], this._spacer.childNodes[0]); else this._spacer.appendChild(this.base.childNodes[q]); }
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		
	} else {
		var np = null;
		for (var q=0; q<this.base.childNodes.length; q++) {
			if (this.base.childNodes[q] == this.objPull[this.idPrefix+nextToId].obj) {
				np = q;
				if (this.objPull[this.idPrefix+nextToId].arw != null) np = q+1;
			}
		}
		if (np != null) {
			this._spacer = document.createElement("DIV");
			this._spacer.className = (this.conf.align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right");
			this._spacer.dir = "ltr";
			this._spacer.idd = nextToId;
			while (this.base.childNodes.length > np+1) this._spacer.appendChild(this.base.childNodes[np+1]);
			this.cont.appendChild(this._spacer);
			this._fixSpacer();
		}
	}
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype.removeSpacer = function() {
	if (!this._spacer) return;
	while (this._spacer.childNodes.length > 0) this.base.appendChild(this._spacer.childNodes[0]);
	this._spacer.parentNode.removeChild(this._spacer);
	this._spacer = null;
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype._fixSpacer = function() {
	// IE icons mixing fix
	if (typeof(window.addEventListener) == "undefined" && this._spacer != null) {
		this._spacer.style.borderLeft = "1px solid #a4bed4";
		var k = this._spacer;
		window.setTimeout(function(){k.style.borderLeft="0px solid #a4bed4";k=null;},1);
	}
}

dhtmlXToolbarObject.prototype.getType = function(itemId) {
	var parentId = this.getParentId(itemId);
	if (parentId != null) {
		var typeExt = null;
		var itemData = this.objPull[this.idPrefix+parentId]._listOptions[itemId];
		if (itemData != null) if (itemData.sep != null) typeExt = "buttonSelectSeparator"; else typeExt = "buttonSelectButton";
		return typeExt;
	} else {
		if (this.objPull[this.idPrefix+itemId] == null) return null;
		return this.objPull[this.idPrefix+itemId]["type"];
	}
}

dhtmlXToolbarObject.prototype.getTypeExt = function(itemId) {
	var type = this.getType(itemId);
	if (type == "buttonSelectButton" || type == "buttonSelectSeparator") {
		if (type == "buttonSelectButton") type = "button"; else type = "separator";
		return type;
	}
	return null;
}
dhtmlXToolbarObject.prototype.inArray = function(array, value) {
	for (var q=0; q<array.length; q++) { if (array[q]==value) return true; }
	return false;
}
dhtmlXToolbarObject.prototype.getParentId = function(listId) {
	var parentId = null;
	for (var a in this.objPull) if (this.objPull[a]._listOptions) for (var b in this.objPull[a]._listOptions) if (b == listId) parentId = String(a).replace(this.idPrefix,"");
	return parentId;
}
/* adding items */
dhtmlXToolbarObject.prototype._addItem = function(itemData, pos) {
	if (typeof(itemData.text) == "string") {
		itemData.text = window.dhx4.trim(itemData.text);
		if (itemData.text.length == 0) itemData.text = null;
	}
	this._addItemToStorage(itemData, pos);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}

dhtmlXToolbarObject.prototype.addButton = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"button", text:text, img:imgEnabled, imgdis:imgDisabled}, pos);
}

dhtmlXToolbarObject.prototype.addText = function(id, pos, text) {
	this._addItem({id:id,type:"text",text:text}, pos);
}

dhtmlXToolbarObject.prototype.addButtonSelect = function(id, pos, text, opts, imgEnabled, imgDisabled, renderSelect, openAll, maxOpen, mode) { 
	var options = [];
	for (var q=0; q<opts.length; q++) {
		var u = {};
		if (opts[q] instanceof Array) {
			u.id = opts[q][0];
			u.type = (opts[q][1]=="obj"?"button":"separator");
			u.text = (opts[q][2]||null);
			u.img = (opts[q][3]||null);
		} else if (opts[q] instanceof Object && opts[q] != null && typeof(opts[q].id) != "undefined" && typeof(opts[q].type) != "undefined") {
			u.id = opts[q].id;
			u.type = (opts[q].type=="obj"?"button":"separator");
			u.text = opts[q].text;
			u.img = opts[q].img;
		}
		options.push(u);
	}
	this._addItem({id:id, type:"buttonSelect", text:text, img:imgEnabled, imgdis:imgDisabled, renderSelect:renderSelect, openAll:openAll, options:options, maxOpen:maxOpen, mode:mode}, pos);
}

dhtmlXToolbarObject.prototype.addButtonTwoState = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"buttonTwoState", img:imgEnabled, imgdis:imgDisabled, text:text}, pos);
}

dhtmlXToolbarObject.prototype.addSeparator = function(id, pos) {
	this._addItem({id:id,type:"separator"}, pos);
}

dhtmlXToolbarObject.prototype.addSlider = function(id, pos, len, valueMin, valueMax, valueNow, textMin, textMax, tip) {
	this._addItem({id:id, type:"slider", length:len, valueMin:valueMin, valueMax:valueMax, valueNow:valueNow, textMin:textMin, textMax:textMax, toolTip:tip}, pos);
}

dhtmlXToolbarObject.prototype.addInput = function(id, pos, value, width) {
	this._addItem({id:id,type:"buttonInput",value:value,width:width}, pos);
}

dhtmlXToolbarObject.prototype.forEachItem = function(handler) {
	for (var a in this.objPull) {
		if (this.inArray(this.rootTypes, this.objPull[a]["type"])) {
			handler(this.objPull[a]["id"].replace(this.idPrefix,""));
		}
	}
};
(function(){
	var list="isVisible,enableItem,disableItem,isEnabled,setItemText,getItemText,setItemToolTip,getItemToolTip,getInput,setItemImage,setItemImageDis,clearItemImage,clearItemImageDis,setItemState,getItemState,setItemToolTipTemplate,getItemToolTipTemplate,setValue,getValue,setMinValue,getMinValue,setMaxValue,getMaxValue,setWidth,getWidth,setMaxOpen".split(",")
	var ret=[false,"","",false,"","","","","","","","","",false,"","","",null,"",[null,null],"",[null,null],"",null]
	var functor=function(name,res){
		return function(itemId,a,b){
			itemId = this.idPrefix+itemId;
			if (this.objPull[itemId][name] != null) return this.objPull[itemId][name].call(this.objPull[itemId],a,b); else return res;
		};
	}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		var res=ret[i];
		dhtmlXToolbarObject.prototype[name] = functor(name,res);
	}
})();

dhtmlXToolbarObject.prototype.showItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].showItem != null) {
		this.objPull[itemId].showItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}

dhtmlXToolbarObject.prototype.hideItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].hideItem != null) {
		this.objPull[itemId].hideItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}
dhtmlXToolbarObject.prototype.getPosition = function(itemId) {
	return this._getPosition(itemId);
}
dhtmlXToolbarObject.prototype._getPosition = function(id, getRealPosition) {
	
	if (this.objPull[this.idPrefix+id] == null) return null;
	
	var pos = null;
	var w = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q].idd != null) {
			if (this.base.childNodes[q].idd == id) pos = w;
			w++;
		}
	}
	if (!pos && this._spacer != null) {
		for (var q=0; q<this._spacer.childNodes.length; q++) {
			if (this._spacer.childNodes[q].idd != null) {
				if (this._spacer.childNodes[q].idd == id) pos = w;
				w++;
			}
		}
	}
	return pos;
}

dhtmlXToolbarObject.prototype.setPosition = function(itemId, pos) {
	this._setPosition(itemId, pos);
}

dhtmlXToolbarObject.prototype._setPosition = function(id, pos) {
	
	if (this.objPull[this.idPrefix+id] == null) return;
	
	var spacerId = null;
	if (this._spacer) {
		spacerId = this._spacer.idd;
		this.removeSpacer();
	}
	
	if (isNaN(pos)) pos = this.base.childNodes.length;
	if (pos < 0) pos = 0;
	
	var item = this.objPull[this.idPrefix+id];
	this.base.removeChild(item.obj);
	if (item.arw) this.base.removeChild(item.arw);
	
	var newPos = this._getIdByPosition(pos, true);
	
	if (newPos[0] == null) {
		this.base.appendChild(item.obj);
		if (item.arw) this.base.appendChild(item.arw);
	} else {
		this.base.insertBefore(item.obj, this.base.childNodes[newPos[1]]);
		if (item.arw) this.base.insertBefore(item.arw, this.base.childNodes[newPos[1]+1]);
	}
	if (spacerId != null) this.addSpacer(spacerId);
	
}
dhtmlXToolbarObject.prototype._getIdByPosition = function(pos, retRealPos) {
	
	var id = null;
	var w = 0;
	var realPos = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q]["idd"] != null && id == null) {
			if ((w++) == pos) id = this.base.childNodes[q]["idd"];
		}
		if (id == null) realPos++;
	}
	realPos = (id==null?null:realPos);
	return (retRealPos==true?new Array(id, realPos):id);
}

dhtmlXToolbarObject.prototype.removeItem = function(itemId) {
	this._removeItem(itemId);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._removeItem = function(itemId) {
	
	var t = this.getType(itemId);
	
	itemId = this.idPrefix+itemId;
	var p = this.objPull[itemId];
	
	
	if ({button:1, buttonTwoState:1}[t] == 1) {
		
		if (window.dhx4.isIE) p.obj.onselectstart = null;
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p) p[a] = null;
		
	}
	
	if (t == "buttonSelect") {
		
		for (var a in p._listOptions) this.removeListOption(itemId, a);
		p._listOptions = null;
		
		if (p.polygon._ie6cover) {
			document.body.removeChild(p.polygon._ie6cover);
			p.polygon._ie6cover = null;
		}
		
		p.p_tbl.removeChild(p.p_tbody);
		p.polygon.removeChild(p.p_tbl);
		p.polygon.onselectstart = null;
		document.body.removeChild(p.polygon);
		
		if (window.dhx4.isIE) {
			p.obj.onselectstart = null;
			p.arw.onselectstart = null;
		}
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		this._evs.clear.apply(p, [p.arw.evs, p.arw]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p.arw) if (typeof(p.arw[a]) == "function") p.arw[a] = null;
		p.arw.parentNode.removeChild(p.arw);
		p.arw = null;
		
		for (var a in p) p[a] = null;
		
		
	}
	
	if (t == "buttonInput") {
		
		p.obj.childNodes[0].onkeydown = null;
		p.obj.removeChild(p.obj.childNodes[0]);
		
		p.obj.w = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.setWidth = null;
		p.getWidth = null;
		p.setValue = null;
		p.getValue = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	if (t == "slider") {
		
		if (window.dhx4.isIPad) {
			document.removeEventListener("touchmove", pen._doOnMouseMoveStart, false);
			document.removeEventListener("touchend", pen._doOnMouseMoveEnd, false);
		} else {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousemove", p.pen._doOnMouseMoveStart, false);
				window.removeEventListener("mouseup", p.pen._doOnMouseMoveEnd, false);
			} else {
				document.body.detachEvent("onmousemove", p.pen._doOnMouseMoveStart);
				document.body.detachEvent("onmouseup", p.pen._doOnMouseMoveEnd);
			}
		}
		
		p.pen.allowMove = null;
		p.pen.initXY = null;
		p.pen.maxX = null;
		p.pen.minX = null;
		p.pen.nowX = null;
		p.pen.newNowX = null;
		p.pen.valueMax = null;
		p.pen.valueMin = null;
		p.pen.valueNow = null;
		
		p.pen._definePos = null;
		p.pen._detectLimits = null;
		p.pen._doOnMouseMoveStart = null;
		p.pen._doOnMouseMoveEnd = null;
		p.pen.onmousedown = null;
		
		p.obj.removeChild(p.pen);
		p.pen = null;
		
		p.label.tip = null;
		document.body.removeChild(p.label);
		p.label = null;
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		while (p.obj.childNodes.length > 0) p.obj.removeChild(p.obj.childNodes[0]);
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		p.state = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.setItemToolTipTemplate = null;
		p.getItemToolTipTemplate = null;
		p.setMaxValue = null;
		p.setMinValue = null;
		p.getMaxValue = null;
		p.getMinValue = null;
		p.setValue = null;
		p.getValue = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "separator") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "text") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setWidth = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	t = null;
	p = null;
	this.objPull[this.idPrefix+itemId] = null;
	delete this.objPull[this.idPrefix+itemId];
	
	
};
//#tool_list:06062008{
(function(){
	var list="addListOption,removeListOption,showListOption,hideListOption,isListOptionVisible,enableListOption,disableListOption,isListOptionEnabled,setListOptionPosition,getListOptionPosition,setListOptionText,getListOptionText,setListOptionToolTip,getListOptionToolTip,setListOptionImage,getListOptionImage,clearListOptionImage,forEachListOption,getAllListOptions,setListOptionSelected,getListOptionSelected".split(",")
	var functor = function(name){
				return function(parentId,a,b,c,d,e){
				parentId = this.idPrefix+parentId;
				if (this.objPull[parentId] == null) return;
				if (this.objPull[parentId]["type"] != "buttonSelect") return;
				return this.objPull[parentId][name].call(this.objPull[parentId],a,b,c,d,e);
			}
		}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		dhtmlXToolbarObject.prototype[name]=functor(name)
	}
})();

dhtmlXToolbarObject.prototype._rtlParseBtn = function(t1, t2) {
	return t1+t2;
}
/*****************************************************************************************************************************************************************
	object: separator
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._separatorObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_sep";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	// add object
	that.base.appendChild(this.obj);
	
	// functions
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: text
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._textObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_text";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	this.obj.innerHTML = (data.text||"");
	//
	that.base.appendChild(this.obj);
	//
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		this.obj.innerHTML = text;
	}
	this.getItemText = function() {
		return this.obj.innerHTML;
	}
	this.setWidth = function(width) {
		this.obj.style.width = width+"px";
	}
	this.setItemToolTip = function(t) {
		this.obj.title = t;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: button
******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonObject = function(that, id, data) {
	
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	//
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	//
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""), (data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.pressed == true || t.obj.over == true) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = t.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
		t.obj.pressed = true;
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
		if (t.state == false || t.obj.pressed == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(t.obj.over?"over":"def");
		t.obj.pressed = false;
		if (t.obj.extAction){window.setTimeout(function(){try{if(t&&t.obj)window[t.obj.extAction](t.id);}catch(e){}},1);}
		that.callEvent("onClick", [t.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	return this;
}

/******************************************************************************************************************************************************************
	object: buttonSelect
*******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonSelectObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	this.mode = (data.mode||"button"); // button, select
	if (this.mode == "select") {
		this.openAll = true;
		this.renderSelect = false;
		if (!data.text||data.text.length==0) data.text = "&nbsp;"
	} else {
		this.openAll = (window.dhx4.s2b(data.openAll)==true);
		this.renderSelect = (data.renderSelect == null ? true : window.dhx4.s2b(data.renderSelect));
	}
	this.maxOpen = (!isNaN(data.maxOpen?data.maxOpen:"")?data.maxOpen:null);
	
	this._maxOpenTest = function() {
		if (!isNaN(this.maxOpen)) {
			if (!that._sbw) {
				var t = document.createElement("DIV");
				t.className = "dhxtoolbar_maxopen_test";
				document.body.appendChild(t);
				var k = document.createElement("DIV");
				k.className = "dhxtoolbar_maxopen_test2";
				t.appendChild(k);
				that._sbw = t.offsetWidth-k.offsetWidth;
				t.removeChild(k);
				k = null;
				document.body.removeChild(t);
				t = null;
			}
		}
	}
	this._maxOpenTest();
	
	//
	this.obj = document.createElement("DIV");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	
	this.callEvent = false;
	
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	this.arw = document.createElement("DIV");
	this.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.arw.style.display = this.obj.style.display;
	this.arw.innerHTML = "<div class='arwimg'>&nbsp;</div>";
	
	this.arw.title = this.obj.title;
	this.arw.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	that.base.appendChild(this.arw);
	
	var self = this;
	
	if (window.dhx4.isIE) {
		this.arw.onselectstart = this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (self.state == false || self.obj.over == true || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) == null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
		}
		self.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (self.state == false || that.anyUsed == self.obj.idd || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
		}
		self.obj.over = self.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != self.id) return; // multiple touches?
			that.conf.touch_id = self.id;
		}
		if (self.state == false) return;
		
		if (that.anyUsed == self.obj.idd) {
			// hide polygon
			if (self.obj.over == true) {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
			} else {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			}
			self._hidePoly(true);
			that.anyUsed = null;
		} else {
			// show polygon
			var node = (e.target||e.srcElement);
			if (self.openAll == true || node == self.arw || node.parentNode == self.arw) {
				if (e.type == "touchstart") self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				self.arw._skip = true;
				self._showPoly(true);
				that.anyUsed = self.obj.idd;
			} else {
				if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) {
					self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
					self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				}
				self.obj.pressed = true;
			}
		}
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (self.polygon.style.display == "") return;
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == self.id) that.conf.touch_id = null;
		}
		if (self.state == false || self.obj.pressed == false) return;
		if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(self.obj.over?"over":"def");
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(self.obj.over?"over":"def");
		}
		// event
		if (this.extAction) {var k = this;window.setTimeout(function(){try{window[k.extAction](id);}catch(e){};k=null;},1);}
		that.callEvent("onClick", [self.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.arw.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown"
	};
	that._evs.add.apply(this, [this.arw.evs, this.arw]);
	
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	this._showPoly = function(callEvent) {
		// hide other if already opened
		if (that.anyUsed != null) {
			if (that.objPull[that.idPrefix+that.anyUsed].type == "buttonSelect") {
				var item = that.objPull[that.idPrefix+that.anyUsed];
				if (item.polygon.style.display != "none") {
					item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
					item.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
					item.obj.over = false;
					window.dhx4.zim.clear(item.polygon._idd);
					item.polygon.style.display = "none";
					if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
					// fix border
					if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(item.id, true);
					// event
					that.callEvent("onButtonSelectHide", [item.obj.idd]);
				}
			}
		}
		// show
		this.polygon.style.top = "0px";
		this.polygon.style.visibility = "hidden";
		this.polygon.style.zIndex = window.dhx4.zim.reserve(this.polygon._idd);
		this.polygon.style.display = "";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, false);
		// check maxOpen
		this._fixMaxOpenHeight(this.maxOpen||null);
		// detect overlay by Y axis
		that._autoDetectVisibleArea();
		// calculate top position
		var newTop = window.dhx4.absTop(this.obj)+this.obj.offsetHeight+that.conf.sel_ofs_y;
		var newH = this.polygon.offsetHeight;
		if (newTop + newH > that.tY2) {
			// if maxOpen mode enabled, check if at bottom at least one item can be shown
			// and show it, if no space - show on top. in maxOpen mode not enabled, show at top
			var k0 = (this.maxOpen!=null?Math.floor((that.tY2-newTop)/22):0); // k0 = count of items that can be visible
			if (k0 >= 1) {
				this._fixMaxOpenHeight(k0);
			} else {
				newTop = window.dhx4.absTop(this.obj)-newH-that.conf.sel_ofs_y;
				if (newTop < 0) newTop = 0;
			}
		}
		this.polygon.style.top = newTop+"px";
		// calculate left position
		if (that.rtl) {
			this.polygon.style.left = window.dhx4.absLeft(this.obj)+this.obj.offsetWidth-this.polygon.offsetWidth+that.conf.sel_ofs_x+"px";
		} else {
			var x1 = document.body.scrollLeft;
			var x2 = x1+(window.innerWidth||document.body.clientWidth);
			var newLeft = window.dhx4.absLeft(this.obj)+that.conf.sel_ofs_x;
			if (newLeft+this.polygon.offsetWidth > x2) newLeft = window.dhx4.absLeft(this.arw)+this.arw.offsetWidth-this.polygon.offsetWidth;
			this.polygon.style.left = Math.max(newLeft,5)+"px";
		}
		this.polygon.style.visibility = "visible";
		// show IE6 cover if needed
		if (this.polygon._ie6cover) {
			this.polygon._ie6cover.style.left = this.polygon.style.left;
			this.polygon._ie6cover.style.top = this.polygon.style.top;
			this.polygon._ie6cover.style.width = this.polygon.offsetWidth+"px";
			this.polygon._ie6cover.style.height = this.polygon.offsetHeight+"px";
			this.polygon._ie6cover.style.display = "";
		}
		// event, added in 4.5
		if (callEvent) that.callEvent("onButtonSelectShow", [this.obj.idd]);
	}
	
	this._hidePoly = function(callEvent) {
		window.dhx4.zim.clear(this.polygon._idd);
		this.polygon.style.display = "none";
		if (this.polygon._ie6cover) this.polygon._ie6cover.style.display = "none";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, true);
		if (callEvent) that.callEvent("onButtonSelectHide", [this.obj.idd]); // event, added in 4.5
		// reset touch event if any
		that.conf.touch_id = null;
	}
	
	this.obj.iddPrefix = that.idPrefix;
	this._listOptions = {};
	
	this._fixMaxOpenHeight = function(maxOpen) {
		var h = "auto";
		var h0 = false;
		if (maxOpen !== null) {
			var t = 0;
			for (var a in this._listOptions) t++;
			if (t > maxOpen) {
				this._ph = 22*maxOpen;
				h = this._ph+"px";
			} else {
				h0 = true;
			}
		}
		this.polygon.style.width = "auto";
		this.polygon.style.height = "auto";
		if (!h0 && self.maxOpen != null) {
			this.polygon.style.width = this.p_tbl.offsetWidth+that._sbw+"px";
			this.polygon.style.height = h;
		}
	}
	
	// inner objects: separator
	this._separatorButtonSelectObject = function(id, data, pos) {
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.className = "tr_sep";
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td = document.createElement("TD");
		this.obj.td.colSpan = "2";
		this.obj.td.className = "td_btn_sep";
		this.obj.td.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.tr.appendChild(this.obj.td);
		
		this.obj.sep = document.createElement("DIV");
		this.obj.sep.className = "btn_sep";
		this.obj.sep.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td.appendChild(this.obj.sep);
		
		self._listOptions[id] = this.obj;
		return this;
	}
	// inner objects: button
	this._buttonButtonSelectObject = function(id, data, pos) {
		
		var en = true;
		if (typeof(data.enabled) != "undefined") {
			en = window.dhx4.s2b(data.enabled);
		} else if (typeof(data.disabled) != "undefined") {
			en = window.dhx4.s2b(data.disabled);
		}
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.en = en;
		this.obj.tr.extAction = (data.action||null);
		this.obj.tr._selected = (data.selected!=null);
		this.obj.tr.className = "tr_btn"+(this.obj.tr.en?(this.obj.tr._selected&&self.renderSelect?" tr_btn_selected":""):" tr_btn_disabled");
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.tr.idd = String(id);
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.td_a = document.createElement("TD");
		this.obj.td_a.className = "td_btn_img";
		this.obj.td_a.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td_b = document.createElement("TD");
		this.obj.td_b.className = "td_btn_txt";
		this.obj.td_b.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (that.rtl) {
			this.obj.tr.appendChild(this.obj.td_b);
			this.obj.tr.appendChild(this.obj.td_a);
		} else {
			this.obj.tr.appendChild(this.obj.td_a);
			this.obj.tr.appendChild(this.obj.td_b);
		}
		
		// image
		if (data.img != null) {
			if (that.conf.icons_css == true) {
				this.obj.td_a.innerHTML = "<i class='"+that.conf.icons_path+data.img+"'></i>";
			} else {
				this.obj.td_a.innerHTML = "<img class='btn_sel_img' src='"+that.conf.icons_path+data.img+"' border='0'>";
			}
			this.obj.tr._img = data.img;
		} else {
			this.obj.td_a.innerHTML = "&nbsp;";
		}
		
		// text
		var itemText = (data.text!=null?data.text:(data.itemText||""));
		this.obj.td_b.innerHTML = "<div class='btn_sel_text'>"+itemText+"</div>";
		
		this.obj.tr.onmouseover = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en || (this._selected && self.renderSelect)) return;
			this.className = "tr_btn tr_btn_over";
		}
		
		this.obj.tr.onmouseout = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en) return;
			if (this._selected && self.renderSelect) {
				if (String(this.className).search("tr_btn_selected") == -1) this.className = "tr_btn tr_btn_selected";
			} else {
				this.className = "tr_btn";
			}
		}
		
		this.obj.tr.ontouchstart = this.obj.tr.onmousedown = function(e) {
			e = e||event;
			if (this._etype == null) this._etype = e.type;
		}
		this.obj.tr.onclick = function(e) {
			
			e = e||event;
			e.cancelBubble = true;
			if (!this.en) return;
			
			self.setListOptionSelected(this.idd.replace(that.idPrefix,""));
			
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			self.obj.over = false;
			
			if (this._etype != null && this._etype.match(/touch/) == null) {
				window.dhx4.zim.clear(self.polygon._idd);
				self.polygon.style.display = "none";
				if (self.polygon._ie6cover) self.polygon._ie6cover.style.display = "none";
			} else {
				var p = self.polygon;
				window.setTimeout(function(){
					window.dhx4.zim.clear(p._idd);
					p.style.display = "none";
					p = null;
				}, 500);
			}
			this._etype = null;
			
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, true);
			that.anyUsed = null;
			that.conf.touch_id = null;
			// event
			that.callEvent("onButtonSelectHide", [self.obj.idd]);
			// event
			var id = this.idd.replace(that.idPrefix,"");
			if (this.extAction) try {window[this.extAction](id);} catch(e){};
			that.callEvent("onClick", [id]);
		}		
		self._listOptions[id] = this.obj;
		
		return this;
		
	}
	
	// add polygon
	this.polygon = document.createElement("DIV");
	this.polygon.dir = "ltr";
	this.polygon.style.display = "none";
	this.polygon.className = "dhx_toolbar_poly_"+that.conf.skin+" dhxtoolbar_icons_"+that.conf.iconSize+that.conf.cssShadow;
	this.polygon.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.polygon.onmousedown = function(e) { e = e||event; e.cancelBubble = true; }
	this.polygon.style.overflowY = "auto";
	this.polygon._idd = window.dhx4.newId();
	
	this.polygon.ontouchstart = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	this.polygon.ontouchend = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	
	this.p_tbl = document.createElement("TABLE");
	this.p_tbl.className = "buttons_cont";
	this.p_tbl.cellSpacing = "0";
	this.p_tbl.cellPadding = "0";
	this.p_tbl.border = "0";
	this.polygon.appendChild(this.p_tbl);
	
	this.p_tbody = document.createElement("TBODY");
	this.p_tbl.appendChild(this.p_tbody);
	
	//
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			var t = "_"+(data.options[q].type||"")+"ButtonSelectObject";
			if (data.options[q].id == null) data.options[q].id = that._genStr(24);
			if (typeof(this[t]) == "function") new this[t](data.options[q].id, data.options[q]);
		}
	}
	
	document.body.appendChild(this.polygon);
	
	// add poly ie6cover
	if (window.dhx4.isIE6) {
		this.polygon._ie6cover = document.createElement("IFRAME");
		this.polygon._ie6cover.frameBorder = 0;
		this.polygon._ie6cover.style.position = "absolute";
		this.polygon._ie6cover.style.border = "none";
		this.polygon._ie6cover.style.backgroundColor = "#000000";
		this.polygon._ie6cover.style.filter = "alpha(opacity=100)";
		this.polygon._ie6cover.style.display = "none";
		this.polygon._ie6cover.setAttribute("src","javascript:false;");
		document.body.appendChild(this.polygon._ie6cover);
	}
	
	// functions
	// new engine
	this.setWidth = function(width) {
		this.obj.style.width = width-this.arw.offsetWidth+"px";
		this.polygon.style.width = this.obj.offsetWidth+this.arw.offsetWidth-2+"px";
		this.p_tbl.style.width = this.polygon.style.width;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
		this.arw.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
		this.arw.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
		this.arw.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	/* list option functions */
	// new engine
	this.addListOption = function(id, pos, type, text, img) {
		if (!(type == "button" || type == "separator")) return;
		var dataItem = {id:id,type:type,text:text,img:img};
		new this["_"+type+"ButtonSelectObject"](id, dataItem, pos);
	}
	// new engine
	this.removeListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		var item = this._listOptions[id];
		if (item.td_a != null && item.td_b != null) {
			// button
			item.td_a.onselectstart = null;
			item.td_b.onselectstart = null;
			while (item.td_a.childNodes.length > 0) item.td_a.removeChild(item.td_a.childNodes[0]);
			while (item.td_b.childNodes.length > 0) item.td_b.removeChild(item.td_b.childNodes[0]);
			item.tr.onselectstart = null;
			item.tr.onmouseover = null;
			item.tr.onmouseout = null;
			item.tr.onclick = null;
			item.tr.ontouchstart = null;
			item.tr.onmousedown = null;
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.td_a = null;
			item.td_b = null;
			item.tr = null;
		} else {
			// separator
			item.sep.onselectstart = null;
			item.td.onselectstart = null;
			item.tr.onselectstart = null;
			while (item.td.childNodes.length > 0) item.td.removeChild(item.td.childNodes[0]);
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.sep = null;
			item.td = null;
			item.tr = null;
		}
		item = null;
		this._listOptions[id] = null;
		try { delete this._listOptions[id]; } catch(e) {}
	}
	// new engine
	this.showListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "";
	}
	// new engine
	this.hideListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "none";
	}
	// new engine
	this.isListOptionVisible = function(id) {
		if (!this._isListButton(id, true)) return;
		return (this._listOptions[id].tr.style.display != "none");
	}
	// new engine
	this.enableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = true;
		this._listOptions[id].tr.className = "tr_btn"+(this._listOptions[id].tr._selected&&that.renderSelect?" tr_btn_selected":"");
	}
	// new engine
	this.disableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = false;
		this._listOptions[id].tr.className = "tr_btn tr_btn_disabled";
	}
	// new engine
	this.isListOptionEnabled = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.en;
	}
	// new engine
	this.setListOptionPosition = function(id, pos) {
		if (!this._listOptions[id] || this.getListOptionPosition(id) == pos || isNaN(pos)) return;
		if (pos < 1) pos = 1;
		var tr = this._listOptions[id].tr;
		this.p_tbody.removeChild(tr);
		if (pos > this.p_tbody.childNodes.length) this.p_tbody.appendChild(tr); else this.p_tbody.insertBefore(tr, this.p_tbody.childNodes[pos-1]);
		tr = null;
	}
	// new engine
	this.getListOptionPosition = function(id) {
		var pos = -1;
		if (!this._listOptions[id]) return pos;
		for (var q=0; q<this.p_tbody.childNodes.length; q++) if (this.p_tbody.childNodes[q] == this._listOptions[id].tr) pos=q+1;
		return pos;
	}
	// new engine
	this.setListOptionImage = function(id, img) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		td.innerHTML = (that.conf.icons_css?"<i class='"+that.conf.icons_path+img+"'></i>":"<img src='"+that.conf.icons_path+img+"' class='btn_sel_img'>");
		td = null;
	}
	// new engine
	this.getListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		var src = null;
		if (td.childNodes.length > 0) src = td.childNodes[0][(that.conf.icons_css?"className":"src")];
		td = null;
		return src;
	}
	// new engine
	this.clearListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		while (td.childNodes.length > 0) td.removeChild(td.childNodes[0]);
		td.innerHTML = "&nbsp;";
		td = null;
	}
	// new engine
	this.setListOptionText = function(id, text) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML = text;
	}
	// new engine
	this.getListOptionText = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML;
	}
	// new engine
	this.setListOptionToolTip = function(id, tip) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.title = tip;
	}
	// new engine
	this.getListOptionToolTip = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.title;
	}
	// works
	this.forEachListOption = function(handler) {
		for (var a in this._listOptions) handler(a);
	}
	// works, return array with ids
	this.getAllListOptions = function() {
		var listData = new Array();
		for (var a in this._listOptions) listData[listData.length] = a;
		return listData;
	}
	// new engine
	this.setListOptionSelected = function(id) {
		for (var a in this._listOptions) {
			var item = this._listOptions[a];
			if (item.td_a != null && item.td_b != null && item.tr.en) {
				if (a == id) {
					item.tr._selected = true;
					item.tr.className = "tr_btn"+(this.renderSelect?" tr_btn_selected":"");
					//
					if (this.mode == "select") {
						if (item.tr._img) this.setItemImage(item.tr._img); else this.clearItemImage();
						this.setItemText(this.getListOptionText(id));
					}
				} else {
					item.tr._selected = false;
					item.tr.className = "tr_btn";
				}
			}
			item = null;
		}
	}
	// new engine
	this.getListOptionSelected = function() {
		var id = null;
		for (var a in this._listOptions) if (this._listOptions[a].tr._selected == true) id = a;
		return id;
	}
	// inner, return tru if list option is button and is exists
	this._isListButton = function(id, allowSeparator) {
		if (this._listOptions[id] == null) return false;
		if (!allowSeparator && this._listOptions[id].tr.className == "tr_sep") return false;
		return true;
	}
	
	this.setMaxOpen = function(r) {
		this._ph = null;
		if (typeof(r) == "number") {
			this.maxOpen = r;
			this._maxOpenTest();
			return;
		}
		this.maxOpen = null;
	}
	
	if (data.width) this.setWidth(data.width);
	
	if (this.mode == "select" && typeof(data.selected) != "undefined") this.setListOptionSelected(data.selected);
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonInput
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonInputObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.w = (data.width!=null?data.width:100);
	this.obj.title = (data.title!=null?data.title:"");
	//
	this.obj.innerHTML = "<input class='dhxtoolbar_input' type='text' style='width:"+this.obj.w+"px;'"+(data.value!=null?" value='"+data.value+"'":"")+">";
	
	var th = that;
	var self = this;
	this.obj.childNodes[0].onkeydown = function(e) {
		e = e||event;
		if (e.keyCode == 13) { th.callEvent("onEnter", [self.obj.idd, this.value]); }
	}
	// add
	that.base.appendChild(this.obj);
	//
	this.enableItem = function() {
		this.obj.childNodes[0].disabled = false;
	}
	this.disableItem = function() {
		this.obj.childNodes[0].disabled = true;
	}
	this.isEnabled = function() {
		return (!this.obj.childNodes[0].disabled);
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display != "none");
	}
	this.setValue = function(value) {
		this.obj.childNodes[0].value = value;
	}
	this.getValue = function() {
		return this.obj.childNodes[0].value;
	}
	this.setWidth = function(width) {
		this.obj.w = width;
		this.obj.childNodes[0].style.width = this.obj.w+"px";
	}
	this.getWidth = function() {
		return this.obj.w;
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	this.getInput = function() {
		return this.obj.firstChild;
	}
	
	if (typeof(data.enabled) != "undefined" && window.dhx4.s2b(data.enabled) == false) {
		this.disableItem();
	}
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonTwoState
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonTwoStateObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img!=null?data.img:"");
	this.imgDis = (data.imgdis!=null?data.imgdis:"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	//
	this.obj = document.createElement("DIV");
	this.obj.pressed = (data.selected!=null);
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.obj.pressed?"pres"+(this.state?"":"_dis"):(this.state?"def":"dis"));
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	if (this.obj.pressed) { this.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over"; }
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.over == true) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (that.callEvent("onBeforeStateChange", [t.obj.idd.replace(that.idPrefix, ""), t.obj.pressed]) !== true) return;
		t.obj.pressed = !t.obj.pressed;
		t.obj.className = "dhx_toolbar_btn " + (t.obj.pressed == true ? "dhxtoolbar_btn_pres" : (t.obj.over == true? "dhxtoolbar_btn_over" : "dhxtoolbar_btn_def"));
		//
		var id = t.obj.idd.replace(that.idPrefix, "");
		if (t.obj.extAction) try {window[t.obj.extAction](idd, t.obj.pressed);} catch(e){};
		that.callEvent("onStateChange", [id, t.obj.pressed]);
	}
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
	}
	
	
	// mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.setItemState = function(state, callEvent) {
		if (this.obj.pressed != state) {
			if (state == true) {
				this.obj.pressed = true;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres"+(this.state?"":"_dis");
			} else {
				this.obj.pressed = false;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
			}
			if (callEvent == true) {
				var id = this.obj.idd.replace(that.idPrefix, "");
				if (this.obj.extAction) try {window[this.obj.extAction](id, this.obj.pressed);} catch(e){};
				that.callEvent("onStateChange", [id, this.obj.pressed]);
			}
		}
	}
	this.getItemState = function() {
		return this.obj.pressed;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: slider
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._sliderObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.len = (data.length!=null?Number(data.length):50);
	//
	this.obj.innerHTML = "<div class='dhxtoolbar_text'>"+(data.textMin||"")+"</div>"+
				"<div class='dhxtoolbar_sl_bg_l'></div>"+
				"<div class='dhxtoolbar_sl_bg_m' style='width:"+this.obj.len+"px;'></div>"+
				"<div class='dhxtoolbar_sl_bg_r'></div>"+
				"<div class='dhxtoolbar_text'>"+(data.textMax||"")+"</div>";
	// add object
	that.base.appendChild(this.obj);
	var self = this;
	
	this.pen = document.createElement("DIV");
	this.pen.className = "dhxtoolbar_sl_pen";
	this.obj.appendChild(this.pen);
	var pen = this.pen;
	
	this.label = document.createElement("DIV");
	this.label.dir = "ltr";
	this.label.className = "dhx_toolbar_slider_label_"+that.conf.skin+(that.rtl?"_rtl":"");
	this.label.style.display = "none";
	this.label.tip = (data.toolTip||"%v");
	this.label._zi = window.dhx4.newId();
	document.body.appendChild(this.label);
	var label = this.label;
	
	// mix-max value
	this.pen.valueMin = (data.valueMin!=null?Number(data.valueMin):0);
	this.pen.valueMax = (data.valueMax!=null?Number(data.valueMax):100);
	if (this.pen.valueMin > this.pen.valueMax) this.pen.valueMin = this.pen.valueMax;
	
	// init value
	this.pen.valueNow = (data.valueNow!=null?Number(data.valueNow):this.pen.valueMax);
	if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
	if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
	
	// min/max x coordinate
	this.pen._detectLimits = function() {
		this.minX = self.obj.childNodes[1].offsetLeft+2;
		this.maxX = self.obj.childNodes[3].offsetLeft-this.offsetWidth+1;
	}
	this.pen._detectLimits();
	
	// position
	this.pen._definePos = function() {
		this.nowX = Math.round((this.valueNow-this.valueMin)*(this.maxX-this.minX)/(this.valueMax-this.valueMin)+this.minX);
		this.style.left = this.nowX+"px";
		this.newNowX = this.nowX;
	}
	this.pen._definePos();

	this.pen.initXY = 0;
	this.pen.allowMove = false;
	this.pen[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		if (self.state == false) return;
		e = e||event;
		this.initXY = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX); //e.clientX;
		this.newValueNow = this.valueNow;
		this.allowMove = true;
		this.className = "dhxtoolbar_sl_pen dhxtoolbar_over";
		if (label.tip != "") {
			label.style.visibility = "hidden";
			label.style.display = "";
			label.innerHTML = label.tip.replace("%v", this.valueNow);
			label.style.left = Math.round(window.dhx4.absLeft(this)+this.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(this)-label.offsetHeight-3+"px";
			label.style.visibility = "";
			label.style.zIndex = window.dhx4.zim.reserve(label._zi);
		}
	}
	
	this.pen._doOnMouseMoveStart = function(e) {
		// optimized for destructor
		e=e||event;
		if (!pen.allowMove) return;
		var ecx = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX);
		var ofst = ecx - pen.initXY;
		
		// mouse goes out to left/right from pen
		if (ecx < window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.minX) return;
		if (ecx > window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.maxX) return;
		
		pen.newNowX = pen.nowX + ofst;
		
		if (pen.newNowX < pen.minX) pen.newNowX = pen.minX;
		if (pen.newNowX > pen.maxX) pen.newNowX = pen.maxX;
		pen.nowX = pen.newNowX;
		pen.style.left = pen.nowX+"px";
		pen.initXY = ecx;
		pen.newValueNow = Math.round((pen.valueMax-pen.valueMin)*(pen.newNowX-pen.minX)/(pen.maxX-pen.minX)+pen.valueMin);
		if (label.tip != "") {
			label.innerHTML = label.tip.replace(/%v/gi, pen.newValueNow);
			label.style.left = Math.round(window.dhx4.absLeft(pen)+pen.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(pen)-label.offsetHeight-3+"px";
		}
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.pen._doOnMouseMoveEnd = function() {
		if (!pen.allowMove) return;
		pen.className = "dhxtoolbar_sl_pen";
		pen.allowMove = false;
		pen.nowX = pen.newNowX;
		pen.valueNow = pen.newValueNow;
		if (label.tip != "") {
			label.style.display = "none";
			window.dhx4.zim.clear(label._zi);
		}
		that.callEvent("onValueChange", [self.obj.idd.replace(that.idPrefix, ""), pen.valueNow]);
	}
	
	if (window.dhx4.isIPad) {
		document.addEventListener("touchmove", pen._doOnMouseMoveStart, false);
		document.addEventListener("touchend", pen._doOnMouseMoveEnd, false);
	} else {
		if (typeof(window.addEventListener) != "undefined") {
			window.addEventListener("mousemove", pen._doOnMouseMoveStart, false);
			window.addEventListener("mouseup", pen._doOnMouseMoveEnd, false);
		} else {
			document.body.attachEvent("onmousemove", pen._doOnMouseMoveStart);
			document.body.attachEvent("onmouseup", pen._doOnMouseMoveEnd);
		}
	}
	// functions
	this.enableItem = function() {
		if (this.state) return;
		this.state = true;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	}
	this.disableItem = function() {
		if (!this.state) return;
		this.state = false;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_dis";
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setValue = function(value, callEvent) {
		value = Number(value);
		if (value < this.pen.valueMin) value = this.pen.valueMin;
		if (value > this.pen.valueMax) value = this.pen.valueMax;
		this.pen.valueNow = value;
		this.pen._definePos();
		if (callEvent == true) that.callEvent("onValueChange", [this.obj.idd.replace(that.idPrefix, ""), this.pen.valueNow]);
	}
	this.getValue = function() {
		return this.pen.valueNow;
	}
	this.setMinValue = function(value, label) {
		value = Number(value);
		if (value > this.pen.valueMax) return;
		this.obj.childNodes[0].innerHTML = label;
		this.obj.childNodes[0].style.display = (label.length>0?"":"none");
		this.pen.valueMin = value;
		if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.setMaxValue = function(value, label) {
		value = Number(value);
		if (value < this.pen.valueMin) return;
		this.obj.childNodes[4].innerHTML = label;
		this.obj.childNodes[4].style.display = (label.length>0?"":"none");
		this.pen.valueMax = value;
		if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.getMinValue = function() {
		var label = this.obj.childNodes[0].innerHTML;
		var value = this.pen.valueMin;
		return new Array(value, label);
	}
	this.getMaxValue = function() {
		var label = this.obj.childNodes[4].innerHTML;
		var value = this.pen.valueMax;
		return new Array(value, label);
	}
	this.setItemToolTipTemplate = function(template) {
		this.label.tip = template;
	}
	this.getItemToolTipTemplate = function() {
		return this.label.tip;
	}
	//
	return this;
}

dhtmlXToolbarObject.prototype.unload = function() {
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("mousedown", this._doOnClick, false);
		window.removeEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.detachEvent("onmousedown", this._doOnClick);
	}
	
	this._doOnClick = null;
	
	this.clearAll();
	this.objPull = null;
	
	if (this._xmlLoader) {
		this._xmlLoader.destructor();
		this._xmlLoader = null;
	}
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	this.cont.removeChild(this.base);
	this.base = null;
	
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	this.cont.className = "";
	this.cont = null;
	
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
	window.dhx4._eventable(this, "clear");
	
	this.tX1 = null;
	this.tX2 = null;
	this.tY1 = null;
	this.tY2 = null;
	
	this.anyUsed = null;
	this.idPrefix = null;
	this.rootTypes = null;
	
	this._rtl = null;
	this._rtlParseBtn = null;
	this.setRTL = null;
	
	this._sbw = null;
	this._getObj = null;
	this._addImgObj = null;
	this._setItemImage = null;
	this._clearItemImage = null;
	this._setItemText = null;
	this._getItemText = null;
	this._enableItem = null;
	this._disableItem = null;
	this._xmlParser = null;
	
	this._addItemToStorage = null;
	this._genStr = null;
	this._addItem = null;
	this._getPosition = null;
	this._setPosition = null;
	this._getIdByPosition = null;
	this._separatorObject = null;
	this._textObject = null;
	this._buttonObject = null;
	this._buttonSelectObject = null;
	this._buttonInputObject = null;
	this._buttonTwoStateObject = null;
	this._sliderObject = null;
	this._autoDetectVisibleArea = null;
	this._removeItem = null;
	this.setAlign = null;
	this.setSkin = null;
	this.setIconsPath = null;
	this.setIconPath = null;
	this.loadXML = null;
	this.loadXMLString = null;
	this.clearAll = null;
	this.addSpacer = null;
	this.removeSpacer = null;
	this.getType = null;
	this.getTypeExt = null;
	this.inArray = null;
	this.getParentId = null;
	this.addButton = null;
	this.addText = null;
	this.addButtonSelect = null;
	this.addButtonTwoState = null;
	this.addSeparator = null;
	this.addSlider = null;
	this.addInput = null;
	this.forEachItem = null;
	this.showItem = null;
	this.hideItem = null;
	this.isVisible = null;
	this.enableItem = null;
	this.disableItem = null;
	this.isEnabled = null;
	this.setItemText = null;
	this.getItemText = null;
	this.setItemToolTip = null;
	this.getItemToolTip = null;
	this.setItemImage = null;
	this.setItemImageDis = null;
	this.clearItemImage = null;
	this.clearItemImageDis = null;
	this.setItemState = null;
	this.getItemState = null;
	this.setItemToolTipTemplate = null;
	this.getItemToolTipTemplate = null;
	this.setValue = null;
	this.getValue = null;
	this.setMinValue = null;
	this.getMinValue = null;
	this.setMaxValue = null;
	this.getMaxValue = null;
	this.setWidth = null;
	this.getWidth = null;
	this.getPosition = null;
	this.setPosition = null;
	this.removeItem = null;
	this.addListOption = null;
	this.removeListOption = null;
	this.showListOption = null;
	this.hideListOption = null;
	this.isListOptionVisible = null;
	this.enableListOption = null;
	this.disableListOption = null;
	this.isListOptionEnabled = null;
	this.setListOptionPosition = null;
	this.getListOptionPosition = null;
	this.setListOptionText = null;
	this.getListOptionText = null;
	this.setListOptionToolTip = null;
	this.getListOptionToolTip = null;
	this.setListOptionImage = null;
	this.getListOptionImage = null;
	this.clearListOptionImage = null;
	this.forEachListOption = null;
	this.getAllListOptions = null;
	this.setListOptionSelected = null;
	this.getListOptionSelected = null;
	this.unload = null;
	this.setUserData = null;
	this.getUserData = null;
	this.setMaxOpen = null;
	this.items = null;
	this.conf = null;
};

dhtmlXToolbarObject.prototype._autoDetectVisibleArea = function() {
	var d = window.dhx4.screenDim();
	this.tX1 = d.left;
	this.tX2 = d.right;
	this.tY1 = d.top;
	this.tY2 = d.bottom;
};

dhtmlXToolbarObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name=="awesome");
};
dhtmlXToolbarObject.prototype._evs = {
	add: function(evs, obj) { // this->calle
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.addEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.attachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	},
	clear: function(evs, obj) {
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.removeEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.detachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	}
};
dhtmlXToolbarObject.prototype._initObj = function(data) {
	for (var q=0; q<data.length; q++) this._addItemToStorage(data[q]);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._xmlToJson = function(xml) {
	
	var data = [];
	var root = xml.getElementsByTagName("toolbar");
	
	if (root != null && root[0] != null) {
		
		root = root[0];
		
		var getExtText = function(node) {
			var t = null;
			for (var q=0; q<node.childNodes.length; q++) {
				if (t == null && node.childNodes[q].tagName == "itemText") {
					t = window.dhx4._xmlNodeValue(node.childNodes[q]);
					break;
				}
			}
			return t;
		}
		
		var t = ["id", "type", "hidden", "title", "text", "enabled", "img", "imgdis", "action", "openAll", "renderSelect", "mode", "maxOpen", "width", "value", "selected", "length", "textMin", "textMax", "toolTip", "valueMin", "valueMax", "valueNow"];
		var p = ["id", "type", "enabled", "disabled", "action", "selected", "img", "text"];
		//
		for (var q=0; q<root.childNodes.length; q++) {
			if (root.childNodes[q].tagName == "item") {
				
				var itemData = {};
				for (var w=0; w<t.length; w++) {
					var val = root.childNodes[q].getAttribute(t[w]);
					if (val != null) itemData[t[w]] = val;
				}
				
				for (var e=0; e<root.childNodes[q].childNodes.length; e++) {
					if (root.childNodes[q].childNodes[e].tagName == "item" && itemData.type == "buttonSelect") {
						var u = {};
						for (var w=0; w<p.length; w++) {
							var val = root.childNodes[q].childNodes[e].getAttribute(p[w]);
							if (val != null) u[p[w]] = val;
						}
						// listed options userdata
						var h = root.childNodes[q].childNodes[e].getElementsByTagName("userdata");
						for (var w=0; w<h.length; w++) {
							if (!u.userdata) u.userdata = {};
							var r = {};
							try { r.name = h[w].getAttribute("name"); } catch(k) { r.name = null; }
							try { r.value = h[w].firstChild.nodeValue; } catch(k) { r.value = ""; }
							if (r.name != null) u.userdata[r.name] = r.value;
						}
						// get extended <itemText>
						u.text = getExtText(root.childNodes[q].childNodes[e])||u.text;
						//
						if (itemData.options == null) itemData.options = [];
						itemData.options.push(u);
					}
					
					// items userdata
					if (root.childNodes[q].childNodes[e].tagName == "userdata") {
						if (itemData.userdata == null) itemData.userdata = {};
						var u = {};
						try { u.name = root.childNodes[q].childNodes[e].getAttribute("name"); } catch(k) { u.name = null; }
						try { u.value = root.childNodes[q].childNodes[e].firstChild.nodeValue; } catch(k) { u.value = ""; }
						if (u.name != null) itemData.userdata[u.name] = u.value;
					}
				}
				
				// get extended <itemText>
				itemData.text = getExtText(root.childNodes[q])||itemData.text;
				
				data.push(itemData);
			}
		}
		
		getExtText = null;
	}
	
	return data;
};

dhtmlXToolbarObject.prototype._addItemToStorage = function(data, pos) {
	
	var id = (data.id||this._genStr(24));
	var type = (data.type||"");
	
	if (type == "spacer") {
		this.addSpacer(this._lastId);
	} else {
		this._lastId = id;
	}
	
	if (type != "" && this["_"+type+"Object"] != null) {
		
		if (type == "buttonSelect") {
			if (data.options != null) {
				for (var q=0; q<data.options.length; q++) { // js-array button select init used obj/sep
					if (data.options[q].type == "obj") data.options[q].type = "button";
					if (data.options[q].type == "sep") data.options[q].type = "separator";
				}
			}
		}
		
		if (type == "slider") {
			var k = {
				tip_template: "toolTip",
				value_min: "valueMin",
				value_max: "valueMax",
				value_now: "valueNow",
				text_min: "textMin",
				text_max: "textMax"
			};
			for (var a in k) {
				if (data[k[a]] == null && data[a] != null) data[k[a]] = data[a];
			}
		}
		
		if (type == "buttonInput") {
			if (data.value == null && data.text != null) data.value = data.text;
		}
		
		if (type == "buttonTwoState") {
			if (typeof(data.selected) == "undefined" && typeof(data.pressed) != "undefined" && window.dhx4.s2b(data.pressed)) {
				data.selected = true;
			}
		}
		
		// common
		if (typeof(data.enabled) == "undefined" && typeof(data.disabled) != "undefined" && window.dhx4.s2b(data.disabled)) {
			data.enabled = false;
		}
		if (data.imgDis == null && data.img_disabled != null) {
			data.imgdis = data.img_disabled;
		}
		
		if ((typeof(data.openAll) == "undefined" || data.openAll == null) && this.conf.skin == "dhx_terrace") data.openAll = true;
		this.objPull[this.idPrefix+id] = new this["_"+type+"Object"](this, id, data);
		this.objPull[this.idPrefix+id]["type"] = type;
		this.setPosition(id, pos);
	}
	
	// userdata
	if (data.userdata != null) {
		for (var a in data.userdata) this.setUserData(id, a, data.userdata[a]);
	}
	// userdata for options
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			if (data.options[q].userdata != null) {
				for (var a in data.options[q].userdata) {
					this.setListOptionUserData(data.id, data.options[q].id, a, data.options[q].userdata[a]);
				}
			}
		}
	}

};

// skin
dhtmlXToolbarObject.prototype.setSkin = function(skin, onlyIcons) {
	if (onlyIcons === true) {
		// prevent of removing skin postfixes when attached to layout/acc/etc
		this.cont.className = this.cont.className.replace(/dhxtoolbar_icons_\d{1,}/,"dhxtoolbar_icons_"+this.conf.iconSize);
	} else {
		this.conf.skin = skin;
		if (this.conf.skin == "dhx_skyblue") {
			this.conf.sel_ofs_y = 1;
		}
		if (this.conf.skin == "dhx_web") {
			this.conf.sel_ofs_y = 1;
			this.conf.sel_ofs_x = 1;
		}
		if (this.conf.skin == "dhx_terrace") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		if (this.conf.skin == "material") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		this.cont.className = "dhx_toolbar_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
	}
	
	for (var a in this.objPull) {
		var item = this.objPull[a];
		if (item["type"] == "slider") {
			item.pen._detectLimits();
			item.pen._definePos();
			item.label.className = "dhx_toolbar_slider_label_"+this.conf.skin;
		}
		if (item["type"] == "buttonSelect") {
			item.polygon.className = "dhx_toolbar_poly_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
		}
	}
	if (skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype.setAlign = function(align) {
	this.conf.align = (align=="right"?"right":"left");
	this.base.className = (align=="right"?"dhxtoolbar_float_right":"dhxtoolbar_float_left");
	if (this._spacer) this._spacer.className = (align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right")
};

dhtmlXToolbarObject.prototype.setIconSize = function(size) {
	this.conf.iconSize = ({18:true,24:true,32:true,48:true}[size]?size:18);
	this.setSkin(this.conf.skin, true);
	this.callEvent("_onIconSizeChange",[this.conf.iconSize]);
};

dhtmlXToolbarObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};


// user data
dhtmlXToolbarObject.prototype.setUserData = function(id, name, value) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null) {
		if (this.objPull[id].userData == null) this.objPull[id].userData = {};
		this.objPull[id].userData[name] = value;
	}
};
dhtmlXToolbarObject.prototype.getUserData = function(id, name) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null && this.objPull[id].userData != null) return this.objPull[id].userData[name]||null;
	return null;
};
// userdata for listed options
dhtmlXToolbarObject.prototype._isListOptionExists = function(listId, optionId) {
	if (this.objPull[this.idPrefix+listId] == null) return false;
	var item = this.objPull[this.idPrefix+listId];
	if (item.type != "buttonSelect") return false;
	if (item._listOptions[optionId] == null) return false;
	return true;
};
dhtmlXToolbarObject.prototype.setListOptionUserData = function(listId, optionId, name, value) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return;
	// set userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (opt.userData == null) opt.userData = {};
	opt.userData[name] = value;
};
dhtmlXToolbarObject.prototype.getListOptionUserData = function(listId, optionId, name) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return null;
	// get userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (!opt.userData) return null;
	return (opt.userData[name]?opt.userData[name]:null);
};


// terrace skin fixes
dhtmlXToolbarObject.prototype._improveTerraceSkin = function() {
	
	if (this.conf.terrace_radius == null) this.conf.terrace_radius = "3px";
	
	var p = [];
	var bn = {separator: true, text: true}; // border-less items
	
	var e = [this.base];
	if (this._spacer != null) e.push(this._spacer);
	for (var w=0; w<e.length; w++) {
		p[w] = [];
		for (var q=0; q<e[w].childNodes.length; q++) {
			if (e[w].childNodes[q].idd != null && e[w].childNodes[q].style.display != "none") {
				var a = this.idPrefix+e[w].childNodes[q].idd;
				if (this.objPull[a] != null && this.objPull[a].obj == e[w].childNodes[q]) {
					p[w].push({a:a,type:this.objPull[a].type,node:this.objPull[a][this.objPull[a].type=="buttonSelect"?"arw":"obj"]});
				}
			}
		}
		e[w] = null;
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			
			var t = p[w][q];
			
			// check if border-right/border-left needed
			var br = false;
			var bl = false;
			
			if (!bn[t.type]) {
				
				// right side - check if item last-child or next-sibling is borderless item
				if (q == p[w].length-1 || (p[w][q+1] != null && bn[p[w][q+1].type])) br = true;
				
				// left side, check if item first-child or prev-sibling is borderless item
				if (q == 0 || (q-1 >= 0 && p[w][q-1] != null && bn[p[w][q-1].type])) bl = true;
				
			}
			
			t.node.style.borderRightWidth = (br?"1px":"0px");
			t.node.style.borderTopRightRadius = t.node.style.borderBottomRightRadius = (br?this.conf.terrace_radius:"0px");
			
			if (t.type == "buttonSelect") {
				t.node.previousSibling.style.borderTopLeftRadius = t.node.previousSibling.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
				t.node.previousSibling._br = br;
				t.node.previousSibling._bl = bl;
			} else {
				t.node.style.borderTopLeftRadius = t.node.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
			}
			
			t.node._br = br;
			t.node._bl = bl;
			
		}
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			for (var a in p[w][q]) p[w][q][a] = null;
			p[w][q] = null;
		}
		p[w] = null;
	}
	
	p = e = null;
};

// enable/disable riunded corners when sublist opened
dhtmlXToolbarObject.prototype._improveTerraceButtonSelect = function(id, state) {
	var item = this.objPull[id];
	if (state == true) {
		item.obj.style.borderBottomLeftRadius = (item.obj._bl?this.conf.terrace_radius:"0px");
		item.arw.style.borderBottomRightRadius = (item.obj._br?this.conf.terrace_radius:"0px");
	} else {
		item.obj.style.borderBottomLeftRadius = "0px";
		item.arw.style.borderBottomRightRadius = "0px";
	}
	item = null;
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_toolbar = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_toolbar_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
			obj.firstChild.className = "dhx_toolbar_base_18_dhx_skyblue";
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.cont]); // before cont only
		
		this.conf.ofs_nodes.t.toolbar = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	}
	
	dhtmlXCellObject.prototype.attachToolbar = function(conf) {
		
		if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
		
		this.callEvent("_onBeforeContentAttach", ["toolbar"]);
		
		if (typeof(conf) == "undefined") {
			conf = {};
		} else if (typeof(conf) == "string") {
			conf = {skin:conf};
		}
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("toolbar").firstChild;
		
		this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
		this._adjustCont(this._idd);
		
		this.dataNodes.toolbar._masterCell = this;
		this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
			this._masterCell._adjustCont();
		});
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.toolbar;
		
	};
	
	dhtmlXCellObject.prototype.detachToolbar = function() {
		
		if (this.dataNodes.toolbar == null) return;
		
		this.dataNodes.toolbar._masterCell = null; // link to this
		if (typeof(this.dataNodes.toolbar.unload) == "function") this.dataNodes.toolbar.unload();
		this.dataNodes.toolbar = null;
		delete this.dataNodes.toolbar;
		
		this._detachObject("toolbar");
		
	};
	
	dhtmlXCellObject.prototype.showToolbar = function() {
		this._mtbShowHide("toolbar", "");
	};
	
	dhtmlXCellObject.prototype.hideToolbar = function() {
		this._mtbShowHide("toolbar", "none");
	};
	

	
	dhtmlXCellObject.prototype.getAttachedToolbar = function() {
		return this.dataNodes.toolbar;
	};
	
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//latest dev. version

/*_TOPICS_
@0:initialization
@1:selection control
@2:rows control
@3:colums control
@4:cells controll
@5:data manipulation
@6:appearence control
@7:overal control
@8:tools
@9:treegrid
@10: event handlers
@11: paginal output
*/

var globalActiveDHTMLGridObject;
String.prototype._dhx_trim=function(){
	return this.replace(/&nbsp;/g, " ").replace(/(^[ \t]*)|([ \t]*$)/g, "");
}

function dhtmlxArray(ar){
	return dhtmlx.extend((ar||new Array()), dhtmlxArray._master);
};
dhtmlxArray._master={
	_dhx_find:function(pattern){
		for (var i = 0; i < this.length; i++){
			if (pattern == this[i])
				return i;
		}
		return -1;
	},
	_dhx_insertAt:function(ind, value){
		this[this.length]=null;
		for (var i = this.length-1; i >= ind; i--)
			this[i]=this[i-1]
		this[ind]=value
	},
	_dhx_removeAt:function(ind){
		this.splice(ind,1)
	},
	_dhx_swapItems:function(ind1, ind2){
		var tmp = this[ind1];
		this[ind1]=this[ind2]
		this[ind2]=tmp;
	}
}

/**
*   @desc: dhtmlxGrid constructor
*   @param: id - (optional) id of div element to base grid on
*   @returns: dhtmlxGrid object
*   @type: public
*/
function dhtmlXGridObject(id){
	if (dhtmlxEvent.initTouch)
		dhtmlxEvent.initTouch();
	
	if (_isIE)
	try{
		document.execCommand("BackgroundImageCache", false, true);
	}
	catch (e){}
	
	if (id){
		if (typeof (id) == 'object'){
			this.entBox=id
			if (!this.entBox.id) this.entBox.id="cgrid2_"+this.uid();
		} else
		this.entBox=document.getElementById(id);
	} else {
		this.entBox=document.createElement("DIV");
		this.entBox.id="cgrid2_"+this.uid();
	}
	this.entBox.innerHTML="";
	dhx4._eventable(this);
	
	var self = this;
	
	this._RaSeCol=[];
	this._wcorr=0;
	this.fontWidth = 7;
	this.cell=null;
	this.row=null;
	this.iconURL="";
	this.editor=null;
	this._f2kE=true;
	this._dclE=true;
	this.combos=new Array(0);
	this.defVal=new Array(0);
	this.rowsAr={
	};
	
	this.rowsBuffer=dhtmlxArray();
	this.rowsCol=dhtmlxArray(); //array of rows by index
	
	this._data_cache={
	};
	
	this._ecache={
	}
	
	this._ud_enabled=true;
	this.xmlLoader=this.doLoadDetails;
	
	this._maskArr=[];
	this.selectedRows=dhtmlxArray(); //selected rows array
	
	this.UserData={};//hash of row related userdata (and for grid - "gridglobaluserdata")
	this._sizeFix=this._borderFix=0;
	/*MAIN OBJECTS*/
	
	this.entBox.className+=" gridbox";
	
	this.entBox.style.width=this.entBox.getAttribute("width")
	||(window.getComputedStyle
		? (this.entBox.style.width||window.getComputedStyle(this.entBox, null)["width"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["width"]
			: this.entBox.style.width||0))
	||"100%";
	
	this.entBox.style.height=this.entBox.getAttribute("height")
	||(window.getComputedStyle
		? (this.entBox.style.height||window.getComputedStyle(this.entBox, null)["height"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["height"]
			: this.entBox.style.height||0))
	||"100%";
	//cursor and text selection
	this.entBox.style.cursor='default';
	
	this.entBox.onselectstart=function(){
		return false
	}; //avoid text select
	var t_creator=function(name){
		var t=document.createElement("TABLE");
		t.cellSpacing=t.cellPadding=0;
		t.style.cssText='width:100%;table-layout:fixed;';
		t.className=name.substr(2);
		return t;
	}
	this.obj=t_creator("c_obj");
	this.hdr=t_creator("c_hdr");
	this.hdr.style.marginRight="20px";
	this.hdr.style.paddingRight="20px";
	
	this.objBox=document.createElement("DIV");
	this.objBox.style.width="100%";
	this.objBox.style.overflow="auto";
	this.objBox.appendChild(this.obj);
	this.objBox.className="objbox";
	
	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);
	
	this.hdrBox=document.createElement("DIV");
	this.hdrBox.style.width="100%"
	this.hdrBox.style.height="25px";
	this.hdrBox.style.overflow="hidden";
	this.hdrBox.className="xhdr";
	
	
	this.preloadImagesAr=new Array(0)
	
	this.sortImg=document.createElement("DIV")
	this.sortImg.style.display="none";
	
	this.hdrBox.appendChild(this.sortImg)
	this.hdrBox.appendChild(this.hdr);
	this.hdrBox.style.position="relative";
	
	this.entBox.appendChild(this.hdrBox);
	this.entBox.appendChild(this.objBox);
	
	//add links to current object
	this.entBox.grid=this;
	this.objBox.grid=this;
	this.hdrBox.grid=this;
	this.obj.grid=this;
	this.hdr.grid=this;
	
	/*PROPERTIES*/
	this.cellWidthPX=[];                      //current width in pixels
	this.cellWidthPC=[];                      //width in % if cellWidthType set in pc
	this.cellWidthType=this.entBox.cellwidthtype||"px"; //px or %
	
	this.delim=this.entBox.delimiter||",";
	this._csvDelim=",";
	
	this.hdrLabels=[];
	this.columnIds=[];
	this.columnColor=[];
	this._hrrar=[];
	this.cellType=dhtmlxArray();
	this.cellAlign=[];
	this.initCellWidth=[];
	this.fldSort=[];
	this._srdh=(_isIE && (document.compatMode != "BackCompat") ? 22 : 20);
	this.imgURL=window.dhx_globalImgPath||""; 
	this.isActive=false; //fl to indicate if grid is in work now
	this.isEditable=true;
	this.useImagesInHeader=false; //use images in header or not
	this.pagingOn=false;          //paging on/off
	this.rowsBufferOutSize=0;     //number of rows rendered at a moment
	/*EVENTS*/
	dhtmlxEvent(window, "unload", function(){
			try{
				if (self.destructor) self.destructor();
			}
			catch (e){}
	});
	
	/*XML LOADER(S)*/
	/**
	*   @desc: set one of predefined css styles (xp, mt, gray, light, clear, modern)
	*   @param: name - style name
	*   @type: public
	*   @topic: 0,6
	*/
	this.setSkin=function(name){
		this._srdh=window.dhx4.readFromCss("dhxgrid_rh_"+name)+4;
		this.skin_name=name;
		if (this._imgURL)
			this.setImagePath(this._imgURL);
		
		var classname = this.entBox.className.split(" gridbox")[0];
		this.entBox.className=classname + " gridbox gridbox_"+name+(_isIE?" isIE":" isModern");
		this.skin_h_correction=0;
		
		//#alter_css:06042008{		
		this.enableAlterCss("ev_"+name, "odd_"+name, this.isTreeGrid())
		this._fixAlterCss()
		//#}
		switch (name){
		case "dhx_terrace":
		case "material":
			this._srdh=33;
			this.forceDivInHeader=true;
			break;
			
		case "dhx_web":
		case "material":
			this.forceDivInHeader=true;
			this._srdh = 31;
			break;
			
		case "dhx_skyblue":
			this.forceDivInHeader=true;
			break;
		}
		
		if (_isIE&&this.hdr){
			var d = this.hdr.parentNode;
			d.removeChild(this.hdr);
			d.appendChild(this.hdr);
		}
		this.setSizes();
	}
	
	if (_isIE)
		this.preventIECaching(true);
	if (window.dhtmlDragAndDropObject)
		this.dragger=new dhtmlDragAndDropObject();
	
	/*METHODS. SERVICE*/
	/**
	*   @desc: on scroll grid inner actions
	*   @type: private
	*   @topic: 7
	*/
	this._doOnScroll=function(e, mode){
		this.callEvent("onScroll", [
				this.objBox.scrollLeft,
				this.objBox.scrollTop
		]);
		
		this.doOnScroll(e, mode);
	}
	/**
	*   @desc: on scroll grid more inner action
	*   @type: private
	*   @topic: 7
	*/
	this.doOnScroll=function(e, mode){
		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
		if (this.ftr)
			this.ftr.parentNode.scrollLeft=this.objBox.scrollLeft;
		
		if (mode)
			return;
		
		if (this._srnd){
			if (this._dLoadTimer)
				window.clearTimeout(this._dLoadTimer);
			this._dLoadTimer=window.setTimeout(function(){
					if (self._update_srnd_view)
						self._update_srnd_view();
			}, 100);
		}
	}
	/**
	*   @desc: attach grid to some object in DOM
	*   @param: obj - object to attach to
	*   @type: public
	*   @topic: 0,7
	*/
	this.attachToObject=function(obj){
		obj.appendChild(this.globalBox?this.globalBox:this.entBox);
		//this.objBox.style.height=this.entBox.style.height;
		this.setSizes();
	}
	/**
	*   @desc: initialize grid
	*   @param: fl - if to parse on page xml data island 
	*   @type: public
	*   @topic: 0,7
	*/
	this.init=function(fl){
		if ((this.isTreeGrid())&&(!this._h2)){
			this._h2=this._createHierarchy();
			
			if ((this._fake)&&(!this._realfake))
				this._fake._h2=this._h2;
			this._tgc={
				imgURL: null
			};
		}
		
		if (!this._hstyles)
			return;
		
		if (!this.skin_name)
			this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxgrid")||"material");
		
		this.editStop()
		/*TEMPORARY STATES*/
		this.lastClicked=null;                //row clicked without shift key. used in multiselect only
		this.resized=null;                    //hdr cell that is resized now
		this.fldSorted=this.r_fldSorted=null; //hdr cell last sorted
		//empty grid if it already was initialized
		this.cellWidthPX=[];
		this.cellWidthPC=[];
		
		if (this.hdr.rows.length > 0){
			var temp = this.xmlFileUrl;
			this.clearAll(true);
			this.xmlFileUrl = temp;
		}
		
		var hdrRow = this.hdr.insertRow(0);
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow.appendChild(document.createElement("TH"));
			hdrRow.childNodes[i]._cellIndex=i;
			hdrRow.childNodes[i].style.height="0px";
		}
		
		if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
			hdrRow.style.position="absolute";
		else
			hdrRow.style.height='auto';
		
		var hdrRow = this.hdr.insertRow(_isKHTML ? 2 : 1);
		
		hdrRow._childIndexes=new Array();
		var col_ex = 0;
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow._childIndexes[i]=i-col_ex;
			
			if ((this.hdrLabels[i] == this.splitSign)&&(i != 0)){
				if (_isKHTML)
					hdrRow.insertCell(i-col_ex);
				hdrRow.cells[i-col_ex-1].colSpan=(hdrRow.cells[i-col_ex-1].colSpan||1)+1;
				hdrRow.childNodes[i-col_ex-1]._cellIndex++;
				col_ex++;
				hdrRow._childIndexes[i]=i-col_ex;
				continue;
			}
			
			hdrRow.insertCell(i-col_ex);
			
			hdrRow.childNodes[i-col_ex]._cellIndex=i;
			hdrRow.childNodes[i-col_ex]._cellIndexS=i;
			this.setColumnLabel(i, this.hdrLabels[i]);
		}
		
		if (col_ex == 0)
			hdrRow._childIndexes=null;
		this._cCount=this.hdrLabels.length;
		
		if (_isIE)
		window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
		}, 1);
		
		//create virtual top row
		if (!this.obj.firstChild)
			this.obj.appendChild(document.createElement("TBODY"));
		
		var tar = this.obj.firstChild;
		
		if (!tar.firstChild){
			tar.appendChild(document.createElement("TR"));
			tar=tar.firstChild;
			
			if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
				tar.style.position="absolute";
			else
				tar.style.height='auto';
			
			for (var i = 0; i < this.hdrLabels.length; i++){
				tar.appendChild(document.createElement("TH"));
				tar.childNodes[i].style.height="0px";
			}
		}
		
		this._c_order=null;
		
		if (this.multiLine != true)
			this.obj.className+=" row20px";
		
		//
		//this.combos = new Array(this.hdrLabels.length);
		//set sort image to initial state
		this.sortImg.style.position="absolute";
		this.sortImg.style.display="none";
		this.sortImg.className = "dhxgrid_sort_desc";
		this.sortImg.defLeft=0;
		
		if (this.noHeader){
			this.hdrBox.style.display='none';
		}
		else {
			this.noHeader=false
		}
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if (this._ivizcol)
			this.setColHidden();
		//#}
		//#}
		//#header_footer:06042008{		
		this.attachHeader();
		this.attachHeader(0, 0, "_aFoot");
		//#}
		this.setSizes();
		
		if (fl)
			this.parseXML()
		this.obj.scrollTop=0
		
		if (this.dragAndDropOff)
			this.dragger.addDragLanding(this.entBox, this);
		
		if (this._initDrF)
			this._initD();
		
		dhx4.callEvent("onGridCreated", [this]);
	};
	
	this.setColumnSizes=function(gridWidth){
		var summ = 0;
		var fcols = []; //auto-size columns
		
		var fix = 0;
		for (var i = 0; i < this._cCount; i++){
			if ((this.initCellWidth[i] == "*") && !this._hrrar[i]){
				this._awdth=false; //disable auto-width
				fcols.push(i);
				continue;
			}
			
			if (this.cellWidthType == '%'){
				if (typeof this.cellWidthPC[i]=="undefined")
					this.cellWidthPC[i]=this.initCellWidth[i];
				var cwidth = (gridWidth*this.cellWidthPC[i]/100)||0;
				if (fix>0.5){
					cwidth++;
					fix--;
				}
				var rwidth = this.cellWidthPX[i]=Math.floor(cwidth);
				var fix =fix + cwidth - rwidth;
			} else{
				if (typeof this.cellWidthPX[i]=="undefined")
					this.cellWidthPX[i]=this.initCellWidth[i];
			}
			if (!this._hrrar[i])
				summ+=this.cellWidthPX[i]*1;
		}
		
		//auto-size columns
		if (fcols.length){
			var ms = Math.floor((gridWidth-summ)/fcols.length);
			if (ms < 0) ms=1;
			
			for (var i = 0; i < fcols.length; i++){
				var next=Math.max((this._drsclmW ? (this._drsclmW[fcols[i]]||0) : 0),ms)
				this.cellWidthPX[fcols[i]]=next;
				summ+=next;
			}
			
			if(gridWidth > summ){
				var last=fcols[fcols.length-1];
				this.cellWidthPX[last]=this.cellWidthPX[last] + (gridWidth-summ);
				summ = gridWidth;
			}
			
			this._setAutoResize();
		}
		
		
		this.obj.style.width=summ+"px";
		this.hdr.style.width=summ+"px";
		if (this.ftr) this.ftr.style.width=summ+"px";
		
		this.chngCellWidth();
		return summ;
	}
	
	/**shz)_
	*   @desc: sets sizes of grid elements
	*   @type: private
	*   @topic: 0,7
	*/
	this.setSizes=function(){
		//drop processing if grid still not initialized 
		if ((!this.hdr.rows[0])) return;
		
		var quirks=this.quirks = (_isIE && document.compatMode=="BackCompat");
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;		

		if (!this.dontSetSizes){
			if (this.globalBox){
				if (!this.globalBox.clientWidth) return;
				var ow = this.globalBox.clientWidth;
				var splitOuterBorder=(this.globalBox.offsetWidth-ow)/2;		
				if (this._delta_x && !this._realfake){
					this.globalBox.style.width=this._delta_x;
					var owu = this.globalBox.clientWidth;
					this.entBox.style.width=Math.max(0,(owu+(quirks?splitOuterBorder*2:0))-this._fake.entBox.clientWidth)+"px";
					if (owu != this._lastTimeSplitWidth){
						this._fake._correctSplit(this._fake.entBox.clientWidth);
						this._lastTimeSplitWidth = owu;
					}
				}
				if (this._delta_y && !this._realfake){
					this.globalBox.style.height = this._delta_y;
					this.entBox.style.overflow = this._fake.entBox.style.overflow="hidden";
					this.entBox.style.height = this._fake.entBox.style.height=this.globalBox.clientHeight+(quirks?splitOuterBorder*2:0)+"px";
				}
			} else {
				if (this._delta_x){
					/*when placed directly in TD tag, container can't use native percent based sizes, 
					because table auto-adjust to show all content - too clever*/
					if (this.entBox.parentNode && this.entBox.parentNode.tagName=="TD"){
						this.entBox.style.width="1px";
						this.entBox.style.width=parseInt(this._delta_x)*this.entBox.parentNode.clientWidth/100-outerBorder*2+"px";
					}else
					this.entBox.style.width=this._delta_x;
				}
				if (this._delta_y)
					this.entBox.style.height=this._delta_y;
			}
		}
		
		//if we have container without sizes, wait untill sizes defined
		window.clearTimeout(this._sizeTime);		
		if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)){
			this._sizeTime=window.setTimeout(function(){
					if (self.setSizes)
						self.setSizes();
			}, 250);
			return;
		}		
		
		var border_x = ((!this._wthB) && ((this.entBox.cmp||this._delta_x) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		var border_y = ((!this._wthB) && ((this.entBox.cmp||this._delta_y) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		
		if (this._sizeFix){
			border_x -= this._sizeFix;
			border_y -= this._sizeFix;
		}
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		
		var scrfix = dhtmlx.$customScroll?0:18;
		
		var gridWidth=this.entBox.clientWidth-(this.skin_h_correction||0)*(quirks?0:1)-border_x;
		var gridWidthActive=this.entBox.clientWidth-(this.skin_h_correction||0)-border_x;
		var gridHeight=this.entBox.clientHeight-border_y;
		var summ=this.setColumnSizes(gridWidthActive-(isVScroll?scrfix:0)-(this._correction_x||0));
		
		var isHScroll = this.parentGrid?false:((this.objBox.scrollWidth > this.objBox.offsetWidth)||(this.objBox.style.overflowX=="scroll")); 
		var headerHeight = this.hdr.clientHeight;
		var footerHeight = this.ftr?this.ftr.clientHeight:0;
		var newWidth=gridWidth;
		var newHeight=gridHeight-headerHeight-footerHeight;
		
		//if we have auto-width without limitations - ignore h-scroll
		if (this._awdth && this._awdth[0] && this._awdth[1]==99999) isHScroll=0;
		//auto-height
		if (this._ahgr){
			if (this._ahgrMA)
				newHeight=this.entBox.parentNode.clientHeight-headerHeight-footerHeight;
			else
				newHeight=this.obj.offsetHeight+(isHScroll?scrfix:0)+(this._correction_y||0);
			
			if (this._ahgrM){
				if (this._ahgrF) 
					newHeight=Math.min(this._ahgrM,newHeight+headerHeight+footerHeight)-headerHeight-footerHeight;
				else 
					newHeight=Math.min(this._ahgrM,newHeight);
				
			}
			if (isVScroll && newHeight>=this.obj.scrollHeight+(isHScroll?scrfix:0)){
				isVScroll=false;//scroll will be compensated;
				this.setColumnSizes(gridWidthActive-(this._correction_x||0)); //correct auto-size columns
			}
		}
		
		//auto-width
		if ((this._awdth)&&(this._awdth[0])){ 
			//convert percents to PX, because auto-width with procents has no sense
			if (this.cellWidthType == '%') this.cellWidthType="px";
			
			if (this._fake) summ+=this._fake.entBox.clientWidth;	//include fake grid in math
			var newWidth=Math.min(Math.max(summ+(isVScroll?scrfix:0),this._awdth[2]),this._awdth[1])+(this._correction_x||0);
			this.objBox.style.overflowX = (!isVScroll && this.objBox.scrollWidth <= newWidth)?"hidden":"auto";
			if (this._fake) newWidth-=this._fake.entBox.clientWidth;
		}
		
		newHeight=Math.max(0,newHeight);//validate value for IE
		
		//FF3.1, bug in table rendering engine
		this._ff_size_delta=(this._ff_size_delta==0.1)?0.2:0.1;
		if (!_isFF) this._ff_size_delta=0;
		
		if (!this.dontSetSizes){
			this.entBox.style.width=Math.max(0,newWidth+(quirks?2:0)*outerBorder+this._ff_size_delta)+"px";
			this.entBox.style.height=newHeight+(quirks?2:0)*outerBorder+headerHeight+footerHeight+"px";
		}
		this.objBox.style.height=newHeight+((quirks&&!isVScroll)?2:0)*outerBorder+"px";//):this.entBox.style.height);
		this.hdrBox.style.height=headerHeight+"px";		
		
		
		if (newHeight != gridHeight)
			this.doOnScroll(0, !this._srnd);
		var ext=this["setSizes_"+this.skin_name];
		if (ext) ext.call(this);
		
		this.setSortImgPos();	
		
		//it possible that changes of size, has changed header height 
		if (headerHeight != this.hdr.clientHeight && this._ahgr) 	
			this.setSizes();
		this.callEvent("onSetSizes",[]);
	};
	/**
	*   @desc: changes cell width
	*   @param: [ind] - index of row in grid
	*   @type: private
	*   @topic: 4,7
	*/
	this.chngCellWidth=function(){
		if ((_isOpera)&&(this.ftr))
			this.ftr.width=this.objBox.scrollWidth+"px";
		var l = this._cCount;
		
		for (var i = 0; i < l; i++){
			this.hdr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
			this.obj.rows[0].childNodes[i].style.width=this.cellWidthPX[i]+"px";
			
			if (this.ftr)
				this.ftr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
		}
	}
	/**
	*   @desc: set delimiter character used in list values (default is ",")
	*   @param: delim - delimiter as string
	*   @before_init: 1
	*   @type: public
	*   @topic: 0
	*/
	this.setDelimiter=function(delim){
		this.delim=delim;
	}
	/**
	*   @desc: set width of columns in percents
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in percents
	*   @topic: 0,7
	*/
	this.setInitWidthsP=function(wp){
		this.cellWidthType="%";
		this.initCellWidth=wp.split(this.delim.replace(/px/gi, ""));
		if (!arguments[1]) this._setAutoResize();
	}
	/**
	*	@desc:
	*	@type: private
	*	@topic: 0
	*/
	this._setAutoResize=function(){
		if (this._realfake) return;
		var el = window;
		var self = this;
		
		dhtmlxEvent(window,"resize",function(){
				window.clearTimeout(self._resize_timer);
				if (self._setAutoResize)
				self._resize_timer=window.setTimeout(function(){
						if (self.setSizes)
							self.setSizes();
						if (self._fake)
							self._fake._correctSplit();
				}, 100);
		});

		//prevent multiple initializations
		this._setAutoResize = function(){};
	}
	
	
	/**
	*   @desc: set width of columns in pixels
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in pixels
	*   @topic: 0,7
	*/
	this.setInitWidths=function(wp){
		this.cellWidthType="px";
		this.initCellWidth=wp.split(this.delim);
		
		if (_isFF){
			for (var i = 0; i < this.initCellWidth.length; i++)
				if (this.initCellWidth[i] != "*")
				this.initCellWidth[i]=parseInt(this.initCellWidth[i]);
		}
	}
	
	/**
	*   @desc: set multiline rows support to enabled or disabled state
	*   @type: public
	*   @before_init: 1
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiline=function(state){
		this.multiLine=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set multiselect mode to enabled or disabled state
	*   @type: public
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiselect=function(state){
		this.selMultiRows=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set path to grid internal images (sort direction, any images used in editors, checkbox, radiobutton)
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setImagePath=function(path){
		path = path.replace(/imgs\/dhxgrid_[a-z]*\/$/,"imgs/");
		this._imgURL= path;
		this.imgURL = path + "dhxgrid_"+(this.skin_name || "dhx_skyblue").replace("dhx_", "") + "/";
		this.iconTree = this.imgURL + "tree/";
	}
	this.setImagesPath=this.setImagePath;
	/**
	*   @desc: set path to external images used in grid ( tree and img column types )
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setIconPath=function(path){
		this.iconURL=path;
	}	
	this.setIconsPath=this.setIconPath;
	//#column_resize:06042008{
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.changeCursorState=function(ev){
		var el = ev.target||ev.srcElement;
		
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		if (!el) return;
		if ((el.tagName == "TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
			return el.style.cursor="default";
		var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
		if ((el.offsetWidth-(ev.offsetX||(parseInt(this.getPosition(el, this.hdrBox))-check)*-1)) < (_isOpera?20:10)){
			el.style.cursor="E-resize";
		}
		else{
			el.style.cursor="default";
		}
		
		if (_isOpera)
			this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.startColResize=function(ev){
		if (this.resized) this.stopColResize();
		this.resized=null;
		var el = ev.target||ev.srcElement;
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		var x = ev.clientX;
		var tabW = this.hdr.offsetWidth;
		var startW = parseInt(el.offsetWidth)
		
		if (el.tagName == "TD"&&el.style.cursor != "default"){
			if ((this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
				return;
			
			self._old_d_mm=document.body.onmousemove;
			self._old_d_mu=document.body.onmouseup;
			document.body.onmousemove=function(e){
				if (self)
					self.doColResize(e||window.event, el, startW, x, tabW)
			}
			document.body.onmouseup=function(){
				if (self)
					self.stopColResize();
			}
		}
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.stopColResize=function(){ 
		document.body.onmousemove=self._old_d_mm||"";
		document.body.onmouseup=self._old_d_mu||"";
		this.setSizes();
		this.doOnScroll(0, 1)
		this.callEvent("onResizeEnd", [this]);
	}
	/**
	*   @desc: part of column resize routine
	*   @param: el - element (column resizing)
	*   @param: startW - started width
	*   @param: x - x coordinate to resize from
	*   @param: tabW - started width of header table
	*   @type: private
	*   @topic: 3
	*/
	this.doColResize=function(ev, el, startW, x, tabW){
		el.style.cursor="E-resize";
		this.resized=el;
		var fcolW = startW+(ev.clientX-x);
		var wtabW = tabW+(ev.clientX-x)
		
		if (!(this.callEvent("onResize", [
				el._cellIndex,
			fcolW,
			this
		])))
		return;
		
		if (_isIE)
			this.objBox.scrollLeft=this.hdrBox.scrollLeft;
		
		var result = false;
		if (el.colSpan > 1){
			var a_sizes = new Array();
			
			for (var i = 0;
				i < el.colSpan;
				i++)a_sizes[i]=Math.round(fcolW*this.hdr.rows[0].childNodes[el._cellIndexS+i].offsetWidth/el.offsetWidth);
				
				for (var i = 0; i < el.colSpan; i++)
					result = this._setColumnSizeR(el._cellIndexS+i*1, a_sizes[i]);
		} else
		result = this._setColumnSizeR(el._cellIndex, fcolW);
		this.doOnScroll(0, 1);
		
		this.setSizes();
		if (this._fake && this._awdth) this._fake._correctSplit();
		
		return result;
	}
	
	/**
	*   @desc: set width of grid columns ( zero row of header and body )
	*   @type: private
	*   @topic: 7
	*/
	this._setColumnSizeR=function(ind, fcolW){
		if (fcolW > ((this._drsclmW&&!this._notresize) ? (this._drsclmW[ind]||10) : 10)){
			this.obj.rows[0].childNodes[ind].style.width=fcolW+"px";
			this.hdr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.ftr)
				this.ftr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.cellWidthType == 'px'){
				this.cellWidthPX[ind]=fcolW;
			}
			else {
				var gridWidth = parseInt(this.entBox.offsetWidth);
				
				if (this.objBox.scrollHeight > this.objBox.offsetHeight)
					gridWidth-=17;
				var pcWidth = Math.round(fcolW / gridWidth*100)
				this.cellWidthPC[ind]=pcWidth;
			}
			if (this.sortImg.style.display!="none")
				this.setSortImgPos();
		} else return false;
	}
	//#}
	//#sorting:06042008{
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: state - true/false - show/hide image
	*    @param: ind - index of field
	*    @param: order - asc/desc - type of image
	*    @param: row - one based index of header row ( used in multirow headers, top row by default )
	*   @type: public
	*   @topic: 7
	*/
	this.setSortImgState=function(state, ind, order, row){
		order=(order||"asc").toLowerCase();
		
		if (!dhx4.s2b(state)){
			this.sortImg.style.display="none";
			if (this.r_fldSorted)
				this.r_fldSorted.className = "";
			this.fldSorted=this.r_fldSorted = null;
			return;
		}
		
		if (order == "asc")
			this.sortImg.className = "dhxgrid_sort_asc";
		else
			this.sortImg.className = "dhxgrid_sort_desc";
		
		this.sortImg.style.display="";
		this.fldSorted=this.hdr.rows[0].childNodes[ind];
		var r = this.hdr.rows[row||1];
		if (!r) return;
		
		for (var i = 0; i < r.childNodes.length; i++){
			if (r.childNodes[i]._cellIndexS == ind){
				this.r_fldSorted=r.childNodes[i];
				return  this.setSortImgPos();
			}
		}
		return this.setSortImgState(state,ind,order,(row||1)+1);
	}
	
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: ind - index of field
	*    @param: ind - index of field
	*    @param: hRowInd - index of row in case of complex header, one-based, optional
	
	*   @type: private
	*   @topic: 7
	*/
	this.setSortImgPos=function(ind, mode, hRowInd, el){
		if (this._hrrar && this._hrrar[this.r_fldSorted?this.r_fldSorted._cellIndex:ind]) return;
		if (this.ar_fldSorted)
			this.ar_fldSorted.className = "";

		if (!el){
			if (!ind)
				var el = this.r_fldSorted;
			else
				var el = this.hdr.rows[hRowInd||0].cells[ind];
		}
		
		if (el != null){
			var pos = this.getPosition(el, this.hdrBox)
			var wdth = el.offsetWidth;
			this.ar_fldSorted = el;
			el.className = this.sortImg.className+"_col";

			this.sortImg.style.left=Number(pos[0]+wdth-13)+"px"; //Number(pos[0]+5)+"px";
			this.sortImg.defLeft=parseInt(this.sortImg.style.left)
			this.sortImg.style.top=Number(pos[1]+5)+"px";
			
			if ((!this.useImagesInHeader)&&(!mode))
				this.sortImg.style.display="inline";
			this.sortImg.style.left=this.sortImg.defLeft+"px"; //-parseInt(this.hdrBox.scrollLeft)
		}
	}
	//#}
	/**
	*   @desc: manage activity of the grid.
	*   @param: fl - true to activate,false to deactivate
	*   @type: private
	*   @topic: 1,7
	*/
	this.setActive=function(fl){
		if (arguments.length == 0)
			var fl = true;
		
		if (fl == true){
			//document.body.onkeydown = new Function("","document.getElementById('"+this.entBox.id+"').grid.doKey()")//
			if (globalActiveDHTMLGridObject&&(globalActiveDHTMLGridObject != this)){
				globalActiveDHTMLGridObject.editStop();
				globalActiveDHTMLGridObject.callEvent("onBlur",[globalActiveDHTMLGridObject]);
			}
			
			globalActiveDHTMLGridObject=this;
			this.isActive=true;
		} else {
			this.isActive=false;
			this.callEvent("onBlur",[this]);
		}
	};
	/**
	*     @desc: called on click occured
	*     @type: private
	*/
	this._doClick=function(ev){
		var selMethod = 0;
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		if (!el || !el.parentNode || !el.parentNode.idd) return;
		var fl = true;
		
		//mm
		//markers start
		if (this.markedCells){
			var markMethod = 0;
			
			if (ev.shiftKey||ev.metaKey){
				markMethod=1;
			}
			
			if (ev.ctrlKey){
				markMethod=2;
			}
			this.doMark(el, markMethod);
			return true;
		}
		//markers end
		//mm
		
		if (this.selMultiRows != false){
			if (ev.shiftKey && this.row != null && this.selectedRows.length){
				selMethod=1;
			}
			
			if (ev.ctrlKey||ev.metaKey){
				selMethod=2;
			}
		}
		return this.doClick(el, fl, selMethod, false)
	};
	
	//#context_menu:06042008{
	/**
	*   @desc: called onmousedown inside grid area
	*   @type: private
	*/
	this._doContClick=function(ev){ 
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if ((!el)||( typeof (el.parentNode.idd) == "undefined")){
			this.callEvent("onEmptyClick", [ev]);
			return true;
		}
		
		if (ev.button == 2||(_isMacOS&&ev.ctrlKey)){
			if (!this.callEvent("onRightClick", [
					el.parentNode.idd,
				el._cellIndex,
				ev
			])){
			var z = function(e){
				(e||event).cancelBubble=true;
				return false;
			};
			
			(ev.srcElement||ev.target).oncontextmenu=z;
			return z(ev);
			}
			
			if (this._ctmndx){
				if (!(this.callEvent("onBeforeContextMenu", [
						el.parentNode.idd,
					el._cellIndex,
					this
				])))
				return true;
				
				if (_isIE)
				ev.srcElement.oncontextmenu=function(){
					event.cancelBubble=true;
					return false;
				};
				
				if (this._ctmndx.showContextMenu){
					
					var dEl0=window.document.documentElement;
					var dEl1=window.document.body;
					var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
					if (_isIE){
						var x= ev.clientX+corrector[0];
						var y = ev.clientY+corrector[1];
					} else {
						var x= ev.pageX;
						var y = ev.pageY;
					}
					this._ctmndx.showContextMenu(x-1,y-1)
					this.contextID=this._ctmndx.contextMenuZoneId=el.parentNode.idd+"_"+el._cellIndex;
					this._ctmndx._skip_hide=true;
				} else {
					el.contextMenuId=el.parentNode.idd+"_"+el._cellIndex;
					el.contextMenu=this._ctmndx;
					el.a=this._ctmndx._contextStart;
					el.a(el, ev);
					el.a=null;
				}
				ev.cancelBubble=true;
				return false;
			}
		}
		
		else if (this._ctmndx){
			if (this._ctmndx.hideContextMenu)
				this._ctmndx.hideContextMenu()
			else
				this._ctmndx._contextEnd();
		}
		return true;
	}
	//#}
	/**
	*    @desc: occures on cell click (supports treegrid)
	*   @param: [el] - cell to click on
	*   @param:   [fl] - true if to call onRowSelect function
	*   @param: [selMethod] - 0 - simple click, 1 - shift, 2 - ctrl
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: private
	*   @topic: 1,2,4,9
	*/
	this.doClick=function(el, fl, selMethod, show){
		if (!this.selMultiRows) selMethod=0; //block programmatical multiselecton if mode not enabled explitly
		var psid = this.row ? this.row.idd : 0;
		
		this.setActive(true);
		
		if (!selMethod)
			selMethod=0;
		
		if (this.cell != null)
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
		
		if (el.tagName == "TD"){
			if (this.checkEvent("onSelectStateChanged"))
				var initial = this.getSelectedId();
			var prow = this.row;
			if (selMethod == 1){
				var elRowIndex = this.rowsCol._dhx_find(el.parentNode)
				var lcRowIndex = this.rowsCol._dhx_find(this.lastClicked)
				
				if (elRowIndex > lcRowIndex){
					var strt = lcRowIndex;
					var end = elRowIndex;
				} else {
					var strt = elRowIndex;
					var end = lcRowIndex;
				}
				
				for (var i = 0; i < this.rowsCol.length; i++)
				if ((i >= strt&&i <= end)){
					if (this.rowsCol[i]&&(!this.rowsCol[i]._sRow)){
						if (!this.rowsCol[i].idd) continue;
						if (this.rowsCol[i].className.indexOf("rowselected")
							== -1&& (this.callEvent("onBeforeSelect", [
									this.rowsCol[i].idd,
									psid,
									el._cellIndex
							]))){
						this.rowsCol[i].className+=" rowselected";
						this.selectedRows[this.selectedRows.length]=this.rowsCol[i]
							}
					} else {
						this.clearSelection();
						return this.doClick(el, fl, 0, show);
					}
				}
			} else if (selMethod == 2){
				if (el.parentNode.className.indexOf("rowselected") != -1){
					el.parentNode.className=el.parentNode.className.replace(/rowselected/g, "");
					this.selectedRows._dhx_removeAt(this.selectedRows._dhx_find(el.parentNode))
					var skipRowSelection = true;
					show = false;
				}
			}
			this.editStop()
			if (typeof (el.parentNode.idd) == "undefined")
				return true;
			
			if ((!skipRowSelection)&&(!el.parentNode._sRow)){
				if (this.callEvent("onBeforeSelect", [
						el.parentNode.idd,
					psid,
					el._cellIndex
				])){
				if (this.getSelectedRowId() != el.parentNode.idd){
					if (selMethod == 0)
						this.clearSelection();
					this.cell=el;
					if ((prow == el.parentNode)&&(this._chRRS))
						fl=false;
					this.row=el.parentNode;
					this.row.className+=" rowselected"
					
					if (this.selectedRows._dhx_find(this.row) == -1)
						this.selectedRows[this.selectedRows.length]=this.row;
				} else {
					this.cell=el;
					this.row = el.parentNode;
				}
				} else fl = false;
			}
			
			if (this.cell && this.cell.parentNode.className.indexOf("rowselected") != -1)
				this.cell.className=this.cell.className.replace(/cellselected/g, "")+" cellselected";
			
			if (selMethod != 1)
				if (!this.row)
				return;
			this.lastClicked=el.parentNode;
			
			var rid = this.row.idd;
			var cid = this.cell;
			
			if (fl&& typeof (rid) != "undefined" && cid && !skipRowSelection) {
				self.onRowSelectTime=setTimeout(function(){
						if (self.callEvent)
						self.callEvent("onRowSelect", [
								rid,
								cid._cellIndex
						]);
				}, 100);
			} else this.callEvent("onRowSelectRSOnly",[rid]);
			
			if (this.checkEvent("onSelectStateChanged")){
				var afinal = this.getSelectedId();
				
				if (initial != afinal)
					this.callEvent("onSelectStateChanged", [afinal,initial]);
			}
			
			if (skipRowSelection) return false;
		}
		this.isActive=true;
		if (show !== false && this.cell && this.cell.parentNode.idd)
			this.moveToVisible(this.cell)
	}
	
	/**
	*   @desc: select all rows in grid, it doesn't fire any events
	*   @param: edit - switch selected cell to edit mode
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectAll=function(){
		this.clearSelection();
		
		var coll = this.rowsBuffer;
		//in paging mode, we select only current page
		if (this.pagingOn) coll = this.rowsCol;
		for (var i = 0; i<coll.length; i ++){
			this.render_row(i).className+=" rowselected";
		}
		
		this.selectedRows=dhtmlxArray([].concat(coll));
		
		if (this.selectedRows.length){
			this.row  = this.selectedRows[0];
			this.cell = this.row.cells[0];
		}
		
		if ((this._fake)&&(!this._realfake))
			this._fake.selectAll();
	}
	/**
	*   @desc: set selection to specified row-cell
	*   @param: r - row object or row index
	*   @param: cInd - cell index
	*   @param: [fl] - true if to call onRowSelect function
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: edit - switch selected cell to edit mode
	*   @param: show - true/false - scroll row to view, true by defaul         
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectCell=function(r, cInd, fl, preserve, edit, show){
		if (!fl)
			fl=false;
		
		if (typeof (r) != "object")
			r=this.render_row(r)
		if (!r || r==-1) return null;
		//#__pro_feature:21092006{
		//#colspan:20092006{
		if (r._childIndexes)
			var c = r.childNodes[r._childIndexes[cInd]];
		else
			//#}
		//#}
		var c = r.childNodes[cInd];
		
		if (!c)
			c=r.childNodes[0];
		if(!this.markedCells){
			if (preserve)
				this.doClick(c, fl, 3, show)
			else
				this.doClick(c, fl, 0, show)
		}
		else 
			this.doMark(c,preserve?2:0);
		
		if (edit)
			this.editCell();
	}
	/**
	*   @desc: moves specified cell to visible area (scrolls)
	*   @param: cell_obj - object of the cell to work with
	*   @param: onlyVScroll - allow only vertical positioning
	
	*   @type: private
	*   @topic: 2,4,7
	*/
	this.moveToVisible=function(cell_obj, onlyVScroll){
		if (this.pagingOn){
			var newPage=Math.floor(this.getRowIndex(cell_obj.parentNode.idd) / this.rowsBufferOutSize)+1;
			if (newPage!=this.currentPage)
				this.changePage(newPage);
		}
		
		try{
			if (cell_obj.offsetHeight){
				var distance = cell_obj.offsetLeft+cell_obj.offsetWidth+20;
				
				var scrollLeft = 0;
				
				if (distance > (this.objBox.offsetWidth+this.objBox.scrollLeft)){
					if (cell_obj.offsetLeft > this.objBox.scrollLeft)
						scrollLeft= cell_obj.offsetLeft - (this.objBox.offsetWidth - cell_obj.offsetWidth) +5
				} else if (cell_obj.offsetLeft < this.objBox.scrollLeft){
					distance-=cell_obj.offsetWidth*2/3;
					if (distance < this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				}
				
				if ((scrollLeft)&&(!onlyVScroll))
					this.objBox.scrollLeft=scrollLeft;
			}
			
			
			if (!cell_obj.offsetHeight){
				var mask=this._realfake?this._fake.rowsAr[cell_obj.parentNode.idd]:cell_obj.parentNode;
				distance = this.rowsBuffer._dhx_find(mask)*this._srdh;
			}
			else
				distance = cell_obj.offsetTop;
			var distancemax = distance + cell_obj.offsetHeight+38;
			
			if (distancemax > (this.objBox.offsetHeight+this.objBox.scrollTop)){
				var scrollTop = distance;
			} else if (distance < this.objBox.scrollTop){
				var scrollTop = distance-5
			}
			
			if (scrollTop)
				this.objBox.scrollTop=scrollTop;
		}
		catch (er){}
	}
	/**
	*   @desc: creates Editor object and switch cell to edit mode if allowed
	*   @type: public
	*   @topic: 4
	*/
	this.editCell = function(){
		if (this.editor&&this.cell == this.editor.cell)
			return; //prevent reinit for same cell
		
		this.editStop();
		
		if ((this.isEditable != true)||(!this.cell))
			return false;
		var c = this.cell;
		
		//#locked_row:11052006{
		if (c.parentNode._locked)
			return false;
		//#}
		
		this.editor=this.cells4(c);
		
		//initialize editor
		if (this.editor != null){
			if (this.editor.isDisabled()){
				this.editor=null;
				return false;
			}
			
			if (this.callEvent("onEditCell", [
					0,
				this.row.idd,
				this.cell._cellIndex
			]) != false&&this.editor.edit){
			this._Opera_stop=(new Date).valueOf();
			c.className += " editable";
			this.editor.edit();
			this.callEvent("onEditCell", [
					1,
					this.row.idd,
					this.cell._cellIndex
			])
			} else { //preserve editing
				this.editor=null;
			}
		}
	}
	/**
	*   @desc: retuns value from editor(if presents) to cell and closes editor
	*   @mode: if true - current edit value will be reverted to previous one
	*   @type: public
	*   @topic: 4
	*/
	this.editStop=function(mode){
		if (_isOpera)
		if (this._Opera_stop){
			if ((this._Opera_stop*1+50) > (new Date).valueOf())
				return;
			
			this._Opera_stop=null;
		}
		
		if (this.editor&&this.editor != null){
			this.editor.cell.className=this.editor.cell.className.replace("editable", "");
			
			if (mode){
				var t = this.editor.val;
				this.editor.detach();
				this.editor.setValue(t);
				this.editor=null;
				
				this.callEvent("onEditCancel", [
						this.row.idd,
						this.cell._cellIndex,
						t
				]);
				return;
			}
			
			if (this.editor.detach())
				this.cell.wasChanged=true;
			
			var g = this.editor;
			if (g == null) return;
			
			this.editor=null;
			var z = this.callEvent("onEditCell", [
					2,
					this.row.idd,
					this.cell._cellIndex,
					g.getValue(),
					g.val
			]);
			
			if (( typeof (z) == "string")||( typeof (z) == "number"))
				g[g.setImage ? "setLabel" : "setValue"](z);
			
			else if (!z)
				g[g.setImage ? "setLabel" : "setValue"](g.val);
			
			if (this._ahgr && this.multiLine) this.setSizes();
		}
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRowCell=function(row, dir, pos){
		row=this._nextRow((this._groups?this.rowsCol:this.rowsBuffer)._dhx_find(row), dir);
		
		if (!row)
			return null;
		
		return row.childNodes[row._childIndexes ? row._childIndexes[pos] : pos];
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._getNextCell=function(acell, dir, i){
		
		acell=acell||this.cell;
		
		var arow = acell.parentNode;
		
		if (this._tabOrder){
			i=this._tabOrder[acell._cellIndex];
			
			if (typeof i != "undefined")
				if (i < 0)
				acell=this._nextRowCell(arow, dir, Math.abs(i)-1);
			else
				acell=arow.childNodes[i];
		} else {
			var i = acell._cellIndex+dir;
			
			if (i >= 0&&i < this._cCount){
				if (arow._childIndexes)
					i=arow._childIndexes[acell._cellIndex]+dir;
				acell=arow.childNodes[i];
			} else {
				
				acell=this._nextRowCell(arow, dir, (dir == 1 ? 0 : (this._cCount-1)));
			}
		}
		
		if (!acell){
			if ((dir == 1)&&this.tabEnd){
				this.tabEnd.focus();
				this.tabEnd.focus();
				this.setActive(false);
			}
			
			if ((dir == -1)&&this.tabStart){
				this.tabStart.focus();
				this.tabStart.focus();
				this.setActive(false);
			}
			return null;
		}
		
		//tab out
		
		// tab readonly
		if (acell.style.display != "none"
			&&(!this.smartTabOrder||!this.cells(acell.parentNode.idd, acell._cellIndex).isDisabled()))
		return acell;
		return this._getNextCell(acell, dir);
		// tab readonly
		
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRow=function(ind, dir){
		var r = this.render_row(ind+dir);
		if (!r || r==-1) return null;
		if (r&&r.style.display == "none")
			return this._nextRow(ind+dir, dir);
		
		return r;
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this.scrollPage=function(dir){ 
		if (!this.rowsBuffer.length) return;
		var master = this._realfake?this._fake:this;
		var new_ind = Math.floor((master._r_select||this.getRowIndex(this.row.idd)||0)+(dir)*this.objBox.offsetHeight / (this._srdh||20));
		
		if (new_ind < 0)
			new_ind=0;
		if (new_ind >= this.rowsBuffer.length)
			new_ind=this.rowsBuffer.length-1;
		
		if (this._srnd && !this.rowsBuffer[new_ind]){			
			this.objBox.scrollTop+=Math.floor((dir)*this.objBox.offsetHeight / (this._srdh||20))*(this._srdh||20);
			if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			master._r_select=new_ind;
		} else {
			this.selectCell(new_ind, this.cell._cellIndex, true, false,false,(this.multiLine || this._srnd));
			if (!this.multiLine && !this._srnd && !this._realfake){
				this.objBox.scrollTop=this.getRowById(this.getRowId(new_ind)).offsetTop;
				if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			}
			master._r_select=null;
		}
	}
	
	/**
	*   @desc: manages keybord activity in grid
	*   @type: private
	*   @topic: 7
	*/
	this.doKey=function(ev){
		if (!ev)
			return true;
		
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);
			
			if (zx.className!="dhxcombo_input"&&((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1)))
				return true;
		}
		
		if ((globalActiveDHTMLGridObject)&&(this != globalActiveDHTMLGridObject))
			return globalActiveDHTMLGridObject.doKey(ev);
		
		if (this.isActive == false){
			//document.body.onkeydown = "";
			return true;
		}
		
		if (this._htkebl)
			return true;
		
		if (!this.callEvent("onKeyPress", [
				ev.keyCode,
			ev.ctrlKey,
			ev.shiftKey,
			ev
		]))
		return false;
		
		var code = "k"+ev.keyCode+"_"+(ev.ctrlKey ? 1 : 0)+"_"+(ev.shiftKey ? 1 : 0);
		
		if (this.cell){ //if selection exists in grid only
			if (this._key_events[code]){
				if (false === this._key_events[code].call(this))
					return true;
				
				if (ev.preventDefault)
					ev.preventDefault();
				ev.cancelBubble=true;
				return false;
			}
			
			if (this._key_events["k_other"])
				this._key_events.k_other.call(this, ev);
		}
		
		return true;
	}
	
	/**
	*   @desc: selects row (and first cell of it)
	*   @param: r - row index or row object
	*   @param: fl - if true, then call function on select
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRow=function(r, fl, preserve, show){
		if (typeof (r) != 'object')
			r=this.render_row(r);
		this.selectCell(r, 0, fl, preserve, false, show)
	};
	
	/**
	*   @desc: called when row was double clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this.wasDblClicked=function(ev){
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if (el){
			var rowId = el.parentNode.idd;
			return this.callEvent("onRowDblClicked", [
					rowId,
					el._cellIndex,
					ev
			]);
		}
	}
	
	/**
	*   @desc: called when header was clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this._onHeaderClick=function(e, el){
		var that = this.grid;
		el=el||that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (this.grid.resized == null){
			if (!(this.grid.callEvent("onHeaderClick", [
					el._cellIndexS,
				(e||window.event)
			])))
			return false;
			//#sorting:06042008{				
			that.sortField(el._cellIndexS, false, el)
			//#}
		}
		this.grid.resized = null;
	}
	
	/**
	*   @desc: deletes selected row(s)
	*   @type: public
	*   @topic: 2
	*/
	this.deleteSelectedRows=function(){
		var num = this.selectedRows.length //this.obj.rows.length
		
		if (num == 0)
			return;
		
		var tmpAr = this.selectedRows;
		this.selectedRows=dhtmlxArray()
		for (var i = num-1; i >= 0; i--){
			var node = tmpAr[i]
			
			if (!this.deleteRow(node.idd, node)){
				this.selectedRows[this.selectedRows.length]=node;
			}
			else {
				if (node == this.row){
					var ind = i;
				}
			}
			/*
			this.rowsAr[node.idd] = null;
			var posInCol = this.rowsCol._dhx_find(node)
			this.rowsCol[posInCol].parentNode.removeChild(this.rowsCol[posInCol]);//nb:this.rowsCol[posInCol].removeNode(true);
			this.rowsCol._dhx_removeAt(posInCol)*/
		}
		
		if (ind){
			try{
				if (ind+1 > this.rowsCol.length) //this.obj.rows.length)
					ind--;
				this.selectCell(ind, 0, true)
			}
			catch (er){
				this.row=null
				this.cell=null
			}
		}
	}
	
	/**
	*   @desc: gets selected row id
	*   @returns: id of selected row (list of ids with default delimiter) or null if non row selected
	*   @type: public
	*   @topic: 1,2,9
	*/
	this.getSelectedRowId=function(){
		var selAr = new Array(0);
		var uni = {
		};
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var id = this.selectedRows[i].idd;
			
			if (uni[id])
				continue;
			
			selAr[selAr.length]=id;
			uni[id]=true;
		}
		
		//..
		if (selAr.length == 0)
			return null;
		else
			return selAr.join(this.delim);
	}
	
	/**
	*   @desc: gets index of selected cell
	*   @returns: index of selected cell or -1 if there is no selected sell
	*   @type: public
	*   @topic: 1,4
	*/
	this.getSelectedCellIndex=function(){
		if (this.cell != null)
			return this.cell._cellIndex;
		else
			return -1;
	}
	/**
	*   @desc: gets width of specified column in pixels
	*   @param: ind - column index
	*   @returns: column width in pixels
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColWidth=function(ind){
		return parseInt(this.cellWidthPX[ind]);
	}
	
	/**
	*   @desc: sets width of specified column in pixels (soen't works with procent based grid)
	*   @param: ind - column index
	*   @param: value - new width value
	*   @type: public
	*   @topic: 3,7
	*/
	this.setColWidth=function(ind, value){
		if (value == "*")
			this.initCellWidth[ind] = "*";
		else {
			if (this._hrrar[ind]) return; //hidden
			if (this.cellWidthType == 'px')
				this.cellWidthPX[ind]=parseInt(value);
			else
				this.cellWidthPC[ind]=parseInt(value);
		}
		this.setSizes();
	}
	/**
	*   @desc: gets row index by id (grid only)
	*   @param: row_id - row id
	*   @returns: row index or -1 if there is no row with specified id
	*   @type: public
	*   @topic: 2
	*/
	this.getRowIndex=function(row_id){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id)
			return i;
		return -1;
	}
	/**
	*   @desc: gets row id by index
	*   @param: ind - row index
	*   @returns: row id or null if there is no row with specified index
	*   @type: public
	*   @topic: 2
	*/
	this.getRowId=function(ind){
		return this.rowsBuffer[ind] ? this.rowsBuffer[ind].idd : this.undefined;
	}
	/**
	*   @desc: sets new id for row by its index
	*   @param: ind - row index
	*   @param: row_id - new row id
	*   @type: public
	*   @topic: 2
	*/
	this.setRowId=function(ind, row_id){
		this.changeRowId(this.getRowId(ind), row_id)
	}
	/**
	*   @desc: changes id of the row to the new one
	*   @param: oldRowId - row id to change
	*   @param: newRowId - row id to set
	*   @type:public
	*   @topic: 2
	*/
	this.changeRowId=function(oldRowId, newRowId){
		if (oldRowId == newRowId)
			return;
		/*
		for (var i=0; i<row.childNodes.length; i++)
		if (row.childNodes[i]._code)
		this._compileSCL("-",row.childNodes[i]);      */
		var row = this.rowsAr[oldRowId]
		row.idd=newRowId;
		
		if (this.UserData[oldRowId]){
			this.UserData[newRowId]=this.UserData[oldRowId]
			this.UserData[oldRowId]=null;
		}
		
		if (this._h2&&this._h2.get[oldRowId]){
			this._h2.get[newRowId]=this._h2.get[oldRowId];
			this._h2.get[newRowId].id=newRowId;
			delete this._h2.get[oldRowId];
		}
		
		this.rowsAr[oldRowId]=null;
		this.rowsAr[newRowId]=row;
		
		for (var i = 0; i < row.childNodes.length; i++)
			if (row.childNodes[i]._code)
			row.childNodes[i]._code=this._compileSCL(row.childNodes[i]._val, row.childNodes[i]);
		
		if (this._mat_links && this._mat_links[oldRowId]){
			var a=this._mat_links[oldRowId];
			delete this._mat_links[oldRowId];
			for (var c in a)
				for (var i=0; i < a[c].length; i++)
				this._compileSCL(a[c][i].original,a[c][i]);
		}
		
		this.callEvent("onRowIdChange",[oldRowId,newRowId]);
	}
	/**
	*   @desc: sets ids to every column. Can be used then to retreive the index of the desired colum
	*   @param: [ids] - delimitered list of ids (default delimiter is ","), or empty if to use values set earlier
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnIds=function(ids){
		this.columnIds=ids.split(this.delim)
	}
	/**
	*   @desc: sets ids to specified column.
	*   @param: ind- index of column
	*   @param: id- id of column
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnId=function(ind, id){
		this.columnIds[ind]=id;
	}
	/**
	*   @desc: gets column index by column id
	*   @param: id - column id
	*   @returns: index of the column
	*   @type: public
	*   @topic: 3
	*/
	this.getColIndexById=function(id){
		for (var i = 0; i < this.columnIds.length; i++)
			if (this.columnIds[i] == id)
			return i;
	}
	/**
	*   @desc: gets column id of column specified by index
	*   @param: cin - column index
	*   @returns: column id
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnId=function(cin){
		return this.columnIds[cin];
	}
	
	/**
	*   @desc: gets label of column specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnLabel=function(cin, ind, hdr, raw){
		var z = (hdr||this.hdr).rows[(ind||0)+1];
		for (var i=0; i<z.cells.length; i++)
			if (z.cells[i]._cellIndexS==cin) return raw ? z.cells[i].firstChild.innerHTML : (_isIE ? z.cells[i].innerText : z.cells[i].textContent);
		return "";
	};
	this.getColLabel = this.getColumnLabel;
	/**
	*   @desc: gets label of footer specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getFooterLabel=function(cin, ind, raw){
		return this.getColumnLabel(cin,ind,this.ftr, raw);
	}
	
	
	/**
	*   @desc: sets row text BOLD
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextBold=function(row_id){
		var r=this.getRowById(row_id)
		if (r) r.style.fontWeight="bold";
	}
	/**
	*   @desc: sets style to row
	*   @param: row_id - row id
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextStyle=function(row_id, styleString){
		var r = this.getRowById(row_id)
		if (!r) return;
		for (var i = 0; i < r.childNodes.length; i++){
			var pfix = r.childNodes[i]._attrs["style"]||"";
			//#__pro_feature:21092006{
			//#column_hidden:21092006{
			if ((this._hrrar)&&(this._hrrar[i]))
				pfix="display:none;";
			//#}
			//#}
			if (_isIE)
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
			else
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
		}
	}
	/**
	*   @desc: sets background color of row (via bgcolor attribute)
	*   @param: row_id - row id
	*   @param: color - color value
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowColor=function(row_id, color){
		var r = this.getRowById(row_id)
		
		for (var i = 0; i < r.childNodes.length; i++)r.childNodes[i].bgColor=color;
	}
	/**
	*   @desc: sets style to cell
	*   @param: row_id - row id
	*   @param: ind - cell index
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setCellTextStyle=function(row_id, ind, styleString){
		var r = this.getRowById(row_id)
		
		if (!r)
			return;
		
		var cell = r.childNodes[r._childIndexes ? r._childIndexes[ind] : ind];
		
		if (!cell)
			return;
		var pfix = "";
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if ((this._hrrar)&&(this._hrrar[ind]))
			pfix="display:none;";
		//#}
		//#}
		if (_isIE)
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
		else
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
	}
	
	/**
	*   @desc: sets row text weight to normal
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextNormal=function(row_id){
		var r=this.getRowById(row_id);
		if (r) r.style.fontWeight="normal";
	}
	/**
	*   @desc: determines if row with specified id exists
	*   @param: row_id - row id
	*   @returns: true if exists, false otherwise
	*   @type: public
	*   @topic: 2,7
	*/
	this.doesRowExist=function(row_id){
		if (this.getRowById(row_id) != null)
			return true
		else
			return false
	}
	
	
	
	/**
	*   @desc: gets number of columns in grid
	*   @returns: number of columns in grid
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColumnsNum=function(){
		return this._cCount;
	}
	
	
	//#moving_rows:06042008{
	/**
	*   @desc: moves row one position up if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowUp=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, -1);
		
		var rInd = this.rowsCol._dhx_find(r)
		if ((r.previousSibling)&&(rInd != 0)){
			r.parentNode.insertBefore(r, r.previousSibling)
			this.rowsCol._dhx_swapItems(rInd, rInd-1)
			this.setSizes();
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd-1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd-1);
		}
	}
	/**
	*   @desc: moves row one position down if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowDown=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, 1);
		
		var rInd = this.rowsCol._dhx_find(r);
		if (r.nextSibling){ 
			this.rowsCol._dhx_swapItems(rInd, rInd+1)
			
			if (r.nextSibling.nextSibling)
				r.parentNode.insertBefore(r, r.nextSibling.nextSibling)
			else
				r.parentNode.appendChild(r)
			this.setSizes();
			
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd+1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd);
		}
	}
	//#}
	//#co_excell:06042008{
	/**
	* @desc: gets Combo object of specified column. Use it to change select box value for cell before editor opened
	*   @type: public
	*   @topic: 3,4
	*   @param: col_ind - index of the column to get combo object for
	*/
	this.getCombo=function(col_ind){
		if (!this.combos[col_ind]){
			this.combos[col_ind]=new dhtmlXGridComboObject();
		}
		return this.combos[col_ind];
	}
	//#}
	/**
	*   @desc: sets user data to row
	*   @param: row_id -  row id. if empty then user data is set for grid (not row)
	*   @param: name -  name of user data block
	*   @param: value -  value of user data block
	*   @type: public
	*   @topic: 2,5
	*/
	this.setUserData=function(row_id, name, value){
		if (!row_id)
			row_id="gridglobaluserdata";
		
		if (!this.UserData[row_id])
			this.UserData[row_id]=new Hashtable()
		this.UserData[row_id].put(name, value)
	}
	/**
	*   @desc: gets user Data
	*   @param: row_id -  row id. if empty then user data is for grid (not row)
	*   @param: name -  name of user data
	*   @returns: value of user data
	*   @type: public
	*   @topic: 2,5
	*/
	this.getUserData=function(row_id, name){
		if (!row_id)
			row_id="gridglobaluserdata";		
		this.getRowById(row_id); //parse row if necessary
		
		var z = this.UserData[row_id];
		return (z ? z.get(name) : "");
	}
	
	/**
	*   @desc: manage editibility of the grid
	*   @param: [fl] - set not editable if FALSE, set editable otherwise
	*   @type: public
	*   @topic: 7
	*/
	this.setEditable=function(fl){
		this.isEditable=dhx4.s2b(fl);
	}
	/**
	*   @desc: selects row by ID
	*   @param: row_id - row id
	*   @param: multiFL - VOID. select multiple rows
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @param: call - true to call function on select
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRowById=function(row_id, multiFL, show, call){
		if (!call)
			call=false;
		this.selectCell(this.getRowById(row_id), 0, call, multiFL, false, show);
	}
	
	/**
	*   @desc: removes selection from the grid
	*   @type: public
	*   @topic: 1,9
	*/
	this.clearSelection=function(){
		this.editStop()
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var r = this.rowsAr[this.selectedRows[i].idd];
			
			if (r)
				r.className=r.className.replace(/rowselected/g, "");
		}
		
		//..
		this.selectedRows=dhtmlxArray()
		this.row=null;
		
		if (this.cell != null){
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
			this.cell=null;
		}
		
		this.callEvent("onSelectionCleared",[]);
	}
	/**
	*   @desc: copies row content to another existing row
	*   @param: from_row_id - id of the row to copy content from
	*   @param: to_row_id - id of the row to copy content to
	*   @type: public
	*   @topic: 2,5
	*/
	this.copyRowContent=function(from_row_id, to_row_id){
		var frRow = this.getRowById(from_row_id)
		
		if (!this.isTreeGrid())
		for (var i = 0; i < frRow.cells.length; i++){
			this.cells(to_row_id, i).setValue(this.cells(from_row_id, i).getValue())
		}
		else
			this._copyTreeGridRowContent(frRow, from_row_id, to_row_id);
		
		//for Mozilla (to avaoid visual glitches)
		if (!_isIE)
			this.getRowById(from_row_id).cells[0].height=frRow.cells[0].offsetHeight
	}
	/**
	*   @desc: sets new label for cell in footer
	*   @param: col - header column index
	*   @param: label - new label for the cpecified footer's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setFooterLabel=function(c, label, ind){
		return this.setColumnLabel(c,label,ind,this.ftr);
	};
	/**
	*   @desc: sets new column header label
	*   @param: col - header column index
	*   @param: label - new label for the cpecified header's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setColumnLabel=function(c, label, ind, hdr){
		var z = (hdr||this.hdr).rows[ind||1];
		var col = (z._childIndexes ? z._childIndexes[c] : c);
		if (!z.cells[col]) return;
		if (!this.useImagesInHeader){
			var hdrHTML = "<div class='hdrcell'>"
			
			if (label.indexOf('img:[') != -1){
				var imUrl = label.replace(/.*\[([^>]+)\].*/, "$1");
				label=label.substr(label.indexOf("]")+1, label.length)
				hdrHTML+="<img width='18px' height='18px' align='absmiddle' src='"+imUrl+"' hspace='2'>"
			}
			hdrHTML+=label;
			hdrHTML+="</div>";
			z.cells[col].innerHTML=hdrHTML;
			
			if (this._hstyles[c])
				z.cells[col].style.cssText=this._hstyles[c];
		} else { //if images in header header
			z.cells[col].style.textAlign="left";
			z.cells[col].innerHTML="<img src='"+label+"'>";
			//preload sorting headers (asc/desc)
			var a = new Image();
			a.src=""+label.replace(/(\.[a-z]+)/, ".des$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=a;
			var b = new Image();
			b.src=""+label.replace(/(\.[a-z]+)/, ".asc$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=b;
		}
		
		if ((label||"").indexOf("#") != -1){
			var t = label.match(/(^|{)#([^}]+)(}|$)/);
			
			if (t){
				var tn = "_in_header_"+t[2];
				
				if (this[tn])
					this[tn]((this.forceDivInHeader ? z.cells[col].firstChild : z.cells[col]), col, label.split(t[0]));
			}
		}
	};
	this.setColLabel = function(a,b,ind,c){
		return this.setColumnLabel(a,b,(ind||0)+1,c);
	};
	/**
	*   @desc: deletes all rows in grid
	*   @param: header - (boolean) enable/disable cleaning header
	*   @type: public
	*   @topic: 5,7,9
	*/
	this.clearAll=function(header){
		if (!this.obj.rows[0]) return; //call before initilization
		if (this._h2){
			this._h2=this._createHierarchy();
			
			if (this._fake){
				if (this._realfake)
					this._h2=this._fake._h2;
				else
					this._fake._h2=this._h2;
			}
		}
		
		this.limit=this._limitC=0;
		this.editStop(true);
		
		if (this._dLoadTimer)
			window.clearTimeout(this._dLoadTimer);
		
		if (this._dload){
			this.objBox.scrollTop=0;
			this.limit=this._limitC||0;
			this._initDrF=true;
		}
		
		var len = this.rowsCol.length;
		
		//for some case
		len=this.obj.rows.length;
		
		for (var i = len-1; i > 0; i--){
			var t_r = this.obj.rows[i];
			t_r.parentNode.removeChild(t_r);
		}
		
		if (header){
			this._master_row=null;
			this.obj.rows[0].parentNode.removeChild(this.obj.rows[0]);
			
			for (var i = this.hdr.rows.length-1; i >= 0; i--){
				var t_r = this.hdr.rows[i];
				t_r.parentNode.removeChild(t_r);
			}
			
			if (this.ftr){
				this.ftr.parentNode.removeChild(this.ftr);
				this.ftr=null;
			}
			this._aHead=this.ftr=this.cellWidth=this._aFoot=null;
			this.cellType=dhtmlxArray();
			this._hrrar=[];
			this.columnIds=[];
			this.combos=[];
			this._strangeParams=[];
			this.defVal = [];
			this._ivizcol = null;
		}
		
		//..
		this.row=null;
		this.cell=null;
		
		this.rowsCol=dhtmlxArray()
		this.rowsAr={}; //array of rows by idd
		this._RaSeCol=[];
		this.rowsBuffer=dhtmlxArray()
		this.UserData=[]
		this.selectedRows=dhtmlxArray();
		
		if (this.pagingOn || this._srnd)
			this.xmlFileUrl="";
		if (this.pagingOn)
			this.changePage(1);
		
		//  if (!this._fake){
		/*
		if ((this._hideShowColumn)&&(this.hdr.rows[0]))
		for (var i=0; i<this.hdr.rows[0].cells.length; i++)
		this._hideShowColumn(i,"");
		this._hrrar=new Array();*/
		//}
		if (this._contextCallTimer)
			window.clearTimeout(this._contextCallTimer);
		
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		this.setSortImgState(false);
		this.setSizes();
		//this.obj.scrollTop = 0;
		
		this.callEvent("onClearAll", []);
	}
	
	//#sorting:06042008{
	/**
	*   @desc: sorts grid by specified field
	*    @invoke: header click
	*   @param: [ind] - index of the field
	*   @param: [repeatFl] - if to repeat last sorting
	*   @type: private
	*   @topic: 3
	*/
	this.sortField=function(ind, repeatFl, r_el){
		if (this.getRowsNum() == 0)
			return false;
		
		var el = this.hdr.rows[0].cells[ind];
		
		if (!el)
			return; //somehow
		// if (this._dload  && !this.callEvent("onBeforeSorting",[ind,this]) ) return true;
		
		if (el.tagName == "TH"&&(this.fldSort.length-1) >= el._cellIndex
			&&this.fldSort[el._cellIndex] != 'na'){ //this.entBox.fieldstosort!="" &&
		var data=this.getSortingState();
		var sortType= ( data[0]==ind && data[1]=="asc" ) ? "des" : "asc";
		
		if (!this.callEvent("onBeforeSorting", [
				ind,
			this.fldSort[ind],
			sortType
		]))
		return;
		this.sortImg.className="dhxgrid_sort_"+(sortType == "asc" ? "asc" : "desc");
		
		//for header images
		if (this.useImagesInHeader){
			var cel = this.hdr.rows[1].cells[el._cellIndex].firstChild;
			
			if (this.fldSorted != null){
				var celT = this.hdr.rows[1].cells[this.fldSorted._cellIndex].firstChild;
				celT.src=celT.src.replace(/(\.asc\.)|(\.des\.)/, ".");
			}
			cel.src=cel.src.replace(/(\.[a-z]+)$/, "."+sortType+"$1")
		}
		//.
		this.sortRows(el._cellIndex, this.fldSort[el._cellIndex], sortType)
		this.fldSorted=el;
		if (r_el && r_el.tagName.toLowerCase() != "th")
			this.r_fldSorted=r_el;

		var c = this.hdr.rows[1];
		var c = r_el.parentNode;
		var real_el = c._childIndexes ? c._childIndexes[el._cellIndex] : el._cellIndex;
		this.setSortImgPos(false, false, false, r_el);
			}
	}
	//#__pro_feature:21092006{
	//#custom_sort:21092006{
	/**
	*   @desc: set custom sorting (custom sort has three params - valueA,valueB,order; where order can be asc or des)
	*   @param: func - function to use for comparison
	*   @param:   col - index of column to apply custom sorting to
	*   @type: public
	*   @edition: Professional
	*   @topic: 3
	*/
	this.setCustomSorting=function(func, col){
		if (!this._customSorts)
			this._customSorts=new Array();
		this._customSorts[col]=( typeof (func) == "string") ? eval(func) : func;
		this.fldSort[col]="cus";
	}
	//#}
	//#}
	//#}
	/**
	*   @desc: specify if values passed to Header are images file names
	*   @param: fl - true to treat column header values as image names
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.enableHeaderImages=function(fl){
		this.useImagesInHeader=fl;
	}
	
	/**
	*   @desc: set header label and default params for new headers
	*   @param: hdrStr - header string with delimiters
	*   @param: splitSign - string used as a split marker, optional. Default is "#cspan"
	*   @param: styles - array of header styles
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.setHeader=function(hdrStr, splitSign, styles){
		if (typeof (hdrStr) != "object")
			var arLab = this._eSplit(hdrStr);
		else
			arLab=[].concat(hdrStr);
		
		var arWdth = new Array(0);
		var arTyp = new dhtmlxArray(0);
		var arAlg = new Array(0);
		var arVAlg = new Array(0);
		var arSrt = new Array(0);
		
		for (var i = 0; i < arLab.length; i++){
			arWdth[arWdth.length]=Math.round(100 / arLab.length);
			arTyp[arTyp.length]="ed";
			arAlg[arAlg.length]="left";
			arVAlg[arVAlg.length]="middle"; //top
			arSrt[arSrt.length]="na";
		}
		
		this.splitSign=splitSign||"#cspan";
		this.hdrLabels=arLab;
		this.cellWidth=arWdth;
		if (!this.initCellWidth.length) this.setInitWidthsP(arWdth.join(this.delim),true);
		this.cellType=arTyp;
		this.cellAlign=arAlg;
		this.cellVAlign=arVAlg;
		this.fldSort=arSrt;
		this._hstyles=styles||[];
	}
	/**
	*   @desc: 
	*   @param: str - ...
	*   @type: private
	*/
	this._eSplit=function(str){
		if (![].push)
			return str.split(this.delim);
		
		var a = "r"+(new Date()).valueOf();
		var z = this.delim.replace(/([\|\+\*\^])/g, "\\$1")
		return (str||"").replace(RegExp(z, "g"), a).replace(RegExp("\\\\"+a, "g"), this.delim).split(a);
	}
	
	/**
	*   @desc: get column type by column index
	*   @param: cInd - column index
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColType=function(cInd){
		return this.cellType[cInd];
	}
	
	/**
	*   @desc: get column type by column ID
	*   @param: cID - column id
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColTypeById=function(cID){
		return this.cellType[this.getColIndexById(cID)];
	}
	
	/**
	*   @desc: set column types
	*   @param: typeStr - type codes list (default delimiter is ",")
	*   @before_init: 2
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColTypes=function(typeStr){
		this.cellType=dhtmlxArray(typeStr.split(this.delim));
		this._strangeParams=new Array();
		
		for (var i = 0; i < this.cellType.length; i++){
			if ((this.cellType[i].indexOf("[") != -1)){
				var z = this.cellType[i].split(/[\[\]]+/g);
				this.cellType[i]=z[0];
				this.defVal[i]=z[1];
				
				if (z[1].indexOf("=") == 0){
					this.cellType[i]="math";
					this._strangeParams[i]=z[0];
				}
			}
			if (!window["eXcell_"+this.cellType[i]]) dhx4.callEvent("onConfigurationError",["Incorrect cell type: "+this.cellType[i],this,this.cellType[i]]);
		}
	}
	/**
	*   @desc: set column sort types (avaialble: str, int, date, na or function object for custom sorting)
	*   @param: sortStr - sort codes list with default delimiter
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColSorting=function(sortStr){
		this.fldSort=sortStr.split(this.delim)
		//#__pro_feature:21092006{
		//#custom_sort:21092006{
		//str, int, date
		var check = {str:1, "int":1, date:1};
		for (var i = 0; i < this.fldSort.length; i++)
		if ((!check[this.fldSort[i]])&&( typeof (window[this.fldSort[i]]) == "function")){
			if (!this._customSorts)
				this._customSorts=new Array();
			this._customSorts[i]=window[this.fldSort[i]];
			this.fldSort[i]="cus";
		}
		//#}
		//#}
	}
	/**
	*   @desc: set align of values in columns
	*   @param: alStr - list of align values (possible values are: right,left,center,justify). Default delimiter is ","
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColAlign=function(alStr){
		this.cellAlign=alStr.split(this.delim)
		for (var i=0; i < this.cellAlign.length; i++)
			this.cellAlign[i]=this.cellAlign[i]._dhx_trim();
	}
	/**
	*   @desc: set vertical align of columns
	*   @param: valStr - vertical align values list for columns (possible values are: baseline,sub,super,top,text-top,middle,bottom,text-bottom)
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColVAlign=function(valStr){
		this.cellVAlign=valStr.split(this.delim)
	}
	
	/**
	* 	@desc: create grid with no header. Call before initialization, but after setHeader. setHeader have to be called in any way as it defines number of columns
	*   @param: fl - true to use no header in the grid
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,7
	*/
	this.setNoHeader=function(fl){
		this.noHeader=dhx4.s2b(fl);
	}
	/**
	*   @desc: scrolls row to the visible area
	*   @param: rowID - row id
	*   @type: public
	*   @topic: 2,7
	*/
	this.showRow=function(rowID){
		this.getRowById(rowID)
		
		if (this._h2) this.openItem(this._h2.get[rowID].parent.id);
		var c = this.getRowById(rowID).childNodes[0];
		
		while (c&&c.style.display == "none")
			c=c.nextSibling;
		
		if (c)
			this.moveToVisible(c, true)
	}
	
	/**
	*   @desc: modify default style of grid and its elements. Call before or after Init
	*   @param: ss_header - style def. expression for header
	*   @param: ss_grid - style def. expression for grid cells
	*   @param: ss_selCell - style def. expression for selected cell
	*   @param: ss_selRow - style def. expression for selected Row
	*   @type: public
	*   @before_init: 2
	*   @topic: 0,6
	*/
	this.setStyle=function(ss_header, ss_grid, ss_selCell, ss_selRow){
		this.ssModifier=[
			ss_header,
			ss_grid,
			ss_selCell,
			ss_selCell,
			ss_selRow
		];
		
		var prefs = ["#"+this.entBox.id+" table.hdr td", "#"+this.entBox.id+" table.obj td",
			"#"+this.entBox.id+" table.obj tr.rowselected td.cellselected",
		"#"+this.entBox.id+" table.obj td.cellselected", "#"+this.entBox.id+" table.obj tr.rowselected td"];
		
		var index = 0;
		while (!_isIE){
			try{
				var temp = document.styleSheets[index].cssRules.length;
			} catch(e) { index++; continue; }
			break;
		}
		
		for (var i = 0; i < prefs.length; i++)
		if (this.ssModifier[i]){
			if (_isIE)
				document.styleSheets[0].addRule(prefs[i], this.ssModifier[i]);
			else
				document.styleSheets[index].insertRule(prefs[i]+(" { "+this.ssModifier[i]+" }"), document.styleSheets[index].cssRules.length);
		}
	}
	/**
	*   @desc: colorize columns  background.
	*   @param: clr - colors list
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.setColumnColor=function(clr){
		this.columnColor=clr.split(this.delim)
	}
	//#alter_css:06042008{
	/**
	*   @desc: set even/odd css styles
	*   @param: cssE - name of css class for even rows
	*   @param: cssU - name of css class for odd rows
	*   @param: perLevel - true/false - mark rows not by order, but by level in treegrid
	*   @param: levelUnique - true/false - creates additional unique css class based on row level
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.enableAlterCss=function(cssE, cssU, perLevel, levelUnique){
		if (cssE||cssU)
		this.attachEvent("onGridReconstructed",function(){
				this._fixAlterCss();
				if (this._fake)
					this._fake._fixAlterCss();
		});
		
		this._cssSP=perLevel;
		this._cssSU=levelUnique;
		this._cssEven=cssE;
		this._cssUnEven=cssU;
	}
	//#}
	/**
	*   @desc: recolor grid from defined point
	*   @type: private
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this._fixAlterCss=function(ind){
		//#alter_css:06042008{		
		if (this._h2 && (this._cssSP || this._cssSU))
			return this._fixAlterCssTGR(ind);
		if (!this._cssEven && !this._cssUnEven) return;
		ind=ind||0;
		var j = ind;
		
		for (var i = ind; i < this.rowsCol.length; i++){
			if (!this.rowsCol[i])
				continue;
			
			if (this.rowsCol[i].style.display != "none"){
				if (this.rowsCol[i]._cntr) { j=1; continue; }
				if (this.rowsCol[i].className.indexOf("rowselected") != -1){
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" rowselected "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" rowselected "+(this.rowsCol[i]._css||"");
				} else {
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" "+(this.rowsCol[i]._css||"");
				}
				j++;
			}
		}
		//#}		
	}
	//#__pro_feature:21092006{
	/**
	*     @desc: clear wasChanged state for all cells in grid
	*     @type: public
	*     @edition: Professional
	*     @topic: 7
	*/
	this.clearChangedState=function(){
		for (var i = 0; i < this.rowsCol.length; i++){
			var row = this.rowsCol[i];
			if (row && row.childNodes){
				var cols = row.childNodes.length;
				for (var j = 0; j < cols; j++)row.childNodes[j].wasChanged=false;
			}
		}
	};
	
	/**
	*     @desc: get list of IDs of changed rows
	*     @type: public
	*     @edition: Professional
	*     @return: list of ID of changed rows
	*     @topic: 7
	*/
	this.getChangedRows=function(and_added){
		var res = new Array();
		this.forEachRow(function(id){
				var row = this.rowsAr[id];
				if (row.tagName!="TR") return; 
				var cols = row.childNodes.length;
				if (and_added && row._added)
					res[res.length]=row.idd;
				else
					for (var j = 0; j < cols; j++)
					if (row.childNodes[j].wasChanged){
						res[res.length]=row.idd;
						break;
					}
		})
		return res.join(this.delim);
	};
	
	
	//#serialization:21092006{
	
	this._sUDa=false;
	this._sAll=false;
	
	/**
	*     @desc: configure XML serialization
	*     @type: public
	*     @edition: Professional
	*     @param: userData - enable/disable user data serialization
	*     @param: fullXML - enable/disable full XML serialization (selection state)
	*     @param: config - serialize grid configuration
	*     @param: changedAttr - include changed attribute
	*     @param: onlyChanged - include only Changed  rows in result XML
	*     @param: asCDATA - output cell values as CDATA sections (prevent invalid XML)
	*     @topic: 0,5,7
	*/
	this.setSerializationLevel=function(userData, fullXML, config, changedAttr, onlyChanged, asCDATA){
		this._sUDa=userData;
		this._sAll=fullXML;
		this._sConfig=config;
		this._chAttr=changedAttr;
		this._onlChAttr=onlyChanged;
		this._asCDATA=asCDATA;
	}
	
	
	/**
	*     @desc: configure which column must be serialized (if you do not use this method, then all columns will be serialized)
	*     @type: public
	*     @edition: Professional
	*     @param: list - list of true/false values separated by comma, if list empty then all fields will be serialized
	*     @topic: 0,5,7
	*/
	this.setSerializableColumns=function(list){
		if (!list){
			this._srClmn=null;
			return;
		}
		this._srClmn=(list||"").split(",");
		
		for (var i = 0; i < this._srClmn.length; i++)this._srClmn[i]=dhx4.s2b(this._srClmn[i]);
	}
	
	/**
	*     @desc: serialize a collection of rows
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialise=function(rCol, inner, closed){
		this.editStop()
		var out = [];
		//rows collection
		var close = "</"+this.xml.s_row+">"
		
		if (this.isTreeGrid()){
			this._h2.forEachChildF(0, function(el){
					var temp = this._serializeRow(this.render_row_tree(-1, el.id));
					out.push(temp);
					
					if (temp)
						return true;
					else
						return false;
			}, this, function(){
				out.push(close);
			});
		}
		else
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]){
				if (this._chAttr && this.rowsBuffer[i]._locator)
					continue;
				
				var temp = this._serializeRow(this.render_row(i));
				out.push(temp);
				
				if (temp)
					out.push(close);
			}
			
			return [out.join("")];
	}
	
	/**
	*   @desc: serialize TR or xml node to grid formated xml (row tag)
	*   @param: r - TR or xml node (row)
	*   @retruns: string - xml representation of passed row
	*   @type: private
	*/
	this._serializeRow=function(r, i){
		var out = [];
		var ra = this.xml.row_attrs;
		var ca = this.xml.cell_attrs;
		
		out.push("<"+this.xml.s_row);
		out.push(" id='"+r.idd+"'");
		
		if ((this._sAll)&&this.selectedRows._dhx_find(r) != -1)
			out.push(" selected='1'");
		
		if (this._h2&&this._h2.get[r.idd].state == "minus")
			out.push(" open='1'");
		
		if (ra.length)
			for (var i = 0; i < ra.length; i++)out.push(" "+ra[i]+"='"+r._attrs[ra[i]]+"'");
		out.push(">");
		
		//userdata
		if (this._sUDa&&this.UserData[r.idd]){
			keysAr=this.UserData[r.idd].getKeys()
			
			for (var ii = 0; ii < keysAr.length; ii++){
				var subkey = keysAr[ii];
				if (subkey.indexOf("__") !== 0)
					out.push("<userdata name='"+subkey+"'>"+(this._asCDATA?"<![CDATA[":"")+this.UserData[r.idd].get(subkey)+(this._asCDATA?"]]>":"")+"</userdata>");
			}
		}
		
		
		//cells
		var changeFl = false;
		
		for (var jj = 0; jj < this._cCount; jj++){
			if ((!this._srClmn)||(this._srClmn[jj])){
				var zx = this.cells3(r, jj);
				out.push("<cell");
				
				if (ca.length)
					for (var i = 0; i < ca.length; i++)out.push(" "+ca[i]+"='"+zx.cell._attrs[ca[i]]+"'");
				zxVal=zx[this._agetm]();
				
				if (this._asCDATA)
					zxVal="<![CDATA["+zxVal+"]]>";
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan)&&zx.cell.colSpan > 1)
					out.push(" colspan=\""+zx.cell.colSpan+"\" ");
				//#}
				
				if (this._chAttr){
					if (zx.wasChanged()){
						out.push(" changed=\"1\"");
						changeFl=true;
					}
				}
				
				else if ((this._onlChAttr)&&(zx.wasChanged()))
					changeFl=true;
				
				if (this._sAll && this.cellType[jj]=="tree")
					out.push((this._h2 ? (" image='"+this._h2.get[r.idd].image+"'") : "")+">"+zxVal+"</cell>");
				else
					out.push(">"+zxVal+"</cell>");
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan))
				for (var u = 0; u < zx.cell.colSpan-1; u++){
					out.push("<cell/>");
					jj++;
				}
				//#}
			}
		}
		
		if ((this._onlChAttr)&&(!changeFl)&&(!r._added))
			return "";
		
		return out.join("");
	}
	
	/**
	*     @desc: serialize grid configuration
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialiseConfig=function(){
		var out = "<head>";
		
		for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
			if (this._srClmn && !this._srClmn[i]) continue;
			var sort = this.fldSort[i];
			if (sort == "cus"){
				sort = this._customSorts[i].toString();
				sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
			}
			out+="<column width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i]
			+"' sort='"+(sort||"na")+"' color='"+(this.columnColor[i]||"")+"'"
			+(this.columnIds[i]
				? (" id='"+this.columnIds[i]+"'")
				: "")+">";
			if (this._asCDATA)
				out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
			else
				out+=this.getColumnLabel(i);
			var z = this.getCombo(i);
			
			if (z)
				for (var j = 0; j < z.keys.length; j++)out+="<option value='"+z.keys[j]+"'>"+z.values[j]+"</option>";
			out+="</column>"
		}
		return out+="</head>";
	}
	/**
	*     @desc: get actual xml of grid. The depth of serialization can be set with setSerializationLevel method
	*     @type: public
	*     @edition: Professional
	*     @topic: 5,7
	*/
	this.serialize=function(){
		var out = '<?xml version="1.0"?><rows>';
		
		if (this._mathSerialization)
			this._agetm="getMathValue";
		else
			this._agetm="getValue";
		
		if (this._sUDa&&this.UserData["gridglobaluserdata"]){
			var keysAr = this.UserData["gridglobaluserdata"].getKeys()
			
			for (var i = 0;
				i < keysAr.length;
				i++)out+="<userdata name='"+keysAr[i]+"'>"+this.UserData["gridglobaluserdata"].get(keysAr[i])
				+"</userdata>";
		}
		
		if (this._sConfig)
			out+=this._serialiseConfig();
		out+=this._serialise();
		
		out+='</rows>';
		return out;
	}
	//#}
	//#}
	
	/**
	*    @desc: returns absolute left and top position of specified element
	*    @returns: array of two values: absolute Left and absolute Top positions
	*    @param: oNode - element to get position of
	*   @type: private
	*   @topic: 8
	*/
	this.getPosition=function(oNode, pNode){
		if (!pNode){
			var pos = dhx4.getOffset(oNode);
			return [pos.left, pos.top];
		}
		pNode = pNode||document.body;
		
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;
		
		while ((oCurrentNode)&&(oCurrentNode != pNode)){ //.tagName!="BODY"){
			iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft;
			iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		
		if (pNode == document.body){
			if (_isIE){
				iTop+=document.body.offsetTop||document.documentElement.offsetTop;
				iLeft+=document.body.offsetLeft||document.documentElement.offsetLeft;
			} else if (!_isFF){
				iLeft+=document.body.offsetLeft;
				iTop+=document.body.offsetTop;
			}
		}
		return [iLeft, iTop];
	}
	/**
	*   @desc: gets nearest parent of specified type
	*   @param: obj - input object
	*   @param: tag - string. tag to find as parent
	*   @returns: object. nearest paraent object (including spec. obj) of specified type.
	*   @type: private
	*   @topic: 8
	*/
	this.getFirstParentOfType=function(obj, tag){
		while (obj&&obj.tagName != tag&&obj.tagName != "BODY"){
			obj=obj.parentNode;
		}
		return obj;
	}
	
	
	
	/*INTERNAL EVENT HANDLERS*/
	this.objBox.onscroll=function(){
		this.grid._doOnScroll();
	};
	this.hdrBox.onscroll=function(){
		if (this._try_header_sync) return;
		this._try_header_sync = true;
		if (Math.abs(this.grid.objBox.scrollLeft - this.scrollLeft)>1){
			this.grid.objBox.scrollLeft = this.scrollLeft;
		}
		this._try_header_sync = false;
	}
	//#column_resize:06042008{
	if ((!_isOpera)||(_OperaRv > 8.5)){
		this.hdr.onmousemove=function(e){
			this.grid.changeCursorState(e||window.event);
		};
		this.hdr.onmousedown=function(e){
			return this.grid.startColResize(e||window.event);
		};		
	}
	//#}
	//#tooltips:06042008{
	this.obj.onmousemove=this._drawTooltip;
	//#}
	this.objBox.onclick=function(e){
		e = e||event;
		e.cancelBubble=true;
		this.firstChild.grid.setActive(true);
		window.dhx4.callEvent("_onGridClick", [e, this.firstChild.grid]);
	};
	this.obj.onclick=function(e){
		if (this.grid._doClick(e||window.event) !== false){
			if (this.grid._sclE) 
				this.grid.editCell(e||window.event); 
			else
				this.grid.editStop();
		}
		
		e = e||event;
		e.cancelBubble=true;
		window.dhx4.callEvent("_onGridClick", [e, this.grid]);
	};
	//#context_menu:06042008{
	if (_isMacOS){
		this.entBox.oncontextmenu=function(e){
			e.cancelBubble=true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue=false;
			var that = this.grid; if (that._realfake) that = that._fake;
			return that._doContClick(e||window.event);
		};
	} else {
		this.entBox.onmousedown=function(e){
			return this.grid._doContClick(e||window.event);
		};
		this.entBox.oncontextmenu=function(e){
			if (this.grid._ctmndx)
				(e||event).cancelBubble=true;
			return !this.grid._ctmndx;
		};
	}
    	
	//#}		
	this.obj.ondblclick=function(e){
		if (!this.grid.wasDblClicked(e||window.event)) 
			return false; 
		if (this.grid._dclE) {
			var row = this.grid.getFirstParentOfType((_isIE?event.srcElement:e.target),"TR");
			if (row == this.grid.row)
				this.grid.editCell(e||window.event);  
		}
		(e||event).cancelBubble=true;
		if (_isOpera) return false; //block context menu for Opera 9+
	};
	this.hdr.onclick=this._onHeaderClick;
	this.sortImg.onclick=function(){
		self._onHeaderClick.apply({
				grid: self
		}, [
			null,
			self.r_fldSorted
		]);
	};
	
	this.hdr.ondblclick=this._onHeaderDblClick;
	
	
	if (!document.body._dhtmlxgrid_onkeydown){
		dhtmlxEvent(document, "keydown",function(e){
				if (globalActiveDHTMLGridObject) 
					return globalActiveDHTMLGridObject.doKey(e||window.event);
		});
		document.body._dhtmlxgrid_onkeydown=true;
	}
	
	dhtmlxEvent(document.body, "click", function(){
			if (self.editStop) self.editStop();
			if (self.isActive) self.setActive(false);
	});
	
	
	if (this.entBox.style.height.toString().indexOf("%") != -1)
		this._delta_y = this.entBox.style.height;
	if (this.entBox.style.width.toString().indexOf("%") != -1)
		this._delta_x = this.entBox.style.width;
	
	if (this._delta_x||this._delta_y)
		this._setAutoResize();
	
	
	/* deprecated names */
	this.setColHidden=this.setColumnsVisibility
	this.enableCollSpan = this.enableColSpan
	this.setMultiselect=this.enableMultiselect;
	this.setMultiLine=this.enableMultiline;
	this.deleteSelectedItem=this.deleteSelectedRows;
	this.getSelectedId=this.getSelectedRowId;
	this.getHeaderCol=this.getColumnLabel;
	this.isItemExists=this.doesRowExist;
	this.getColumnCount=this.getColumnsNum;
	this.setSelectedRow=this.selectRowById;
	this.setHeaderCol=this.setColumnLabel;
	this.preventIECashing=this.preventIECaching;
	this.enableAutoHeigth=this.enableAutoHeight;
	this.getUID=this.uid;
	
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);
	
	return this;
}

dhtmlXGridObject.prototype={
	getRowAttribute: function(id, name){
		return this.getRowById(id)._attrs[name];
	},
	setRowAttribute: function(id, name, value){
		this.getRowById(id)._attrs[name]=value;
	},
	/**
	*   @desc: detect is current grid is a treeGrid
	*   @type: private
	*   @topic: 2
	*/
	isTreeGrid:function(){
		return (this.cellType._dhx_find("tree") != -1);
	},
	
	//#column_hidden:21092006{	
	/**
	*   @desc: hide/show row (warning! - this command doesn't affect row indexes, only visual appearance)
	*   @param: ind - column index
	*   @param: state - true/false - hide/show row
	*   @type:  public
	*/
	setRowHidden:function(id, state){
		var f = dhx4.s2b(state);
		//var ind=this.getRowIndex(id);
		//if (id<0)
		//   return;
		var row = this.getRowById(id) //this.rowsCol[ind];
		
		if (!row)
			return;
		
		if (row.expand === "")
			this.collapseKids(row);
		
		if ((state)&&(row.style.display != "none")){
			row.style.display="none";
			var z = this.selectedRows._dhx_find(row);
			
			if (z != -1){
				row.className=row.className.replace("rowselected", "");
				
				for (var i = 0;
					i < row.childNodes.length;
					i++)row.childNodes[i].className=row.childNodes[i].className.replace(/cellselected/g, "");
					this.selectedRows._dhx_removeAt(z);
			}
			this.callEvent("onGridReconstructed", []);
		}
		
		if ((!state)&&(row.style.display == "none")){
			row.style.display="";
			this.callEvent("onGridReconstructed", []);
		}
		this.callEvent("onRowHide",[id, state]);
		this.setSizes();
	},
	
	//#__pro_feature:21092006{
	/**
	*   @desc: hide/show column
	*   @param: ind - column index
	*   @param: state - true/false - hide/show column
	*   @type:  public
	*   @edition: Professional
	*/
	setColumnHidden:function(ind, state){
		if (!this.hdr.rows.length){
			if (!this._ivizcol)
				this._ivizcol=[];
			return this._ivizcol[ind]=state;
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(state))
			this.sortImg.style.display="none";
		
		var f = dhx4.s2b(state);
		
		if (f){
			if (!this._hrrar)
				this._hrrar=new Array();
			
			else if (this._hrrar[ind])
				return;
			this._hrrar[ind]="display:none;";
			this._hideShowColumn(ind, "none");
		} else {
			if ((!this._hrrar)||(!this._hrrar[ind]))
				return;
			this._hrrar[ind]="";
			this._hideShowColumn(ind, "");
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(!state))
			this.sortImg.style.display="inline";
		
		this.setSortImgPos();
		this.callEvent("onColumnHidden",[ind,state])
	},
	
	
	/**
	*   @desc: get show/hidden status of column
	*   @param: ind - column index
	*   @type:  public
	*   @edition: Professional
	*   @returns:  if column hidden then true else false
	*/
	isColumnHidden:function(ind){
		if ((this._hrrar)&&(this._hrrar[ind]))
			return true;
		
		return false;
	},
	/**
	*   @desc: set list of visible/hidden columns
	*   @param: list - list of true/false separated by comma
	*   @type:  public
	*	@newmethod: setColumnsVisibility
	*   @edition: Professional
	*   @topic:0
	*/
	setColumnsVisibility:function(list){
		if (list)
			this._ivizcol=list.split(this.delim);
		
		if (this.hdr.rows.length&&this._ivizcol)
			for (var i = 0; i < this._ivizcol.length; i++)this.setColumnHidden(i, this._ivizcol[i]);
	},
	/**
	*   @desc: fix hidden state for column in all rows
	*   @type: private
	*/
	_fixHiddenRowsAll:function(pb, ind, prop, state, index){
		index=index||"_cellIndex";
		var z = pb.rows.length;
		
		for (var i = 0; i < z; i++){
			var x = pb.rows[i].childNodes;
			
			if (x.length != this._cCount){
				for (var j = 0; j < x.length; j++)
				if (x[j][index] == ind){
					x[j].style[prop]=state;
					break;
				}
			} else
			x[ind].style[prop]=state;
		}
	},
	/**
	*   @desc: hide column
	*   @param: ind - column index
	*   @param: state - hide/show
	*   @edition: Professional
	*   @type:  private
	*/
	_hideShowColumn:function(ind, state){
		var hind = ind;
		
		if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes)&&(this.hdr.rows[1]._childIndexes[ind] != ind))
			hind=this.hdr.rows[1]._childIndexes[ind];
		
		if (state == "none"){
			this.hdr.rows[0].cells[ind]._oldWidth=this.hdr.rows[0].cells[ind].style.width||(this.initCellWidth[ind]+"px");
			this.hdr.rows[0].cells[ind]._oldWidthP=this.cellWidthPC[ind];
			this.obj.rows[0].cells[ind].style.width="0px";
			
			
			var t={rows:[this.obj.rows[0]]}
			this.forEachRow(function(id){
					if (this.rowsAr[id].tagName=="TR")
						t.rows.push(this.rowsAr[id])
			})
			this._fixHiddenRowsAll(t, ind, "display", "none");
			
			if (this.isTreeGrid())
				this._fixHiddenRowsAllTG(ind, "none");
			
			if ((_isOpera&&_OperaRv < 9)||_isKHTML||(_isFF)){ 
				this._fixHiddenRowsAll(this.hdr, ind, "display", "none","_cellIndexS");
				
			}
			if (this.ftr)
				this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");			
			this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap","_cellIndexS");
			
			if (!this.cellWidthPX.length&&!this.cellWidthPC.length)
				this.cellWidthPX=[].concat(this.initCellWidth);
			
			if (this.cellWidthPX[ind])
				this.cellWidthPX[ind]=0;
			
			if (this.cellWidthPC[ind])
				this.cellWidthPC[ind]=0;
		} else {
			if (this.hdr.rows[0].cells[ind]._oldWidth){
				var zrow = this.hdr.rows[0].cells[ind];
				
				if (_isOpera||_isKHTML||(_isFF))
					this._fixHiddenRowsAll(this.hdr, ind, "display", "","_cellIndexS");
				
				if (this.ftr)
					this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");
				
				
				var t={rows:[this.obj.rows[0]]}
				this.forEachRow(function(id){
						if (this.rowsAr[id].tagName=="TR")
							t.rows.push(this.rowsAr[id])
				})
				this._fixHiddenRowsAll(t, ind, "display", "");
				
				if (this.isTreeGrid())
					this._fixHiddenRowsAllTG(ind, "");
				
				this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal","_cellIndexS");
				
				if (zrow._oldWidthP)
					this.cellWidthPC[ind]=zrow._oldWidthP;
				
				if (zrow._oldWidth)
					this.cellWidthPX[ind]=parseInt(zrow._oldWidth);
			}
		}

		if (!state && this._realfake)
			this.setColumnSizes(this.entBox.clientWidth);

		this.setSizes();
		
		if ((!_isIE)&&(!_isFF)){
			//dummy Opera/Safari fix
			this.obj.border=1;
			this.obj.border=0;
		}
	},
	//#}	
	//#}
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	/**
	*   @desc: enable/disable colspan support
	*   @param: mode - true/false
	*   @type:  public
	*   @edition: Professional
	*/
	enableColSpan:function(mode){
		this._ecspn=dhx4.s2b(mode);
	},
	//#}
	//#}
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable hovering row on mouse over
	*   @param: mode - true/false
	*   @param: cssClass - css class for hovering row
	*   @type:  public
	*/
	enableRowsHover:function(mode, cssClass){
		this._unsetRowHover(false,true);
		this._hvrCss=cssClass;
		
		if (dhx4.s2b(mode)){
			if (!this._elmnh){
				this.obj._honmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._setRowHover;
				
				if (_isIE)
					this.obj.onmouseleave=this._unsetRowHover;
				else
					this.obj.onmouseout=this._unsetRowHover;
				
				this._elmnh=true;
			}
		} else {
			if (this._elmnh){
				this.obj.onmousemove=this.obj._honmousemove;
				
				if (_isIE)
					this.obj.onmouseleave=null;
				else
					this.obj.onmouseout=null;
				
				this._elmnh=false;
			}
		}
	},
	//#}	
	/**
	*   @desc: enable/disable events which fire excell editing, mutual exclusive with enableLightMouseNavigation
	*   @param: click - true/false - enable/disable editing by single click
	*   @param: dblclick - true/false - enable/disable editing by double click
	*   @param: f2Key - enable/disable editing by pressing F2 key
	*   @type:  public
	*/
	enableEditEvents:function(click, dblclick, f2Key){
		this._sclE=dhx4.s2b(click);
		this._dclE=dhx4.s2b(dblclick);
		this._f2kE=dhx4.s2b(f2Key);
	},
	
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable light mouse navigation mode (row selection with mouse over, editing with single click), mutual exclusive with enableEditEvents
	*   @param: mode - true/false
	*   @type:  public
	*/
	enableLightMouseNavigation:function(mode){
		if (dhx4.s2b(mode)){
			if (!this._elmn){
				this.entBox._onclick=this.entBox.onclick;
				this.entBox.onclick=function(){
					return true;
				};
				
				this.obj._onclick=this.obj.onclick;
				this.obj.onclick=function(e){
					var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
					if (!c) return;
					this.grid.editStop();
					this.grid.doClick(c);
					this.grid.editCell();
					(e||event).cancelBubble=true;
				}
				
				this.obj._onmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._autoMoveSelect;
				this._elmn=true;
			}
		} else {
			if (this._elmn){
				this.entBox.onclick=this.entBox._onclick;
				this.obj.onclick=this.obj._onclick;
				this.obj.onmousemove=this.obj._onmousemove;
				this._elmn=false;
			}
		}
	},
	
	
	/**
	*   @desc: remove hover state on row
	*   @type:  private
	*/
	_unsetRowHover:function(e, c){
		if (c)
			that=this;
		else
			that=this.grid;
		
		if ((that._lahRw)&&(that._lahRw != c)){
			for (var i = 0;
				i < that._lahRw.childNodes.length;
				i++)that._lahRw.childNodes[i].className=that._lahRw.childNodes[i].className.replace(that._hvrCss, "");
				that._lahRw=null;
		}
	},
	
	/**
	*   @desc: set hover state on row
	*   @type:  private
	*/
	_setRowHover:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (c && c.parentNode!=this.grid._lahRw) {
			this.grid._unsetRowHover(0, c);
			c=c.parentNode;
	  		if (!c.idd || c.idd=="__filler__") return;
			for (var i = 0; i < c.childNodes.length; i++)c.childNodes[i].className+=" "+this.grid._hvrCss;
			this.grid._lahRw=c;
		}
		this._honmousemove(e);
	},
	
	/**
	*   @desc: onmousemove, used in light mouse navigaion mode
	*   @type:  private
	*/
	_autoMoveSelect:function(e){
		//this - grid.obj
		if (!this.grid.editor){
			var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
			
			if (c.parentNode.idd)
				this.grid.doClick(c, true, 0);
		}
		this._onmousemove(e);
	},
	//#}	
	//#__pro_feature:21092006{
	//#distrb_parsing:21092006{
	/**
	*   @desc: enable/disable distributed parsing (rows paresed portion by portion with some timeout)
	*   @param: mode - true/false
	*   @param: count - count of nodes parsed by one step (the 10 by default)
	*   @param: time - time between parsing counts in milli seconds (the 250 by default)
	*   @type:  public
	*   @edition: Professional
	*/
	enableDistributedParsing:function(mode, count, time){
		if (dhx4.s2b(mode)){
			this._ads_count=count||10;
			this._ads_time=time||250;
		} else
		this._ads_count=0;
	},
	//#}
	//#}
	/**
	*     @desc: destructor, removes grid and cleans used memory
	*     @type: public
	*     @topic: 0
	*/
	destructor:function(){
		this.editStop(true);
		//add links to current object
		if (this._sizeTime)
			this._sizeTime=window.clearTimeout(this._sizeTime);
		this.entBox.className=(this.entBox.className||"").replace(/gridbox.*/,"");
		if (this.formInputs)
			for (var i = 0; i < this.formInputs.length; i++)this.parentForm.removeChild(this.formInputs[i]);
		
		var a;
		
		for (var i = 0; i < this.rowsCol.length; i++)
			if (this.rowsCol[i])
			this.rowsCol[i].grid=null;
		
		for (i in this.rowsAr)
			if (this.rowsAr[i])
			this.rowsAr[i]=null;
		
		this.rowsCol=new dhtmlxArray();
		this.rowsAr={};
		this.entBox.innerHTML="";
		
		var dummy=function(){};
		this.entBox.onclick = this.entBox.onmousedown = this.entBox.onbeforeactivate = this.entBox.onbeforedeactivate = this.entBox.onbeforedeactivate = this.entBox.onselectstart = dummy;
		this.setSizes = this._update_srnd_view = this.callEvent = dummy;
		this.entBox.grid=this.objBox.grid=this.hdrBox.grid=this.obj.grid=this.hdr.grid=null;
		if (this._fake){
			this.globalBox.innerHTML = "";
			this._fake.setSizes = this._fake._update_srnd_view = this._fake.callEvent = dummy;
			this.globalBox.onclick = this.globalBox.onmousedown = this.globalBox.onbeforeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onselectstart = dummy;
		}
		
		for (a in this){
			if ((this[a])&&(this[a].m_obj))
				this[a].m_obj=null;
			this[a]=null;
		}
		
		if (this == globalActiveDHTMLGridObject)
			globalActiveDHTMLGridObject=null;
		//   self=null;
		return null;
	},
	
	//#sorting:06042008{	
	/**
	*     @desc: get sorting state of grid
	*     @type: public
	*     @returns: array, first element is index of sortef column, second - direction of sorting ("asc" or "des").
	*     @topic: 0
	*/
	getSortingState:function(){
		var z = new Array();
		
		if (this.fldSorted){
			z[0]=this.fldSorted._cellIndex;
			z[1]=(this.sortImg.className == "dhxgrid_sort_desc" ? "des" : "asc");
		}
		return z;
	},
	//#}
	
	/**
	*     @desc: enable autoheight of grid
	*     @param: mode - true/false
	*     @param: maxHeight - maximum height before scrolling appears (no limit by default)
	*     @param: countFullHeight - control the usage of maxHeight parameter - when set to true all grid height included in max height calculation, if false then only data part (no header) of grid included in calcualation (false by default)
	*     @type: public
	*     @topic: 0
	*/
	enableAutoHeight:function(mode, maxHeight, countFullHeight){
		this._ahgr=dhx4.s2b(mode);
		this._ahgrF=dhx4.s2b(countFullHeight);
		this._ahgrM=maxHeight||null;
		if (arguments.length == 1){
			this.objBox.style.overflowY=mode?"hidden":"auto";
		}
		if (maxHeight == "auto"){
			this._ahgrM=null;
			this._ahgrMA=true;
			this._setAutoResize();
			//   this._activeResize();
		}
	},
	//#sorting:06042008{	
	enableStableSorting:function(mode){
		this._sst=dhx4.s2b(mode);
		this.rowsCol.stablesort=function(cmp){
			var size = this.length-1;
			
			for (var i = 0; i < this.length-1; i++){
				for (var j = 0; j < size; j++)
				if (cmp(this[j], this[j+1]) > 0){
					var temp = this[j];
					this[j]=this[j+1];
					this[j+1]=temp;
				}
				size--;
			}
		}
	},
	//#}
	
	/**
	*     @desc: enable/disable hot keys in grid
	*     @param: mode - true/false
	*     @type: public
	*     @topic: 0
	*/
	enableKeyboardSupport:function(mode){
		this._htkebl=!dhx4.s2b(mode);
	},
	
	//#context_menu:06042008{	
	/**
	*     @desc: enable/disable context menu
	*     @param: dhtmlxMenu object, if null - context menu will be disabled
	*     @type: public
	*     @topic: 0
	*/
	enableContextMenu:function(menu){
		this._ctmndx=menu;
	},
	//#}	
	
	/*backward compatibility*/
	setScrollbarWidthCorrection:function(width){
	},
	//#tooltips:06042008{	
	/**
	*     @desc: enable/disable tooltips for specified colums
	*     @param: list - list of true/false values, tooltips enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableTooltips:function(list){
		this._enbTts=list.split(",");
		
		for (var i = 0; i < this._enbTts.length; i++)this._enbTts[i]=dhx4.s2b(this._enbTts[i]);
	},
	//#}	
	
	//#column_resize:06042008{
	/**
	*     @desc: enable/disable resizing for specified colums
	*     @param: list - list of true/false values, resizing enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableResizing:function(list){
		this._drsclmn=list.split(",");
		
		for (var i = 0; i < this._drsclmn.length; i++)this._drsclmn[i]=dhx4.s2b(this._drsclmn[i]);
	},
	
	/**
	*     @desc: set minimum column width ( works only for manual resizing )
	*     @param: width - minimum column width, can be set for specified column, or as comma separated list for all columns
	*     @param: ind - column index
	*     @type: public
	*     @topic: 0
	*/
	setColumnMinWidth:function(width, ind){
		if (arguments.length == 2){
			if (!this._drsclmW)
				this._drsclmW=new Array();
			this._drsclmW[ind]=width;
		} else
		this._drsclmW=width.split(",");
	},
	//#}	
	
	/**
	*     @desc: enable/disable unique id for cells (id will be automaticaly created using the following template: "c_[RowId]_[colIndex]")
	*     @param: mode - true/false - enable/disable
	*     @type: public
	*     @topic: 0
	*/
	enableCellIds:function(mode){
		this._enbCid=dhx4.s2b(mode);
	},
	
	
	//#locked_row:11052006{
	/**
	*     @desc: lock/unlock row for editing
	*     @param: rowId - id of row
	*     @param: mode - true/false - lock/unlock
	*     @type: public
	*     @topic: 0
	*/
	lockRow:function(rowId, mode){
		var z = this.getRowById(rowId);
		
		if (z){
			z._locked=dhx4.s2b(mode);
			
			if ((this.cell)&&(this.cell.parentNode.idd == rowId))
				this.editStop();
		}
	},
	//#}
	
	/**
	*   @desc:  get values of all cells in row
	*   @type:  private
	*/
	_getRowArray:function(row){
		var text = new Array();
		
		for (var ii = 0; ii < row.childNodes.length; ii++){
			var a = this.cells3(row, ii);
			text[ii]=a.getValue();
		}
		
		return text;
	},
	//#__pro_feature:21092006{	
	//#data_format:12052006{
	/**
	*     @desc: set mask for date formatting in cell
	*     @param: mask - date mask, d,m,y will mean day,month,year; for example "d/m/y" - 22/05/1985
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setDateFormat:function(mask,incoming){
		this._dtmask=mask;
		this._dtmask_inc=incoming;
	},
	
	/**
	*     @desc: set mask for formatting numeric data ( works for [ed/ro]n excell only or oher cell types with suport for this method)
	*     @param: mask - numeric mask; for example 0,000.00 - 1,234.56
	*     @param: cInd - column index
	*     @param: p_sep - char used as decimalseparator ( point by default )
	*     @param: d_sep - char used as groups part separator ( comma by default )
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setNumberFormat:function(mask, cInd, p_sep, d_sep){
		var nmask = mask.replace(/[^0\,\.]*/g, "");
		var pfix = nmask.indexOf(".");
		
		if (pfix > -1)
			pfix=nmask.length-pfix-1;
		var dfix = nmask.indexOf(",");
		
		if (dfix > -1)
			dfix=nmask.length-pfix-2-dfix;
		if (typeof p_sep != "string")
			p_sep=this.i18n.decimal_separator;
		if (typeof d_sep != "string")
			d_sep=this.i18n.group_separator;
		var pref = mask.split(nmask)[0];
		var postf = mask.split(nmask)[1];
		this._maskArr[cInd]=[
			pfix,
			dfix,
			pref,
			postf,
			p_sep,
			d_sep
		];
	},
	/**
	*   @desc:  convert formated value to original
	*   @type:  private
	*/
	_aplNFb:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var ndata = parseFloat(data.toString().replace(/[^0-9]*/g, ""));
		
		if (data.toString().substr(0, 1) == "-")
			ndata=ndata*-1;
		
		if (a[0] > 0)
			ndata=ndata / Math.pow(10, a[0]);
		return ndata;
	},
	
	/**
	*   @desc:  format data with mask
	*   @type:  private
	*/
	_aplNF:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var c = (parseFloat(data) < 0 ? "-" : "")+a[2];
		data=Math.abs(Math.round(parseFloat(data)*Math.pow(10, a[0] > 0 ? a[0] : 0))).toString();
		data=(data.length
			< a[0]
			? Math.pow(10, a[0]+1-data.length).toString().substr(1, a[0]+1)+data.toString()
			: data).split("").reverse();
			data[a[0]]=(data[a[0]]||"0")+a[4];
			
			if (a[1] > 0)
				for (var j = (a[0] > 0 ? 0 : 1)+a[0]+a[1]; j < data.length; j+=a[1])data[j]+=a[5];
			return c+data.reverse().join("")+a[3];
	},
	//#}
	//#}	
	
	//#config_from_xml:20092006{
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_launchCommands:function(arr){
		for (var i = 0; i < arr.length; i++){
			var args = new Array();
			
			for (var j = 0; j < arr[i].childNodes.length; j++)
				if (arr[i].childNodes[j].nodeType == 1)
				args[args.length]=arr[i].childNodes[j].firstChild.data;
			
			this[arr[i].getAttribute("command")].apply(this, args);
		}
	},
	
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_parseHead:function(xmlDoc){
		var hheadCol = dhx4.ajax.xpath("./head", xmlDoc);
		
		if (hheadCol.length){
			var headCol = dhx4.ajax.xpath("./column", hheadCol[0]);
			var asettings = dhx4.ajax.xpath("./settings", hheadCol[0]);
			var awidthmet = "setInitWidths";
			var split = false;
			
			if (asettings[0]){
				for (var s = 0; s < asettings[0].childNodes.length; s++)switch (asettings[0].childNodes[s].tagName){
				case "colwidth":
					if (asettings[0].childNodes[s].firstChild&&asettings[0].childNodes[s].firstChild.data == "%")
						awidthmet="setInitWidthsP";
					break;
					
				case "splitat":
					split=(asettings[0].childNodes[s].firstChild ? asettings[0].childNodes[s].firstChild.data : false);
					break;
				}
			}
			this._launchCommands(dhx4.ajax.xpath("./beforeInit/call", hheadCol[0]));
			
			if (headCol.length > 0){
				if (this.hdr.rows.length > 0) this.clearAll(true); //drop existing grid here, to prevent loss of initialization parameters
				var sets = [
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				];
				
				var attrs = ["", "width", "type", "align", "sort", "color", "format", "hidden", "id"];
				var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", "setColumnColor", "",
				"", "setColumnIds"];
				
				for (var i = 0; i < headCol.length; i++){
					for (var j = 1; j < attrs.length; j++)sets[j].push(headCol[i].getAttribute(attrs[j]));
					sets[0].push((headCol[i].firstChild
						? headCol[i].firstChild.data
						: "").replace(/^\s*((\s\S)*.+)\s*$/gi, "$1"));
				};
				
				this.setHeader(sets[0]);
				for (var i = 0; i < calls.length; i++)
					if (calls[i])
					this[calls[i]](sets[i].join(this.delim))
				
				for (var i = 0; i < headCol.length; i++){
					if ((this.cellType[i].indexOf('co') == 0)||(this.cellType[i] == "clist")){
						var optCol = dhx4.ajax.xpath("./option", headCol[i]);
						
						if (optCol.length){
							var resAr = new Array();
							
							if (this.cellType[i] == "clist"){
								for (var j = 0;
									j < optCol.length;
									j++)resAr[resAr.length]=optCol[j].firstChild
								? optCol[j].firstChild.data
								: "";
								
								this.registerCList(i, resAr);
							} else {
								var combo = this.getCombo(i);
								
								for (var j = 0;
									j < optCol.length;
									j++)combo.put(optCol[j].getAttribute("value"),
										optCol[j].firstChild
										? optCol[j].firstChild.data
										: "");
							}
						}
					}
					
					else if (sets[6][i])
						if ((this.cellType[i].toLowerCase().indexOf("calendar")!=-1)||(this.fldSort[i] == "date"))
						this.setDateFormat(sets[6][i]);
					else
						this.setNumberFormat(sets[6][i], i);
				}
				
				this.init();
				
				var param=sets[7].join(this.delim);
				//preserving state of hidden columns, if not specified directly
				if (this.setColHidden && param.replace(/,/g,"")!="")
					this.setColHidden(param);
				
				if ((split)&&(this.splitAt))
					this.splitAt(split);
			}
			this._launchCommands(dhx4.ajax.xpath("./afterInit/call", hheadCol[0]));
		}
		//global(grid) user data
		var gudCol = dhx4.ajax.xpath("//rows/userdata", xmlDoc);
		
		if (gudCol.length > 0){
			
			if (!this.UserData["gridglobaluserdata"])
				this.UserData["gridglobaluserdata"]=new Hashtable();
			
			for (var j = 0; j < gudCol.length; j++){
				var u_record = "";
				for (var xj=0; xj < gudCol[j].childNodes.length; xj++)
					u_record += gudCol[j].childNodes[xj].nodeValue;
				this.UserData["gridglobaluserdata"].put(gudCol[j].getAttribute("name"),u_record);
			}
		}
	},
	
	
	//#}
	
	
	/**
	*   @desc: get list of Ids of all rows with checked exCell in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/
	getCheckedRows:function(col_ind){
		var d = new Array();
		this.forEachRowA(function(id){
				var cell = this.cells(id, col_ind);
				if (cell.changeState && cell.getValue() != 0)
					d.push(id);
		},true);
		return d.join(",");
	},
	/**
	*   @desc: check all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	checkAll:function(){var mode=arguments.length?arguments[0]:1;
	for (var cInd=0;cInd<this.getColumnsNum();cInd++){if(this.getColType(cInd)=="ch")this.setCheckedRows(cInd,mode)}},
		/**
	*   @desc: uncheck all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	uncheckAll:function(){ this.checkAll(0); },
	/**
	*   @desc: set value for all checkboxes in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	setCheckedRows:function(cInd,v){this.forEachRowA(function(id){if(this.cells(id,cInd).isCheckbox())this.cells(id,cInd).setValue(v)})},
	//#tooltips:06042008{	
	/**
	*   @desc:  grid body onmouseover function
	*   @type:  private
	*/
	_drawTooltip:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (!c || ((this.grid.editor)&&(this.grid.editor.cell == c)))
			return true;
		
		var r = c.parentNode;
		
		if (!r.idd||r.idd == "__filler__")
			return;
		var el = (e ? e.target : event.srcElement);
		
		if (r.idd == window.unknown)
			return true;
		
		if (!this.grid.callEvent("onMouseOver", [
				r.idd,
			c._cellIndex,
			(e||window.event)
		]))
		return true;
		
		if ((this.grid._enbTts)&&(!this.grid._enbTts[c._cellIndex])){
			if (el.title)
				el.title='';
			return true;
		}
		
		if (c._cellIndex >= this.grid._cCount)
			return;
		var ced = this.grid.cells3(r, c._cellIndex);
		if (!ced || !ced.cell || !ced.cell._attrs) return; // fix for public release
		
		if (el._title)
			ced.cell.title="";
		
		if (!ced.cell._attrs['title'])
			el._title=true;
		
		if (ced)
			el.title=ced.cell._attrs['title']
		||(ced.getTitle
			? ced.getTitle()
			: (ced.getValue()||"").toString().replace(/<[^>]*>/gi, ""));
		
		return true;
	},
	//#}	
	/**
	*   @desc:  can be used for setting correction for cell padding, while calculation setSizes
	*   @type:  private
	*/
	enableCellWidthCorrection:function(size){
		if (_isFF)
			this._wcorr=parseInt(size);
	},
	
	
	/**
	*	@desc: gets a list of all row ids in grid
	*	@param: separator - delimiter to use in list
	*	@returns: list of all row ids in grid
	*	@type: public
	*	@topic: 2,7
	*/
	getAllRowIds:function(separator){
		var ar = [];
		
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i])
			ar.push(this.rowsBuffer[i].idd);
		
		return ar.join(separator||this.delim)
	},
	getAllItemIds:function(){
		return this.getAllRowIds();
	},
	
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	
	/**
	*   @desc: dynamicaly set colspan in row starting from specified column index
	*   @param: row_id - row id
	*   @param: col_id - index of column
	*   @param: colspan - size of colspan
	*   @type: public
	*   @edition: Professional
	*   @topic: 2,9
	*/
	setColspan:function(row_id, col_ind, colspan){
		if (!this._ecspn)
			return;
		
		var r = this.getRowById(row_id);
		
		if ((r._childIndexes)&&(r.childNodes[r._childIndexes[col_ind]])){
			var j = r._childIndexes[col_ind];
			var n = r.childNodes[j];
			var m = n.colSpan;
			n.colSpan=1;
			
			if ((m)&&(m != 1))
			for (var i = 1; i < m; i++){
				var c = document.createElement("TD");
				
				if (n.nextSibling)
					r.insertBefore(c, n.nextSibling);
				else
					r.appendChild(c);
				r._childIndexes[col_ind+i]=j+i;
				c._cellIndex=col_ind+i;
				c.style.textAlign=this.cellAlign[i];
				c.style.verticalAlign=this.cellVAlign[i];
				n=c;
				this.cells3(r, col_ind+i).setValue("");
			}
			
			for (var z = col_ind*1+1*m; z < r._childIndexes.length; z++){
				r._childIndexes[z]+=(m-1)*1;
			}
		}
		
		if ((colspan)&&(colspan > 1)){
			if (r._childIndexes)
				var j = r._childIndexes[col_ind];
			else {
				var j = col_ind;
				r._childIndexes=new Array();
				
				for (var z = 0; z < r.childNodes.length; z++)r._childIndexes[z]=z;
			}
			
			r.childNodes[j].colSpan=colspan;
			
			for (var z = 1; z < colspan; z++){
				r._childIndexes[r.childNodes[j+1]._cellIndex]=j;
				r.removeChild(r.childNodes[j+1]);
			}
			
			var c1 = r.childNodes[r._childIndexes[col_ind]]._cellIndex;
			
			for (var z = c1*1+1*colspan; z < r._childIndexes.length; z++)r._childIndexes[z]-=(colspan-1);
		}
	},
	
	//#}
	//#}
	
	/**
	*   @desc: prevent caching in IE  by adding random values to URL string
	*   @param: mode - enable/disable random values in URLs ( disabled by default )
	*   @type: public
	*   @topic: 2,9
	*/
	preventIECaching:function(mode){
		dhx4.ajax.cache = !mode;
	},
	enableColumnAutoSize:function(mode){
		this._eCAS=dhx4.s2b(mode);
	},
	/**
	*   @desc: called when header was dbllicked
	*   @type: private
	*   @topic: 1,2
	*/
	_onHeaderDblClick:function(e){
		var that = this.grid;
		var el = that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (!that._eCAS)
			return false;
		that.adjustColumnSize(el._cellIndexS)
	},
	
	/**
	*   @desc: autosize column  to max content size
	*   @param: cInd - index of column
	*   @type:  public
	*/
	adjustColumnSize:function(cInd, complex){
		if (this._hrrar && this._hrrar[cInd]) return;
		this._notresize=true;
		var m = 0;
		this._setColumnSizeR(cInd, 20);
		
		for (var j = 1; j < this.hdr.rows.length; j++){
			var a = this.hdr.rows[j];
			a=a.childNodes[(a._childIndexes) ? a._childIndexes[cInd] : cInd];
			
			if ((a)&&((!a.colSpan)||(a.colSpan < 2)) && a._cellIndex==cInd){
				if ((a.childNodes[0])&&(a.childNodes[0].className == "hdrcell"))
					a=a.childNodes[0];
				m=Math.max(m, a.scrollWidth);
			}
		}
		
		var l = this.obj.rows.length;
		var z = 0;
		var tree = this.cellType._dhx_find("tree");
		
		for (var i = 1; i < l; i++){
			var row = this.obj.rows[i];
			var col = cInd;
			if (!this.rowsAr[row.idd]) continue;
			
			if (row._childIndexes){
				if (row._childIndexes[cInd] == row._childIndexes[cInd+1] )
					continue;
				col = row._childIndexes[cInd];
			}

			if (!row.childNodes[col] || row.childNodes[col]._cellIndex != cInd)
				continue;

			z= ( row.childNodes[col].innerText || row.childNodes[col].textContent || "" ).length*this.fontWidth;
			if (this._h2 && cInd == tree)
				z += this._h2.get[row.idd].level * 22;
			
			
			
			if (z > m)
				m=z;
		}
		m+=20+(complex||0);
		
		this._setColumnSizeR(cInd, m);
		this._notresize=false;
		this.setSizes();
	},
	
	//#header_footer:06042008{
	/**
	*   @desc: remove header line from grid (opposite to attachHeader)
	*   @param: index - index of row to be removed ( zero based )
	*	@param: hdr - header object (optional)
	*   @type:  public
	*/
	detachHeader:function(index, hdr){
		hdr=hdr||this.hdr;
		var row = hdr.rows[index+1];
		
		if (row)
			row.parentNode.removeChild(row);
		this.setSizes();
	},
	
	/**
	*   @desc: remove footer line from grid (opposite to attachFooter)
	*   @param: values - array of header titles
	*   @type:  public
	*/
	detachFooter:function(index){
		this.detachHeader(index, this.ftr);
	},
	
	/**
	*   @desc: attach additional line to header
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*	@param: _type - reserved
	*   @type:  public
	*/
	attachHeader:function(values, style, _type){
		if (typeof (values) == "string")
			values=this._eSplit(values);
		
		if (typeof (style) == "string")
			style=style.split(this.delim);
		_type=_type||"_aHead";
		
		if (this.hdr.rows.length){
			if (values)
			this._createHRow([
					values,
					style
				], this[(_type == "_aHead") ? "hdr" : "ftr"]);
			
			else if (this[_type])
				for (var i = 0; i < this[_type].length; i++)this.attachHeader.apply(this, this[_type][i]);
		} else {
			if (!this[_type])
				this[_type]=new Array();
			this[_type][this[_type].length]=[
				values,
				style,
				_type
			];
		}
	},
	/**
	*	@desc:
	*	@type: private
	*/
	_createHRow:function(data, parent){
		if (!parent){
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			var z = document.createElement("DIV");
			z.className="c_ftr".substr(2);
			this.entBox.appendChild(z);
			var t = document.createElement("TABLE");
			t.cellPadding=t.cellSpacing=0;
			
			if (!_isIE || _isIE == 8){
				t.width="100%";
				t.style.paddingRight="20px";
			}
			t.style.marginRight="20px";
			t.style.tableLayout="fixed";
			
			z.appendChild(t);
			t.appendChild(document.createElement("TBODY"));
			this.ftr=parent=t;
			
			var hdrRow = t.insertRow(0);
			var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
			
			for (var i = 0; i < thl; i++){
				hdrRow.appendChild(document.createElement("TH"));
				hdrRow.childNodes[i]._cellIndex=i;
			}
			
			if (_isIE && _isIE<8)
				hdrRow.style.position="absolute";
			else
				hdrRow.style.height='auto';
		}
		var st1 = data[1];
		var z = document.createElement("TR");
		parent.rows[0].parentNode.appendChild(z);
		
		for (var i = 0; i < data[0].length; i++){
			if (data[0][i] == "#cspan"){
				var pz = z.cells[z.cells.length-1];
				pz.colSpan=(pz.colSpan||1)+1;
				continue;
			}
			
			if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
				var pind = parent.rows.length-2;
				var found = false;
				var pz = null;
				
				while (!found){
					var pz = parent.rows[pind];
					
					for (var j = 0; j < pz.cells.length; j++)
					if (pz.cells[j]._cellIndex == i){
						found=j+1;
						break;
					}
					pind--;
				}
				
				pz=pz.cells[found-1];
				pz.rowSpan=(pz.rowSpan||1)+1;
				continue;
				//            data[0][i]="";
			}
			
			var w = document.createElement("TD");
			w._cellIndex=w._cellIndexS=i;
			if (this._hrrar && this._hrrar[i] && !_isIE)
				w.style.display='none';
			
			if (typeof data[0][i] == "object")
				w.appendChild(data[0][i]);
			else {
				if (this.forceDivInHeader)
					w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
				else
					w.innerHTML=(data[0][i]||"&nbsp;");
				
				if ((data[0][i]||"").indexOf("#") != -1){
					var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
					
					if (t){
						var tn = "_in_header_"+t[2];
						
						if (this[tn])
							this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
					}
				}
			}
			if (st1)
				w.style.cssText=st1[i];
			
			z.appendChild(w);
		}
		var self = parent;
		
		if (_isKHTML){
			if (parent._kTimer)
				window.clearTimeout(parent._kTimer);
			parent._kTimer=window.setTimeout(function(){
					parent.rows[1].style.display='none';
					window.setTimeout(function(){
							parent.rows[1].style.display='';
					}, 1);
			}, 500);
		}
	},
	//#__pro_feature:21092006{	
	/**
	*   @desc: attach additional line to footer
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*   @edition: Professional
	*   @type:  public
	*/
	attachFooter:function(values, style){
		this.attachHeader(values, style, "_aFoot");
	},
	//#}
	//#}
	//#__pro_feature:21092006{
	//#dyn_cell_types:04062008{
	/**
	*   @desc: set excell type for cell in question
	*   @param: rowId - row ID
	*   @param: cellIndex - cell index
	*   @param: type - type of excell (code like "ed", "txt", "ch" etc.)
	*   @edition: Professional
	*   @type:  public
	*/
	setCellExcellType:function(rowId, cellIndex, type){
		this.changeCellType(this.getRowById(rowId), cellIndex, type);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	changeCellType:function(r, ind, type){
		type=type||this.cellType[ind];
		var z = this.cells3(r, ind);
		var v = z.getValue();
		z.cell._cellType=type;
		var z = this.cells3(r, ind);
		z.setValue(v);
	},
	/**
	*   @desc: set excell type for all cells in specified row
	*   @param: rowId - row ID
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setRowExcellType:function(rowId, type){
		var z = this.rowsAr[rowId];
		
		for (var i = 0; i < z.childNodes.length; i++)this.changeCellType(z, i, type);
	},
	/**
	*   @desc: set excell type for all cells in specified column
	*   @param: colIndex - column index
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setColumnExcellType:function(colIndex, type){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName=="TR")
			this.changeCellType(this.rowsBuffer[i], colIndex, type);
		if (this.cellType[colIndex]=="math")
			this._strangeParams[i]=type;
		else
			this.cellType[colIndex]=type;
	},
	
	//#}
	//#}
	
	/**
	*   @desc: execute code for each row in a grid
	*   @param: custom_code - function which get row id as incomming argument
	*   @type:  public
	*/
	forEachRow:function(custom_code){
		for (var a in this.rowsAr)
			if (this.rowsAr[a]&&this.rowsAr[a].idd)
			custom_code.apply(this, [this.rowsAr[a].idd]);
	},
	forEachRowA:function(custom_code){
		for (var a =0; a<this.rowsBuffer.length; a++){
			if (this.rowsBuffer[a])
				custom_code.call(this, this.render_row(a).idd);
		}
	},
	/**
	*   @desc: execute code for each cell in a row
	*   @param: rowId - id of row where cell must be itterated
	*   @param: custom_code - function which get eXcell object as incomming argument
	*   @type:  public
	*/
	forEachCell:function(rowId, custom_code){
		var z = this.getRowById(rowId);
		
		if (!z)
			return;
		
		for (var i = 0; i < this._cCount; i++) custom_code(this.cells3(z, i),i);
	},
	/**
	*   @desc: changes grid's container size on the fly to fit total width of grid columns
	*   @param: mode  - truse/false - enable / disable
	*   @param: max_limit  - max allowed width, not limited by default
	*   @param: min_limit  - min allowed width, not limited by default
	*   @type:  public
	*/
	enableAutoWidth:function(mode, max_limit, min_limit){
		this._awdth=[
			dhx4.s2b(mode),
			parseInt(max_limit||99999),
			parseInt(min_limit||0)
		];
		if (arguments.length == 1)
			this.objBox.style.overflowX=mode?"hidden":"auto";
	},
	//#update_from_xml:06042008{	
	/**
	*   @desc: refresh grid from XML ( doesnt work for buffering, tree grid or rows in smart rendering mode )
	*   @param: insert_new - insert new items
	*   @param: del_missed - delete missed rows
	*   @param: afterCall - function, will be executed after refresh completted
	*   @type:  public
	*/
	
	updateFromXML:function(url, insert_new, del_missed, afterCall){
		if (typeof insert_new == "undefined")
			insert_new=true;
		this._refresh_mode=[
			true,
			insert_new,
			del_missed
		];
		this.load(url,afterCall)
	},
	_refreshFromXML:function(xml){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
				this.setValueX(content);
			};
		}
		
		var tree = this.cellType._dhx_find("tree");
		var top = dhx4.ajax.xmltop("rows", xml);
		var pid = top.getAttribute("parent")||0;
		
		var del = {
		};
		
		if (this._refresh_mode[2]){
			if (tree != -1)
			this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
			}, this);
			else
			this.forEachRow(function(id){
					del[id]=true;
			});
		}
		
		var rows = dhx4.ajax.xpath("//row", top);
		
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.getAttribute("id");
			del[id]=false;
			var pid = row.parentNode.getAttribute("id")||pid;
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
				this._process_xml_row(this.rowsAr[id], row, -1);
				this._postRowProcessing(this.rowsAr[id],true)
				if (this._fake && this._fake.rowsAr[id])
					this._fake._process_xml_row(this._fake.rowsAr[id], row, -1);
			} else if (this._refresh_mode[1]){
				var dadd={
					idd: id,
					data: row,
					_parser: this._process_xml_row,
					_locator: this._get_xml_data
				};
				
				var render_index = this.rowsBuffer.length;
				if (this._refresh_mode[1]=="top"){
					this.rowsBuffer.unshift(dadd);
					render_index = 0;
				} else
				this.rowsBuffer.push(dadd);
				
				if (this._h2){ 
					reset=true;
					(this._h2.add(id,(row.parentNode.getAttribute("id")||row.parentNode.getAttribute("parent")))).buff=this.rowsBuffer[this.rowsBuffer.length-1];
				} else if (this._srnd)
				reset = true;
				
				this.rowsAr[id]=row;
				row=this.render_row(render_index);
				this._insertRowAt(row,render_index?-1:0)
			}
		}
		
		if (this._refresh_mode[2])
		for (id in del){
			if (del[id]&&this.rowsAr[id])
				this.deleteRow(id);
		}
		
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
		
		if (reset){
			if (this._h2) 
				this._renderSort();
			else
				this.render_dataset();
		}
		
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},
	//#}	
	//#co_excell:06042008{
	/**
	*   @desc: get combobox specific for cell in question
	*   @param: id - row id
	*   @param: ind  - column index
	*   @type:  public
	*/
	getCustomCombo:function(id, ind){
		var cell = this.cells(id, ind).cell;
		
		if (!cell._combo)
			cell._combo=new dhtmlXGridComboObject();
		return cell._combo;
	},
	//#}
	/**
	*   @desc: set tab order of columns
	*   @param: order - list of tab indexes (default delimiter is ",")
	*   @type:  public
	*/
	setTabOrder:function(order){
		var t = order.split(this.delim);
		this._tabOrder=[];
		var max=this._cCount||order.length;
		
		for (var i = 0; i < max; i++)t[i]={
			c: parseInt(t[i]),
			ind: i
		};
		t.sort(function(a, b){
				return (a.c > b.c ? 1 : -1);
		});
		
		for (var i = 0; i < max; i++)
			if (!t[i+1]||( typeof t[i].c == "undefined"))
			this._tabOrder[t[i].ind]=(t[0].ind+1)*-1;
		else
			this._tabOrder[t[i].ind]=t[i+1].ind;
	},
	
	i18n:{
		loading: "Loading",
		decimal_separator:".",
		group_separator:","
	},
	
	//key_ctrl_shift
	_key_events:{
		k13_1_0: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd+1], this.cell._cellIndex, true);
		},
		k13_0_1: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd-1], this.cell._cellIndex, true);
		},
		k13_0_0: function(){
			this.editStop();
			this.callEvent("onEnter", [
					(this.row ? this.row.idd : null),
					(this.cell ? this.cell._cellIndex : null)
			]);
			this._still_active=true;
		},
		k9_0_0: function(){
			this.editStop();
			if (!this.callEvent("onTab",[true])) return true;
			var z = this._getNextCell(null, 1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k9_0_1: function(){
			this.editStop();
			if (!this.callEvent("onTab",[false])) return false;
			var z = this._getNextCell(null, -1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k113_0_0: function(){
			if (this._f2kE)
				this.editCell();
		},
		k32_0_0: function(){
			var c = this.cells4(this.cell);
			
			if (!c.changeState||(c.changeState() === false))
				return false;
		},
		k27_0_0: function(){
			this.editStop(true);
		},
		k33_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage-1);
			else
				this.scrollPage(-1);
		},
		k34_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage+1);
			else
				this.scrollPage(1);
		},
		k37_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.collapseKids(this.row)
			else
				return false;
		},
		k39_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.expandKids(this.row)
			else
				return false;
		},
		k40_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftNext();
			else {
				if (!this.row.idd) return;
				var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
				var row = this._nextRow(rowInd, 1);
				if (row){
					master._r_select=null;
					this.selectCell(row, this.cell._cellIndex, true);
					if (master.pagingOn) master.showRow(row.idd);
				} else {
					if (!this.callEvent("onLastRow", [])) return false;
					this._key_events.k34_0_0.apply(this, []);
					if (this.pagingOn && this.rowsCol[rowInd+1])
						this.selectCell(rowInd+1, 0, true);
				}
			}
			this._still_active=true;
		},
		k38_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftPrev();
			else {
				if (!this.row.idd) return;
				var rowInd = this.getRowIndex(this.row.idd)+1;
				if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
					var nrow = this._nextRow(rowInd-1, -1);
					this.selectCell(nrow, this.cell._cellIndex, true);
					if (master.pagingOn && nrow) master.showRow(nrow.idd);
				} else {
					this._key_events.k33_0_0.apply(this, []);
					/*
					if (this.pagingOn && this.rowsCol[this.rowsBufferOutSize-1])
					this.selectCell(this.rowsBufferOutSize-1, 0, true);
					*/
				}
			}
			this._still_active=true;
		}
	},
	
	//(c)dhtmlx ltd. www.dhtmlx.com
	
	_build_master_row:function(){
		var t = document.createElement("DIV");
		var html = ["<table><tr>"];
		
		for (var i = 0; i < this._cCount; i++)html.push("<td></td>");
		html.push("</tr></table>");
		t.innerHTML=html.join("");
		this._master_row=t.firstChild.rows[0];
	},
	
	_prepareRow:function(new_id){ /*TODO: hidden columns */
		if (!this._master_row)
			this._build_master_row();
		
		var r = this._master_row.cloneNode(true);
		
		for (var i = 0; i < r.childNodes.length; i++){
			r.childNodes[i]._cellIndex=i;
			if (this._enbCid) r.childNodes[i].id="c_"+new_id+"_"+i;
			if (this.dragAndDropOff)
				this.dragger.addDraggableItem(r.childNodes[i], this);
		}
		r.idd=new_id;
		r.grid=this;
		
		return r;
	},
	
	//#non_xml_data:06042008{
	_process_jsarray_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data) : data));
		return r;
	},
	_get_jsarray_data:function(data, ind){
		return data[ind];
	},
	_process_json_row:function(r, data){
		data = this._c_order ? this._swapColumns(data.data) : data.data;
		return this._process_some_row(r, data);
	},
	_process_some_row:function(r,data){
		r._attrs={};
		
		for (var j = 0; j < r.childNodes.length; j++)
			r.childNodes[j]._attrs={};
		
		this._fillRow(r, data);
		return r;
	},
	_get_json_data:function(data, ind){
		return data.data[ind];
	},
	
	
	_process_js_row:function(r, data){
		var arr = [];
		for (var i=0; i<this.columnIds.length; i++){
			arr[i] = data[this.columnIds[i]];
			if (!arr[i] && arr[i]!==0)
				arr[i]="";
		}
		this._process_some_row(r,arr);
		
		r._attrs = data;
		return r;
	},
	_get_js_data:function(data, ind){
		return data[this.columnIds[ind]];
	},
	_process_csv_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data.split(this.csv.cell)) : data.split(this.csv.cell)));
		return r;
	},
	_get_csv_data:function(data, ind){
		return data.split(this.csv.cell)[ind];
	},
	//#}
	_process_store_row:function(row, data){
		var result = [];
		for (var i = 0; i < this.columnIds.length; i++)
			result[i] = data[this.columnIds[i]];
		for (var j = 0; j < row.childNodes.length; j++)
			row.childNodes[j]._attrs={};
		
		row._attrs = data;
		this._fillRow(row, result);
	},	
	//#xml_data:06042008{
	_process_xml_row:function(r, xml){		
		var cellsCol = dhx4.ajax.xpath(this.xml.cell, xml);
		var strAr = [];
		
		r._attrs=this._xml_attrs(xml);
		
		//load userdata
		if (this._ud_enabled){
			var udCol = dhx4.ajax.xpath("./userdata", xml);
			
			for (var i = udCol.length-1; i >= 0; i--){
				var u_record = "";
				for (var j=0; j < udCol[i].childNodes.length; j++)
					u_record += udCol[i].childNodes[j].nodeValue;
				
				this.setUserData(r.idd,udCol[i].getAttribute("name"), u_record);
			}
		}
		
		//load cell data
		for (var j = 0; j < cellsCol.length; j++){
			var cellVal = cellsCol[this._c_order?this._c_order[j]:j];
			if (!cellVal) continue;
			var cind = r._childIndexes?r._childIndexes[j]:j;
			var exc = cellVal.getAttribute("type");
			
			if (r.childNodes[cind]){
				if (exc)
					r.childNodes[cind]._cellType=exc;
				r.childNodes[cind]._attrs=this._xml_attrs(cellVal);
			}
			
			if (!cellVal.getAttribute("xmlcontent")){
				if (cellVal.firstChild)
					cellVal=cellVal.firstChild.wholeText||cellVal.firstChild.data;
				else
					cellVal="";
			}
			
			strAr.push(cellVal);
		}
		
		for (j < cellsCol.length; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		//treegrid
		if (r.parentNode&&r.parentNode.tagName == "row")
			r._attrs["parent"]=r.parentNode.getAttribute("idd");
		
		//back to common code
		this._fillRow(r, strAr);
		return r;
	},
	_get_xml_data:function(data, ind){ 
		data=data.firstChild;
		
		while (true){
			if (!data)
				return "";
			
			if (data.tagName == "cell")
				ind--;
			
			if (ind < 0)
				break;
			data=data.nextSibling;
		}
		return (data.firstChild ? data.firstChild.data : "");
	},
	//#}	
	_fillRow:function(r, text){
		if (this.editor && this.editor.parentNode && this.editor.parentNode.idd == r.idd)
			this.editStop();
		
		for (var i = 0; i < r.childNodes.length; i++){
			if ((i < text.length)||(this.defVal[i])){
				
				var ii=r.childNodes[i]._cellIndex;
				var val = text[ii];
				var aeditor = this.cells4(r.childNodes[i]);
				
				if ((this.defVal[ii])&&((val == "")||( typeof (val) == "undefined")))
					val=this.defVal[ii];
				
				if (aeditor) aeditor.setValue(val)
			} else {
				r.childNodes[i].innerHTML="&nbsp;";
				r.childNodes[i]._clearCell=true;
			}
		}
		
		return r;
	},
	
	_postRowProcessing:function(r,donly){ 
		if (r._attrs["class"])
			r._css=r.className=r._attrs["class"];
		
		if (r._attrs.locked)
			r._locked=true;
		
		if (r._attrs.bgColor)
			r.bgColor=r._attrs.bgColor;
		var cor=0;	
		
		for (var i = 0; i < r.childNodes.length; i++){
			var c=r.childNodes[i];
			var ii=c._cellIndex;
			//style attribute
			var s = c._attrs.style||r._attrs.style;
			
			if (s)
				c.style.cssText+=";"+s;
			
			if (c._attrs["class"])
				c.className=c._attrs["class"];
			s=c._attrs.align||this.cellAlign[ii];
			
			
			if (s)
				c.align=s;
			c.vAlign=c._attrs.valign||this.cellVAlign[ii];
			var color = c._attrs.bgColor||this.columnColor[ii];
			
			
			if (color)
				c.bgColor=color;
			
			if (c._attrs["colspan"] && !donly){ 
				this.setColspan(r.idd, i+cor, c._attrs["colspan"]);
				//i+=(c._attrs["colspan"]-1);
				cor+=(c._attrs["colspan"]-1);
			}
			
			if (this._hrrar&&this._hrrar[ii]&&!donly){
				c.style.display="none";
			}
		};
		this.callEvent("onRowCreated", [
				r.idd,
				r,
				null
		]);
	},
	/**
	*   @desc: load data from external file ( xml, json, jsarray, csv )
	*   @param: url - url to external file
	*   @param: call - after loading callback function, optional, can be ommited
	*   @param: type - type of data (xml,csv,json,jsarray) , optional, xml by default
	*   @type:  public
	*/			
	load:function(url, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;
		
		this.xmlLoader = this.doLoadDetails;
		
		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc,type]);
			
			if (call){
				call();
				call=null;
			}
		};
		return dhx4.ajax.get(url, this.xmlLoader);
	},
	//#__pro_feature:21092006{		
	loadXMLString:function(str, afterCall){
		if (window.console && window.console.info)
          window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.parse( { responseXML: dhx4.ajax.parse(str) }, afterCall, "xml")
	},
	//#}
	loadXML:function(url, afterCall){
		if (window.console && window.console.info)
        	window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.load(url, afterCall, "xml")
	},
	/**
	*   @desc: load data from local datasource ( xml string, csv string, xml island, xml object, json objecs , javascript array )
	*   @param: data - string or object
	*   @param: type - data type (xml,json,jsarray,csv), optional, data threated as xml by default
	*   @type:  public
	*/			
	parse:function(data, call, type){
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
		this._data_type=type;
		
		if (type == "xml" && typeof data == "string")
			data = { responseXML: dhx4.ajax.parse(data) };
		
		this["_process_"+type](data);
		if (!this._contextCallTimer)
			this.callEvent("onXLE", [this,0,0,data,type]);
		if (call)
			call();
	},
	
	xml:{
		top: "rows",
		row: "./row",
		cell: "./cell",
		s_row: "row",
		s_cell: "cell",
		row_attrs: [],
		cell_attrs: []
	},
	
	csv:{
		row: "\n",
		cell: ","
	},
	
	_xml_attrs:function(node){
		var data = {
		};
		
		if (node.attributes.length){
			for (var i = 0; i < node.attributes.length; i++)data[node.attributes[i].name]=node.attributes[i].value;
		}
		
		return data;
	},
	//#xml_data:06042008{	
	_process_xml:function(xhr){
		if (this._refresh_mode) return this._refreshFromXML(xhr);
		this._parsing=true;
		var top = dhx4.ajax.xmltop(this.xml.top, xhr);
		if (top.tagName!=this.xml.top) return;
		var skey = top.getAttribute("dhx_security");
		if (skey)
			dhtmlx.security_key = skey;
		
		//#config_from_xml:20092006{
		this._parseHead(top);
		//#}
		var rows = dhx4.ajax.xpath(this.xml.row, top)
		var cr = parseInt(top.getAttribute("pos")||0);
		var total = parseInt(top.getAttribute("total_count")||0);
		if (!this.pagingOn)
			var total = Math.min(total, 32000000/this._srdh);
		
		var reset = false;
		if (total && total!=this.rowsBuffer.length){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
				this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
		
		
		if (this.isTreeGrid())
			return this._process_tree_xml(top);
		
		
		for (var i = 0; i < rows.length; i++){
			if (this.rowsBuffer[i+cr])
				continue;
			var id = rows[i].getAttribute("id")||(i+cr+1);
			this.rowsBuffer[i+cr]={
				idd: id,
				data: rows[i],
				_parser: this._process_xml_row,
				_locator: this._get_xml_data
			};
			
			this.rowsAr[id]=rows[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
	},
	//#}
	//#non_xml_data:06042008{	
	_process_jsarray:function(data){
		this._parsing=true;
		data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		for (var i = 0; i < data.length; i++){
			var id = i+1;
			this.rowsBuffer.push({
					idd: id,
					data: data[i],
					_parser: this._process_jsarray_row,
					_locator: this._get_jsarray_data
			});
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_csv:function(data){
		this._parsing=true;
		data=data.responseText || data;
		data=data.replace(/\r/g,"");
		data=data.split(this.csv.row);
		if (this._csvHdr){
   			this.clearAll();
   			var thead=data.splice(0,1)[0].split(this.csv.cell);
   			if (!this._csvAID) thead.splice(0,1);
	   		this.setHeader(thead.join(this.delim));
	   		this.init();
   		}
   		
		for (var i = 0; i < data.length; i++){
			if (!data[i] && i==data.length-1) continue; //skip new line at end of text
			if (this._csvAID){
				var id = i+1;
				this.rowsBuffer.push({
						idd: id,
						data: data[i],
						_parser: this._process_csv_row,
						_locator: this._get_csv_data
				});
			} else {
				var temp = data[i].split(this.csv.cell);
				var id = temp.splice(0,1)[0];
				this.rowsBuffer.push({
						idd: id,
						data: temp,
						_parser: this._process_jsarray_row,
						_locator: this._get_jsarray_data
				});
			}
			
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_js:function(data){
		return this._process_json(data, "js");
	},
	
	_process_json:function(data, mode){
		this._parsing=true;
		
		var data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer.push({
						idd: id,
						data: row,
						_parser: this._process_js_row,
						_locator: this._get_js_data
				});
				
				this.rowsAr[id]=data[i];
			}
		} else {
			if (data.rows){
				for (var i = 0; i < data.rows.length; i++){
					var id = data.rows[i].id;
					this.rowsBuffer.push({
							idd: id,
							data: data.rows[i],
							_parser: this._process_json_row,
							_locator: this._get_json_data
					});
					
					this.rowsAr[id]=data.rows[i];
				}
			}
		}
		if (data.dhx_security)
			dhtmlx.security_key = data.dhx_security;
		
		this.callEvent("onDataReady", []);
		this.render_dataset();
		this._parsing=false;
	},
	//#}	
	render_dataset:function(min, max){ 
		//normal mode - render all
		//var p=this.obj.parentNode;
		//p.removeChild(this.obj,true)
		if (this._srnd){
			if (this._fillers)
				return this._update_srnd_view();
			
			max=Math.min((this._get_view_size()+(this._srnd_pr||0)), this.rowsBuffer.length);
			
		}
		
		if (this.pagingOn){
			min=Math.max((min||0),(this.currentPage-1)*this.rowsBufferOutSize);
			max=Math.min(this.currentPage*this.rowsBufferOutSize, this.rowsBuffer.length)
		} else {
			min=min||0;
			max=max||this.rowsBuffer.length;
		}
		
		for (var i = min; i < max; i++){
			var r = this.render_row(i)
			
			if (r == -1){
				if (this.xmlFileUrl){
					if (this.callEvent("onDynXLS",[i,(this._dpref?this._dpref:(max-i))]))
						this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+(this._dpref?this._dpref:(max-i)), this._data_type);
				}
				max=i;
				break;
			}
			
			if (!r.parentNode||!r.parentNode.tagName){ 
				this._insertRowAt(r, i);
				if (r._attrs["selected"] || r._attrs["select"]){
					this.selectRow(r,r._attrs["call"]?true:false,true);
					r._attrs["selected"]=r._attrs["select"]=null;
				}
			}
			
			
			if (this._ads_count && i-min==this._ads_count){
				var that=this;
				this._context_parsing=this._context_parsing||this._parsing;
				return this._contextCallTimer=window.setTimeout(function(){
						that._contextCallTimer=null;
						that.render_dataset(i,max);
						if (!that._contextCallTimer){
							if(that._context_parsing)
								that.callEvent("onXLE",[])
							else 
								that._fixAlterCss();
							that._context_parsing=false;
						}
				},this._ads_time)
			}
		}
		if (this._ads_count && i == max)
			this.callEvent("onDistributedEnd",[]);
		
		if (this._srnd&&!this._fillers){
			var add_count = this.rowsBuffer.length-max;
			this._fillers = [];
			if (this._fake && !this._realfake) this._fake._fillers = [];
			
			var block_size = Math.round(990000/this._srdh);
			while (add_count > 0){
				var add_step = (_isIE || window._FFrv)?Math.min(add_count, block_size):add_count;
				var new_filler = this._add_filler(max, add_step);
				if (new_filler)
					this._fillers.push(new_filler);
				add_count -= add_step;
				max += add_step;
			}				
		}
		
		//p.appendChild(this.obj)
		this.setSizes();
	},
	
	render_row:function(ind){
		if (!this.rowsBuffer[ind])
			return -1;
		
		if (this.rowsBuffer[ind]._parser){
			var r = this.rowsBuffer[ind];
			if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
				return this.rowsBuffer[ind]=this.rowsAr[r.idd];
			var row = this._prepareRow(r.idd);
			this.rowsBuffer[ind]=row;
			this.rowsAr[r.idd]=row;
			
			r._parser.call(this, row, r.data);
			this._postRowProcessing(row);
			return row;
		}
		return this.rowsBuffer[ind];
	},
	
	
	_get_cell_value:function(row, ind, method){
		if (row._locator){
			/*if (!this._data_cache[row.idd])
			this._data_cache[row.idd]=[];
			if (this._data_cache[row.idd][ind]) 
			return this._data_cache[row.idd][ind];
			else
			return this._data_cache[row.idd][ind]=row._locator.call(this,row.data,ind);
			*/
			if (this._c_order)
				ind=this._c_order[ind];
			return row._locator.call(this, row.data, ind);
		}
		return this.cells3(row, ind)[method ? method : "getValue"]();
	},
	//#sorting:06042008{	
	/**
	*   @desc: sort grid
	*   @param: col - index of column, by which grid need to be sorted
	*   @param: type - sorting type (str,int,date), optional, by default sorting type taken from column setting
	*   @param: order - sorting order (asc,des), optional, by default sorting order based on previous sorting operation
	*   @type:  public
	*/		
	sortRows:function(col, type, order){
		this.editStop();
		//default values
		order=(order||"asc").toLowerCase();
		type=(type||this.fldSort[col]);
		col=col||0;
		
		if (this.isTreeGrid())
			this.sortTreeRows(col, type, order);
		else{
			
			var arrTS = {
			};
			
			var atype = this.cellType[col];
			var amet = "getValue";
			
			if (atype == "link")
				amet="getContent";
			
			if (atype == "dhxCalendar"||atype == "dhxCalendarA")
				amet="getDate";
			
			for (var i = 0;
				i < this.rowsBuffer.length;
				i++)arrTS[this.rowsBuffer[i].idd]=this._get_cell_value(this.rowsBuffer[i], col, amet);
				
				this._sortRows(col, type, order, arrTS);
		}
		this.callEvent("onAfterSorting", [col,type,order]);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	_sortCore:function(col, type, order, arrTS, s){
		var sort = "sort";
		
		if (this._sst){
			s["stablesort"]=this.rowsCol.stablesort;
			sort="stablesort";
		}
		//#__pro_feature:21092006{	
		//#custom_sort:21092006{
		if (type.length > 4)
			type=window[type];
		
		if (type == 'cus'){
			var cstr=this._customSorts[col];
			s[sort](function(a, b){
					return cstr(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else if (typeof (type) == 'function'){
			s[sort](function(a, b){
					return type(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else
			//#}
		//#}
		if (type == 'str'){
			s[sort](function(a, b){
					if (order == "asc")
						return arrTS[a.idd] > arrTS[b.idd] ? 1 : (arrTS[a.idd] < arrTS[b.idd] ? -1 : 0);
					else
						return arrTS[a.idd] < arrTS[b.idd] ? 1 : (arrTS[a.idd] > arrTS[b.idd] ? -1 : 0);
			});
		}
		else if (type == 'int'){
			s[sort](function(a, b){
					var aVal = parseFloat(arrTS[a.idd]);
					aVal=isNaN(aVal) ? -99999999999999 : aVal;
					var bVal = parseFloat(arrTS[b.idd]);
					bVal=isNaN(bVal) ? -99999999999999 : bVal;
					
					if (order == "asc")
						return aVal-bVal;
					else
						return bVal-aVal;
			});
		}
		else if (type == 'date'){
			s[sort](function(a, b){
					var aVal = Date.parse(arrTS[a.idd])||(Date.parse("01/01/1900"));
					var bVal = Date.parse(arrTS[b.idd])||(Date.parse("01/01/1900"));
					
					if (order == "asc")
						return aVal-bVal
					else
						return bVal-aVal
			});
		}
	},
	/**
	*   @desc: inner sorting routine
	*   @type: private
	*   @topic: 7
	*/
	_sortRows:function(col, type, order, arrTS){
		this._sortCore(col, type, order, arrTS, this.rowsBuffer);
		this._reset_view();
		this.callEvent("onGridReconstructed", []);
	},
	//#}		
	_reset_view:function(skip){
		if (!this.obj.rows[0]) return;
		if (this._lahRw) this._unsetRowHover(0, true); //remove hovering during reset
		this.callEvent("onResetView",[]);
		var tb = this.obj.rows[0].parentNode;
		var tr = tb.removeChild(tb.childNodes[0], true)
		if (_isKHTML) //Safari 2x
			for (var i = tb.parentNode.childNodes.length-1; i >= 0; i--) { if (tb.parentNode.childNodes[i].tagName=="TR") tb.parentNode.removeChild(tb.parentNode.childNodes[i],true); }
		else if (_isIE)
			for (var i = tb.childNodes.length-1; i >= 0; i--) tb.childNodes[i].removeNode(true);
		else
			tb.innerHTML="";
		tb.appendChild(tr)
		this.rowsCol=dhtmlxArray();
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		if (!skip){
			if (_isIE && this._srnd){
				// var p=this._get_view_size;
				// this._get_view_size=function(){ return 1; }
				this.render_dataset();
				// this._get_view_size=p;
			}
			else
				this.render_dataset();
		}
		
		
	},
	
	/**
	*   @desc: delete row from the grid
	*   @param: row_id - row ID
	*   @type:  public
	*/		
	deleteRow:function(row_id, node){
		if (!node)
			node=this.getRowById(row_id)
		
		if (!node)
			return;
		
		this.editStop();
		if (!this._realfake)
			if (this.callEvent("onBeforeRowDeleted", [row_id]) == false)
			return false;
		
		var pid=0;
		if (this.cellType._dhx_find("tree") != -1 && !this._realfake){
			pid=this._h2.get[row_id].parent.id;
			this._removeTrGrRow(node);
		}
		else {
			if (node.parentNode)
				node.parentNode.removeChild(node);
			
			var ind = this.rowsCol._dhx_find(node);
			
			if (ind != -1)
				this.rowsCol._dhx_removeAt(ind);
			
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id){
				this.rowsBuffer._dhx_removeAt(i);
				ind=i;
				break;
			}
		}
		this.rowsAr[row_id]=null;
		
		for (var i = 0; i < this.selectedRows.length; i++)
			if (this.selectedRows[i].idd == row_id)
			this.selectedRows._dhx_removeAt(i);
		
		if (this._srnd){
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i]
				if (!f) continue; //can be null	
				if (f[0] >= ind)
					this._update_fillers(i, 0, -1);
				else if (f[0]+f[1] > ind)
					this._update_fillers(i, -1, 0);
			};
			
			this._update_srnd_view();
		}
		
		if (this.pagingOn)
			this.changePage();
		if (!this._realfake)  this.callEvent("onAfterRowDeleted", [row_id,pid]);
		this.callEvent("onGridReconstructed", []);
		if (this._ahgr) this.setSizes();
		return true;
	},
	
	_addRow:function(new_id, text, ind){
		if (ind == -1|| typeof ind == "undefined")
			ind=this.rowsBuffer.length;
		if (typeof text == "string") text=text.split(this.delim);
		var row = this._prepareRow(new_id);
		row._attrs={
		};
		
		for (var j = 0; j < row.childNodes.length; j++)row.childNodes[j]._attrs={
		};
		
		
		this.rowsAr[row.idd]=row;
		if (this._h2) this._h2.get[row.idd].buff=row;	//treegrid specific
		this._fillRow(row, text);
		this._postRowProcessing(row);
		if (this._skipInsert){
			this._skipInsert=false;
			return this.rowsAr[row.idd]=row;
		}
		
		if (this.pagingOn){
			this.rowsBuffer._dhx_insertAt(ind,row);
			this.rowsAr[row.idd]=row;
			return row;
		}
		
		if (this._fillers){ 
			this.rowsCol._dhx_insertAt(ind, null);
			this.rowsBuffer._dhx_insertAt(ind,row);
			if (this._fake) this._fake.rowsCol._dhx_insertAt(ind, null);
			this.rowsAr[row.idd]=row;
			var found = false;
			
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i];
				
				if (f&&f[0] <= ind&&(f[0]+f[1]) >= ind){
					f[1]=f[1]+1;
					var nh = f[2].firstChild.style.height=parseInt(f[2].firstChild.style.height)+this._srdh+"px";
					found=true;
					if (this._fake){
						this._fake._fillers[i][1]++;
						this._fake._fillers[i][2].firstChild.style.height = nh;
					}
				}
				
				if (f&&f[0] > ind){
					f[0]=f[0]+1
					if (this._fake) this._fake._fillers[i][0]++;
				}
			}
			
			if (!found)
			this._fillers.push(this._add_filler(ind, 1, (ind == 0 ? {
					parentNode: this.obj.rows[0].parentNode,
					nextSibling: (this.rowsCol[1])
			} : this.rowsCol[ind-1])));
			
			return row;
		}
		this.rowsBuffer._dhx_insertAt(ind,row);
		return this._insertRowAt(row, ind);
	},
	
	/**
	*   @desc: add row to the grid
	*   @param: new_id - row ID, must be unique
	*   @param: text - row values, may be a comma separated list or an array
	*   @param: ind - index of new row, optional, row added to the last position by default
	*   @type:  public
	*/	
	addRow:function(new_id, text, ind){
		var r = this._addRow(new_id, text, ind);
		
		if (!this.dragContext)
			this.callEvent("onRowAdded", [new_id]);
		
		if (this.pagingOn)
			this.changePage(this.currentPage)
		
		if (this._srnd)
			this._update_srnd_view();
		
		r._added=true;
		
		if (this._srnd && !this._fillers)
			this._fillers = [];
		
		if (this._ahgr)
			this.setSizes();
		this.callEvent("onGridReconstructed", []);
		return r;
	},
	
	_insertRowAt:function(r, ind, skip){
		this.rowsAr[r.idd]=r;
		
		if (this._skipInsert){
			this._skipInsert=false;
			return r;
		}
		
		if ((ind < 0)||((!ind)&&(parseInt(ind) !== 0)))
			ind=this.rowsCol.length;
		else {
			if (ind > this.rowsCol.length)
				ind=this.rowsCol.length;
		}
		
		if (this._cssEven){
			var css = r.className.replace(this._cssUnEven, "");
			if ((this._cssSP ? this.getLevel(r.idd) : ind)%2 == 1)
				r.className=css+" "+this._cssUnEven+(this._cssSU ? (" "+this._cssUnEven+"_"+this.getLevel(r.idd)) : "");
			else
				r.className=css+" "+this._cssEven+(this._cssSU ? (" "+this._cssEven+"_"+this.getLevel(r.idd)) : "");
		}
		/*
		if (r._skipInsert) {                
		this.rowsAr[r.idd] = r;
		return r;
		}*/
		if (!skip)
			if ((ind == (this.obj.rows.length-1))||(!this.rowsCol[ind]))
			if (_isKHTML)
			this.obj.appendChild(r);
		else {
			this.obj.firstChild.appendChild(r);
		}
		else {
			this.rowsCol[ind].parentNode.insertBefore(r, this.rowsCol[ind]);
		}
		
		this.rowsCol._dhx_insertAt(ind, r);
		this.callEvent("onRowInserted",[r, ind]);
		return r;
	},
	
	getRowById:function(id){
		var row = this.rowsAr[id];
		
		if (row){
			if (row.tagName != "TR"){
				for (var i = 0; i < this.rowsBuffer.length; i++)
					if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
					return this.render_row(i);
				if (this._h2) return this.render_row(null,row.idd);
			}
			return row;
		}
		return null;
	},
	
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellById:function(row_id, col){
		return this.cells(row_id, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (use it to get/set value to cell etc.)
	*   @type: public
	*   @topic: 4
	*/
	cells:function(row_id, col){
		if (arguments.length == 0)
			return this.cells4(this.cell);
		else
			var c = this.getRowById(row_id);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellByIndex:function(row_index, col){
		return this.cells2(row_index, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cells2:function(row_index, col){
		var c = this.render_row(row_index);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for row  object and column id
	*   @type: private
	*   @topic: 4
	*/
	cells3:function(row, col){
		var cell = (row._childIndexes ? row.childNodes[row._childIndexes[col]] : row.childNodes[col]);
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for cell  object
	*   @type: private
	*   @topic: 4
	*/
	cells4:function(cell){
		var type = window["eXcell_"+(cell._cellType||this.cellType[cell._cellIndex])];
		
		if (type)
			return new type(cell);
	},	
	cells5:function(cell, type){ 
		var type = type||(cell._cellType||this.cellType[cell._cellIndex]);
		
		if (!this._ecache[type]){
			if (!window["eXcell_"+type])
				var tex = eXcell_ro;
			else
				var tex = window["eXcell_"+type];
			
			this._ecache[type]=new tex(cell);
		}
		this._ecache[type].cell=cell;
		return this._ecache[type];
	},
	dma:function(mode){
		if (!this._ecache)
		this._ecache={
		};
		
		if (mode&&!this._dma){
			this._dma=this.cells4;
			this.cells4=this.cells5;
		} else if (!mode&&this._dma){
			this.cells4=this._dma;
			this._dma=null;
		}
	},
	
	/**
	*   @desc: returns count of row in grid ( in case of dynamic mode it will return expected count of rows )
	*   @type:  public
	*	@returns: count of rows in grid
	*/	
	getRowsNum:function(){
		return this.rowsBuffer.length;
	},
	
	
	/**
	*   @desc: enables/disables mode when readonly cell is not available with tab 
	*   @param: mode - (boolean) true/false
	*   @type:  public
	*/
	enableEditTabOnly:function(mode){
		if (arguments.length > 0)
			this.smartTabOrder=dhx4.s2b(mode);
		else
			this.smartTabOrder=true;
	},
	/**
	*   @desc: sets elements which get focus when tab is pressed in the last or first (tab+shift) cell 
	*   @param: start - html object or its id - gets focus when tab+shift are pressed in the first cell  
	*   @param: end - html object or its id - gets focus when tab is pressed in the last cell  
	*   @type:  public
	*/
	setExternalTabOrder:function(start, end){
		var grid = this;
		this.tabStart=( typeof (start) == "object") ? start : document.getElementById(start);
		
		var oldkeydown_start = this.tabStart.onkeydown;
		this.tabStart.onkeydown=function(e){
			if (oldkeydown_start)
				oldkeydown_start.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && !ev.shiftKey){
				
				ev.cancelBubble=true;		
				grid.selectCell(0, 0, 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2(0, 0).isDisabled()){
					grid._key_events["k9_0_0"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabStart.onkeypress = this.tabStart.onkeydown;
		this.tabEnd=( typeof (end) == "object") ? end : document.getElementById(end);
		
		var oldkeydown_end= this.tabEnd.onkeydown;
		this.tabEnd.onkeydown=this.tabEnd.onkeypress=function(e){
			if (oldkeydown_end)
				oldkeydown_end.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && ev.shiftKey){
				ev.cancelBubble=true;
				grid.selectCell((grid.getRowsNum()-1), (grid.getColumnCount()-1), 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2((grid.getRowsNum()-1), (grid.getColumnCount()-1)).isDisabled()){
					grid._key_events["k9_0_1"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabEnd.onkeypress = this.tabEnd.onkeydown;
	},
	/**
	*   @desc: returns unique ID
	*   @type:  public
	*/	
	uid:function(){
		if (!this._ui_seed) this._ui_seed=(new Date()).valueOf();
		return this._ui_seed++;
	},
	setIconset:function(name){
		this.iconset = name;
	},
	/**
	*   @desc: clears existing grid state and load new XML
	*   @type:  public
	*/
	clearAndLoad:function(){
		if (this._last_load_request){
			//abort last loading if new issued
			var last = this._last_load_request.xmlDoc;
			if (last.readyState != 4){
				try{
					last.onreadystatechange = function(){};
					last.abort();
				} catch(e){}
			}
		};

		var t=this._pgn_skin; this._pgn_skin=null;
		this.clearAll();
		this._pgn_skin=t;
		this._last_load_request = this.load.apply(this,arguments);
	},
	/**
	*   @desc: returns details about current grid state
	*   @type:  public
	*/
	getStateOfView:function(){
		if (this.pagingOn){
			var start = (this.currentPage-1)*this.rowsBufferOutSize;
			return [this.currentPage, start, Math.min(start+this.rowsBufferOutSize,this.rowsBuffer.length), this.rowsBuffer.length ];
		}
 		return [
 			Math.floor(this.objBox.scrollTop/this._srdh),
			Math.ceil(parseInt(this.objBox.offsetHeight)/this._srdh),
			this.rowsBuffer.length
		];
	}
};

//grid
(function(){
		//local helpers
		function direct_set(name,value){ this[name]=value; 	}
		function direct_call(name,value){ this[name].call(this,value); 	}
		function joined_call(name,value){ this[name].call(this,value.join(this.delim));  }
		function set_options(name,value){
			for (var i=0; i < value.length; i++) 
			if (typeof value[i] == "object"){
				var combo = this.getCombo(i);
				for (var key in value[i])
					combo.put(key, value[i][key]);
			}
		}
		function header_set(name,value,obj){
			//make a matrix
			var rows = 1;
			var header = [];
			function add(i,j,value){
				if (!header[j]) header[j]=[];
				if (typeof value == "object") value.toString=function(){ return this.text; }
				header[j][i]=value;
			}
			
			for (var i=0; i<value.length; i++) {
				if (typeof(value[i])=="object" && value[i].length){
					for (var j=0; j < value[i].length; j++)
						add(i,j,value[i][j]);		
				} else
				add(i,0,value[i]);		
			}
			for (var i=0; i<header.length; i++)
			for (var j=0; j<header[0].length; j++){
				var h=header[i][j];
				header[i][j]=(h||"").toString()||"&nbsp;";
				if (h&&h.colspan)
					for (var k=1; k < h.colspan; k++) add(j+k,i,"#cspan");
				if (h&&h.rowspan)
					for (var k=1; k < h.rowspan; k++) add(j,i+k,"#rspan");
			}
			
			this.setHeader(header[0]);
			for (var i=1; i < header.length; i++) 
				this.attachHeader(header[i]);
		}
		
		//defenitions
		var columns_map=[
			{name:"label", 	def:"&nbsp;", 	operation:"setHeader",		type:header_set		},
			{name:"id", 	def:"", 		operation:"columnIds",		type:direct_set		},
			{name:"width", 	def:"*", 		operation:"setInitWidths", 	type:joined_call	},
			{name:"align", 	def:"left", 	operation:"cellAlign",		type:direct_set		},
			{name:"valign", def:"middle", 	operation:"cellVAlign",		type:direct_set		},
			{name:"sort", 	def:"na", 		operation:"fldSort",		type:direct_set		},
			{name:"type", 	def:"ro", 		operation:"setColTypes",	type:joined_call	},
			{name:"options",def:"", 		operation:"",				type:set_options	}
		];
		
		//extending	
		dhtmlx.extend_api("dhtmlXGridObject",{
				_init:function(obj){
					return [obj.parent];
				},
				image_path:"setImagePath",
				columns:"columns",
				rows:"rows",
				headers:"headers",
				skin:"setSkin",
				smart_rendering:"enableSmartRendering",
				css:"enableAlterCss",
				auto_height:"enableAutoHeight",
				save_hidden:"enableAutoHiddenColumnsSaving",
				save_cookie:"enableAutoSaving",
				save_size:"enableAutoSizeSaving",
				auto_width:"enableAutoWidth",
				block_selection:"enableBlockSelection",
				csv_id:"enableCSVAutoID",
				csv_header:"enableCSVHeader",
				cell_ids:"enableCellIds",
				colspan:"enableColSpan",
				column_move:"enableColumnMove",
				context_menu:"enableContextMenu",
				distributed:"enableDistributedParsing",
				drag:"enableDragAndDrop",
				drag_order:"enableDragOrder",
				tabulation:"enableEditTabOnly",
				header_images:"enableHeaderImages",
				header_menu:"enableHeaderMenu",
				keymap:"enableKeyboardSupport",
				mouse_navigation:"enableLightMouseNavigation",
				markers:"enableMarkedCells",
				math_editing:"enableMathEditing",
				math_serialization:"enableMathSerialization",
				drag_copy:"enableMercyDrag",
				multiline:"enableMultiline",
				multiselect:"enableMultiselect",
				save_column_order:"enableOrderSaving",
				hover:"enableRowsHover",
				rowspan:"enableRowspan",
				smart:"enableSmartRendering",
				save_sorting:"enableSortingSaving",
				stable_sorting:"enableStableSorting",
				undo:"enableUndoRedo",
				csv_cell:"setCSVDelimiter",
				date_format:"setDateFormat",
				drag_behavior:"setDragBehavior",
				editable:"setEditable",
				without_header:"setNoHeader",
				submit_changed:"submitOnlyChanged",
				submit_serialization:"submitSerialization",
				submit_selected:"submitOnlySelected",
				submit_id:"submitOnlyRowID",		
				xml:"load"
		},{
			columns:function(obj){
				for (var j=0; j<columns_map.length; j++){
					var settings = [];
					for (var i=0; i<obj.length; i++)
						settings[i]=obj[i][columns_map[j].name]||columns_map[j].def;
					var type=columns_map[j].type||direct_call;
					type.call(this,columns_map[j].operation,settings,obj);
				}
				this.init();
			},
			rows:function(obj){
				
			},
			headers:function(obj){
				for (var i=0; i < obj.length; i++) 
					this.attachHeader(obj[i]);
			}
		});
		
})();


dhtmlXGridObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id) {
			if (this.obj._h2)
				this.obj.addRow(id, row, null, parent);
			else
				this.obj.addRow(id, [], 0);
			
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("updateCallback", function(upd, id) {
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("deleteCallback", function(upd, id) {
			this.obj.setUserData(id, this.action_param, "true_deleted");
			this.obj.deleteRow(id);
	});
	
	
	dp._methods=["setRowTextStyle","setCellTextStyle","changeRowId","deleteRow"];
	this.attachEvent("onEditCell",function(state,id,index){
			if (dp._columns && !dp._columns[index]) return true;
			var cell = this.cells(id,index)
			if (state==1){
				if(cell.isCheckbox()){
					dp.setUpdated(id,true)
				}
			} else if (state==2){
				if(cell.wasChanged()){
					dp.setUpdated(id,true)
				}
			}
			return true;
	});
	this.attachEvent("onRowPaste",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onUndo",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onRowIdChange",function(id,newid){
			var ind=dp.findRow(id);
			if (ind<dp.updatedRows.length)
				dp.updatedRows[ind]=newid;
	});
	this.attachEvent("onSelectStateChanged",function(rowId){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onEnter",function(rowId,celInd){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(rowId){
			if (dp._silent_mode || (!this.rowsAr[rowId])) return true;
			if (this.dragContext && dp.dnd) {
				window.setTimeout(function(){
						dp.setUpdated(rowId,true);
				},1);
				return true;
			}
			var z=dp.getState(rowId);
			if (this._h2){
				this._h2.forEachChild(rowId,function(el){
						dp.setUpdated(el.id,false);
						dp.markRow(el.id,true,"deleted");
				},this);
			}
			if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);		return true; }
			if (z=="deleted")  return false;
			if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }
			
			dp.setUpdated(rowId,true,"deleted");
			return false;
	});
	this.attachEvent("onBindUpdate", function(data, key, id){
		dp.setUpdated(id, true);
	});
	this.attachEvent("onRowAdded",function(rowId){
			if (this.dragContext && dp.dnd) return true;
			dp.setUpdated(rowId,true,"inserted")
			return true;
	});
	dp._getRowData=function(rowId,pref){
		var data = [];
		
		data["gr_id"]=rowId;
		if (this.obj.isTreeGrid())
			data["gr_pid"]=this.obj.getParentId(rowId);
		
		var r=this.obj.getRowById(rowId);
		for (var i=0; i<this.obj._cCount; i++){
			if (this.obj._c_order)
		   		var i_c=this.obj._c_order[i];
		   	else
			   	var i_c=i;
			
			var c=this.obj.cells(r.idd,i);
			if (this._changed && !c.wasChanged()) continue;
			if (this._endnm)
				data[this.obj.getColumnId(i)]=c.getValue();
			else
				data["c"+i_c]=c.getValue();
		}
		
		var udata=this.obj.UserData[rowId];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				if (udata.keys[j] && udata.keys[j].indexOf("__")!=0)
				data[udata.keys[j]]=udata.values[j];
		}
		var udata=this.obj.UserData["gridglobaluserdata"];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				data[udata.keys[j]]=udata.values[j];
		}
		return data;
	};
	dp._clearUpdateFlag=function(rowId){
		var row=this.obj.getRowById(rowId);
		if (row)
			for (var j=0; j<this.obj._cCount; j++)
			this.obj.cells(rowId,j).cell.wasChanged=false;	//using cells because of split
	};
	dp.checkBeforeUpdate=function(rowId){ 
		var valid=true; var c_invalid=[];
		for (var i=0; i<this.obj._cCount; i++)
		if (this.mandatoryFields[i]){
			var res=this.mandatoryFields[i].call(this.obj,this.obj.cells(rowId,i).getValue(),rowId,i);
			if (typeof res == "string"){
				this.messages.push(res);
				valid = false;
			} else {
				valid&=res;
				c_invalid[i]=!res;
			}
		}
		if (!valid){
			this.set_invalid(rowId,"invalid",c_invalid);
			this.setUpdated(rowId,false);
		}
		return valid;
	};	
};


dhx4.attachEvent("onGridCreated", function(grid){
		//make separate config array for each grid
		grid._con_f_used = [].concat(grid._con_f_used);
		dhtmlXGridObject.prototype._con_f_used=[];
		
		var clear_url=function(url){
			url=url.replace(/(\?|\&)connector[^\f]*/g,"");
			return url+(url.indexOf("?")!=-1?"&":"?")+"connector=true"+(this.hdr.rows.length > 0 ? "&dhx_no_header=1":"");
		};
		var combine_urls=function(url){
			return clear_url.call(this,url)+(this._connector_sorting||"")+(this._connector_filter||"");
		};
		var sorting_url=function(url,ind,dir){
			this._connector_sorting="&dhx_sort["+ind+"]="+dir;
			return combine_urls.call(this,url);
		};
		var filtering_url=function(url,inds,vals){
			var chunks = [];
			for (var i=0; i<inds.length; i++)
				chunks[i]="dhx_filter["+inds[i]+"]="+encodeURIComponent(vals[i]);
			this._connector_filter="&"+chunks.join("&");
			return combine_urls.call(this,url);
		};
		grid.attachEvent("onCollectValues",function(ind){
				if (this._con_f_used[ind]){
					if (typeof(this._con_f_used[ind]) == "object")
						return this._con_f_used[ind];
					else
						return false;
				}
				return true;
		});	
		grid.attachEvent("onDynXLS",function(){
				if (this.xmlFileUrl)
					this.xmlFileUrl=combine_urls.call(this,this.xmlFileUrl);
				return true;
		});				
		grid.attachEvent("onBeforeSorting",function(ind,type,dir){
				if (type=="connector"){
					var self=this;
					this.clearAndLoad(sorting_url.call(this,this.xmlFileUrl,ind,dir),function(){
							self.setSortImgState(true,ind,dir);
					});
					return false;
				}
				return true;
		});
		grid.attachEvent("onFilterStart",function(a,b){
				if (this._con_f_used.length){
					var ss = this.getSortingState();
					var self=this;
					this.clearAndLoad(filtering_url.call(this,this.xmlFileUrl,a,b));
					if (ss.length)
						self.setSortImgState(true,ss[0],ss[1]);
					return false;
				}
				return true;
		});
});

dhtmlXGridObject.prototype._con_f_used=[];
dhtmlXGridObject.prototype._in_header_connector_text_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=1;
	return this._in_header_text_filter(t,i);
};
dhtmlXGridObject.prototype._in_header_connector_select_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=2;
	return this._in_header_select_filter(t,i);
};

if (!dhtmlXGridObject.prototype.load_connector){
	
	dhtmlXGridObject.prototype.load_connector=dhtmlXGridObject.prototype.load;
	dhtmlXGridObject.prototype.load=function(url, call, type){
		if (!this._colls_loaded && this.cellType){
			var ar=[];
			for (var i=0; i < this.cellType.length; i++)
				if (this.cellType[i].indexOf("co")==0 || this.cellType[i].indexOf("clist")==0 || this._con_f_used[i]==2) ar.push(i);
			if (ar.length)
				arguments[0]+=(arguments[0].indexOf("?")!=-1?"&":"?")+"connector=true&dhx_colls="+ar.join(",");
		}
		return this.load_connector.apply(this,arguments);
	};
	dhtmlXGridObject.prototype._parseHead_connector=dhtmlXGridObject.prototype._parseHead;
	dhtmlXGridObject.prototype._parseHead=function(url, call, type){
		this._parseHead_connector.apply(this,arguments);
		if (!this._colls_loaded){
			var cols = dhx4.ajax.xpath("./coll_options", arguments[0]);
			for (var i=0; i < cols.length; i++){
				var f = cols[i].getAttribute("for");
				var v = [];
				var combo=null;
				if (this.cellType[f] == "combo")
					combo = this.getColumnCombo(f);
				else if (this.cellType[f].indexOf("co")==0)
					combo=this.getCombo(f);
				
				var os = dhx4.ajax.xpath("./item",cols[i]);
				var opts = [];
				for (var j=0; j<os.length; j++){
					var val=os[j].getAttribute("value");
					
					if (combo){
						var lab=os[j].getAttribute("label")||val;
						
						if (combo.addOption)
							opts.push([val, lab]);
						else
							combo.put(val,lab);
						
						v[v.length]=lab;
					} else
					v[v.length]=val;
				}
				if (opts.length){
					if (combo)
						combo.addOption(opts);
				} else if (v.length && !combo)
				if (this.registerCList)
					this.registerCList(f*1, v);
				
				
				if (this._con_f_used[f*1])
					this._con_f_used[f*1]=v;
			}
			this._colls_loaded=true;
		}
	};
	
}	

//(c)dhtmlx ltd. www.dhtmlx.com

/**
*	@desc: dhtmlxGrid cell object constructor (shouldn't be accesed directly. Use cells and cells2 methods of the grid instead)
*	@type: cell
*	@returns: dhtmlxGrid cell
*/
function dhtmlXGridCellObject(obj){
	/**
	*	@desc: desctructor, clean used memory
	*	@type: public
	*/
	this.destructor=function(){
		this.cell.obj=null;
		this.cell=null;
		this.grid=null;
		this.base=null;
		return null;
	}
	this.cell=obj;
	/**
	*	@desc: gets Value of cell
	*	@type: public
	*/
	this.getValue=function(){
		if ((this.cell.textContent)&&(this.cell.textContent.tagName == "TEXTAREA"))
			return this.cell.textContent.value;
		else
			return this.cell.innerHTML._dhx_trim(); //innerText;
	}

	/**
	*	@desc: gets math formula of cell if any
	*	@type: public
	*/
	this.getMathValue=function(){
		if (this.cell.original)
			return this.cell.original; //innerText;
		else
			return this.getValue();
	}
	
//#excell_methods:04062008{
	/**
	*	@desc: determ. font style if it was set
	*	@returns: font name only if it was set for the cell
	*	@type: public
	*/
	this.getFont=function(){
		arOut=new Array(3);

		if (this.cell.style.fontFamily)
			arOut[0]=this.cell.style.fontFamily

		if (this.cell.style.fontWeight == 'bold'||this.cell.parentNode.style.fontWeight == 'bold')
			arOut[1]='bold';

		if (this.cell.style.fontStyle == 'italic'||this.cell.parentNode.style.fontWeight == 'italic')
			arOut[1]+='italic';

		if (this.cell.style.fontSize)
			arOut[2]=this.cell.style.fontSize
		else
			arOut[2]="";
		return arOut.join("-")
	}
	/**
	*	@desc: determ. cell's text color
	*	@returns: cell's text color
	*	@type: public
	*/
	this.getTextColor=function(){
		if (this.cell.style.color)
			return this.cell.style.color
		else
			return "#000000";
	}
	/**
	*	@desc: determ. cell's background color
	*	@returns: cell's background color
	*	@type: public
	*/
	this.getBgColor=function(){
		return this.cell.style.backgroundColor || "#FFFFFF";
	}
	/**
	*	@desc: determines horisontal align od the cell
	*	@returns: horisontal align of cell content
	*	@type: public
	*/
	this.getHorAlign=function(){
		if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else
			return "left";
	}
	/**
	*	@desc: gets width of the cell in pixel
	*	@returns: width of the cell in pixels
	*	@type: public
	*/
	this.getWidth=function(){
		return this.cell.scrollWidth;
	}

	/**
	*	@desc: sets font family to the cell
	*	@param: val - string in format: Arial-bold(italic,bolditalic,underline)-12px
	*	@type: public
	*/
	this.setFont=function(val){
		fntAr=val.split("-");
		this.cell.style.fontFamily=fntAr[0];
		this.cell.style.fontSize=fntAr[fntAr.length-1]

		if (fntAr.length == 3){
			if (/bold/.test(fntAr[1]))
				this.cell.style.fontWeight="bold";

			if (/italic/.test(fntAr[1]))
				this.cell.style.fontStyle="italic";

			if (/underline/.test(fntAr[1]))
				this.cell.style.textDecoration="underline";
		}
	}
	/**
	*	@desc: sets text color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setTextColor=function(val){
		this.cell.style.color=val;
	}
	/**
	*	@desc: sets background color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setBgColor=function(val){
		if (val == "")
			val=null;
		this.cell.style.background=val;
	}
	/**
	*	@desc: sets horisontal align to the cell
	*	@param: val - value in single-letter or full format(exmp: r or right)
	*	@type: public
	*/
	this.setHorAlign=function(val){
		if (val.length == 1){
			if (val == 'c')
				this.cell.style.textAlign='center'

			else if (val == 'l')
				this.cell.style.textAlign='left';

			else
				this.cell.style.textAlign='right';
		} else
			this.cell.style.textAlign=val
	}
//#}
	/**
	*	@desc: determines whether cell value was changed
	*	@returns: true if cell value was changed, otherwise - false
	*	@type: public
	*/
	this.wasChanged=function(){
		if (this.cell.wasChanged)
			return true;
		else
			return false;
	}
	/**
	*	@desc: determines whether first child of the cell is checkbox or radio
	*	@returns: true if first child of the cell is input element of type radio or checkbox
	*	@type: deprecated
	*/
	this.isCheckbox=function(){
		var ch = this.cell.firstChild;

		if (ch&&ch.tagName == 'INPUT'){
			type=ch.type;

			if (type == 'radio'||type == 'checkbox')
				return true;
			else
				return false;
		} else
			return false;
	}
	/**
	*	@desc: determines whether radio or checkbox inside is checked
	*	@returns: true if first child of the cell is checked
	*	@type: public
	*/
	this.isChecked=function(){
		if (this.isCheckbox()){
			return this.cell.firstChild.checked;
		}
	}
	/**
	*	@desc: determines whether cell content (radio,checkbox) is disabled
	*	@returns: true if first child of the cell is disabled
	*	@type: public
	*/
	this.isDisabled=function(){
		return this.cell._disabled;
	}
	/**
	*	@desc: checks checkbox or radion
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setChecked=function(fl){
		if (this.isCheckbox()){
			if (fl != 'true'&&fl != 1)
				fl=false;
			this.cell.firstChild.checked=fl;
		}
	}
	/**
	*	@desc: disables radio or checkbox
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setDisabled=function(fl){
		if (fl != 'true'&&fl != 1)
			fl=false;

		if (this.isCheckbox()){
			this.cell.firstChild.disabled=fl;

			if (this.disabledF)
				this.disabledF(fl);
		}
		this.cell._disabled=fl;
	}
}

dhtmlXGridCellObject.prototype={
	getAttribute: function(name){
		return this.cell._attrs[name];
	},
	setAttribute: function(name, value){
		this.cell._attrs[name]=value;
	},
	getInput:function(){
		if (this.obj && (this.obj.tagName=="INPUT" || this.obj.tagName=="TEXTAREA")) return this.obj;
		
		var inps=(this.obj||this.cell).getElementsByTagName("TEXTAREA");
		if (!inps.length)
			inps=(this.obj||this.cell).getElementsByTagName("INPUT");
		return inps[0];
	}
}

/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setValue=function(val){
	if (( typeof (val) != "number")&&(!val||val.toString()._dhx_trim() == "")){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;
	this.setCValue(val);
}
/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@param: val2
*	@type: private
*/
dhtmlXGridCellObject.prototype.getTitle=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}

dhtmlXGridCellObject.prototype.setCValue=function(val, val2){
	this.cell.innerHTML=val;
//#__pro_feature:21092006{
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		(arguments.length > 1 ? val2 : val)
	]);
//#}
//#}
}

dhtmlXGridCellObject.prototype.setCTxtValue=function(val){
	this.cell.innerHTML="";
	this.cell.appendChild(document.createTextNode(val));
//#__pro_feature:21092006{	
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		val
	]);
//#}
//#}
}

/**
*	@desc: sets text representation of cell which contains math formula ( setLabel doesn't triger math calculations as setValue do)
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setLabel=function(val){
	this.cell.innerHTML=val;
}

/**
*	@desc: get formula of ExCell ( actual only for math based exCells )
*	@type: public
*/
dhtmlXGridCellObject.prototype.getMath=function(){
	if (this._val)
		return this.val;
	else
		return this.getValue();
}

/**
*	@desc: dhtmlxGrid cell editor constructor (base for all eXcells). Shouldn't be accessed directly
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell(){
	this.obj=null; //editor
	//this.cell = null//cell to get value from
	this.val=null; //current value (before edit)
	/**
	*	@desc: occures on space for example 
	*	@type: private
	*/
	this.changeState=function(){
		return false
	}
	/**
	*	@desc: opens editor
	*	@type: private
	*/
	this.edit=function(){
		this.val=this.getValue()
	} //
	/**
	*	@desc: return value to cell, closes editor
	*	@returns: if cell's value was changed (true) or not
	*	@type: private
	*/
	this.detach=function(){
		return false
	} //
	/**
	*	@desc: gets position (left-right) of element
	*	@param: oNode - element to get position of
	*	@type: private
	*	@topic: 8
	*/
	this.getPosition=function(oNode){
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while (oCurrentNode.tagName != "BODY"){
			iLeft+=oCurrentNode.offsetLeft;
			iTop+=oCurrentNode.offsetTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		return new Array(iLeft, iTop);
	}
}
eXcell.prototype=new dhtmlXGridCellObject;


/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ed(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.atag=(!this.grid.multiLine) ? "INPUT" : "TEXTAREA";
		this.val=this.getValue();
		this.obj=document.createElement(this.cell.atag);
		this.obj.setAttribute("autocomplete", "off");
		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";
		
		this.obj.className="dhx_combo_edit";
		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.val
		this.cell.innerHTML="";
		this.cell.appendChild(this.obj);

		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		if (_isIE){
			this.obj.focus();
			this.obj.blur();
		}
		this.obj.focus();
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell.innerHTML.toString()._dhx_trim();
	}

	this.detach=function(){
		this.setValue(this.obj.value);
		return this.val != this.getValue();
	}
}
eXcell_ed.prototype=new eXcell;

/**
*	@desc: pure text editor ( HTML not supported )
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_edtxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}
eXcell_edtxt.prototype=new eXcell_ed;
//#__pro_feature:21092006{
/**
*	@desc: simple numeric text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*	@edition: professional
*/
function eXcell_edn(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		//this.grid.editStop();
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex);
	}

	this.detach=function(){
		var tv = this.obj.value;
		this.setValue(tv);
		return this.val != this.getValue();
	}
}
eXcell_edn.prototype=new eXcell_ed;
eXcell_edn.prototype.setValue=function(val){ 
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		return this.setCValue("&nbsp;",0);
	} else {
		this.cell._clearCell=false;
		this.cell._orig_value = val;
	}
	this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
}
//#}

//#ch_excell:04062008{
/**
*	@desc: checkbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ch(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
	}

	this.changeState=function(fromClick){
		//nb:
		if (fromClick===true && !this.grid.isActive) {
			if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
			this.grid.setActive(true);
		}
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		])){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")

			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.getValue=function(){
		return this.cell.chstate ? this.cell.chstate.toString() : "0";
	}

	this.isCheckbox=function(){
		return true;
	}
	this.isChecked=function(){
		if (this.getValue() == "1")
			return true;
		else
			return false;
	}

	this.setChecked=function(fl){
		this.setValue(fl.toString())
	}
	this.detach=function(){
		return this.val != this.getValue();
	}
	this.edit=null;
}
eXcell_ch.prototype=new eXcell;
eXcell_ch.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line
	//val can be int
	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	var obj = this;
	this.cell.setAttribute("excell", "ch");
	this.setCValue("<img src='"+this.grid.imgURL+"item_chk"+val
		+".gif' onclick='new eXcell_ch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>",
		this.cell.chstate);
}
//#}
//#ra_excell:04062008{
/**
*	@desc: radio editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ra(cell){
	this.base=eXcell_ch;
	this.base(cell)
	this.grid=cell.parentNode.grid;

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0.", "radio_chk0_dis.").replace("radio_chk1.",
				"radio_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0_dis.", "radio_chk0.").replace("radio_chk1_dis.",
				"radio_chk1.");
	}

	this.changeState=function(mode){
		if (mode===false && this.getValue()==1) return;

		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		]) != false){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")
			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.edit=null;
}
eXcell_ra.prototype=new eXcell_ch;
eXcell_ra.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line

	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		if (!this.grid._RaSeCol)
			this.grid._RaSeCol=[];

		if (this.grid._RaSeCol[this.cell._cellIndex]){
			var z = this.grid.cells(this.grid._RaSeCol[this.cell._cellIndex], this.cell._cellIndex);
			z.setValue("0")
			if (this.grid.rowsAr[z.cell.parentNode.idd])
			this.grid.callEvent("onEditCell", [
				1,
				z.cell.parentNode.idd,
				z.cell._cellIndex
			]);
		}

		this.grid._RaSeCol[this.cell._cellIndex]=this.cell.parentNode.idd;

		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	this.cell.setAttribute("excell", "ra");
	this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra(this.parentNode).changeState(false);'>",
		this.cell.chstate);
}
//#}
//#txt_excell:04062008{
/**
*	@desc: multilene popup editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_textarea";

		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox

		this.obj.value=this.val;

		this.obj.style.display="";
		this.obj.style.textAlign=this.cell.style.textAlign;

		document.body.appendChild(this.obj); //nb:
		if(_isOpera) this.obj.onkeypress=function(ev){ if (ev.keyCode == 9||ev.keyCode == 27) return false; }
		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9||ev.keyCode == 27){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
					});

				return false;
			}
		}

		this.obj.style.left=arPos[0]+"px";
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

		if (this.cell.offsetWidth < 200)
			var pw = 200;
		else
			var pw = this.cell.offsetWidth;
		this.obj.style.width=pw+16+"px"

		if (_isIE) { this.obj.select(); this.obj.value=this.obj.value; }//dzen of IE
		this.obj.focus()
	}
	this.detach=function(){
		var a_val = "";

		a_val=this.obj.value;

		if (a_val == ""){
			this.cell._clearCell=true;
		}
		else
			this.cell._clearCell=false;
		this.setValue(a_val);
		document.body.removeChild(this.obj);
		this.obj=null;
		return this.val != this.getValue();
	}
	this.getValue=function(){
		if (this.obj){
			return this.obj.value;
		}
				
		if (this.cell._clearCell)
			return "";

		if (typeof this.cell._brval != "undefined") return this.cell._brval;

		if ((!this.grid.multiLine))
			return this.cell._brval||this.cell.innerHTML;
		else
			return this.cell._brval||this.cell.innerHTML.replace(/<br[^>]*>/gi, "\n")._dhx_trim(); //innerText;
	}
}

eXcell_txt.prototype=new eXcell;

/**
*	@desc: multiline text editor without HTML support
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txttxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		if ((!this.grid.multiLine)&&this.cell._brval)
			return this.cell._brval;

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		this.cell._brval=val;

		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}

eXcell_txttxt.prototype=new eXcell_txt;

eXcell_txt.prototype.setValue=function(val){
	this.cell._brval=val;

	if (!val||val.toString()._dhx_trim() == ""){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;

	if ((!this.grid.multiLine) || this.cell._clearCell)
		this.setCValue(val, this.cell._brval);
	else
		this.setCValue(val.replace(/\n/g, "<br/>"), val);
}
//#}
//#co_excell:04062008{
/**
*	@desc: combobox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_co(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
		this.combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
		this.editable=true
	}
	this.shiftNext=function(){
		var z = this.list.options[this.list.selectedIndex+1];

		if (z)
			z.selected=true;
		this.obj.value=this.list.options[this.list.selectedIndex].text;

		return true;
	}
	this.shiftPrev=function(){
		if (this.list.selectedIndex != 0){
			var z = this.list.options[this.list.selectedIndex-1];

			if (z)
				z.selected=true;
			this.obj.value=this.list.options[this.list.selectedIndex].text;
		}

		return true;
	}

	this.edit=function(){
		this.val=this.getValue();
		this.text=this.getText()._dhx_trim();
		var arPos = this.grid.getPosition(this.cell) //,this.grid.objBox)

		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_combo_edit";

		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";

		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.text
		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		var editor_obj = this;
		this.obj.onkeyup=function(e){
			var key=(e||event).keyCode;
			if (key==38 || key==40 || key==9) return;
			var val = this.readonly ? String.fromCharCode(key) : this.value;
			
			var c = editor_obj.list.options;

			for (var i = 0; i < c.length; i++)
				if (c[i].text.indexOf(val) == 0)
					return c[i].selected=true;
		}
		this.list=document.createElement("SELECT");

		this.list.className='dhx_combo_select';
		this.list.style.width=this.cell.offsetWidth+"px";
		this.list.style.left=arPos[0]+"px";                       //arPos[0]
		this.list.style.top=arPos[1]+this.cell.offsetHeight+"px"; //arPos[1]+this.cell.offsetHeight;
		this.list.onclick=function(e){
			var ev = e||window.event;
			var cell = ev.target||ev.srcElement

			//tbl.editor_obj.val=cell.combo_val;
			if (cell.tagName == "OPTION")
				cell=cell.parentNode;
			//editor_obj.list.value = cell.value;
			editor_obj.editable=false;
			editor_obj.grid.editStop();
			ev.cancelBubble = true;
		}
		var comboKeys = this.combo.getKeys();
		var fl = false
		var selOptId = 0;

		for (var i = 0; i < comboKeys.length; i++){
			var val = this.combo.get(comboKeys[i])
			this.list.options[this.list.options.length]=new Option(val, comboKeys[i]);

			if (comboKeys[i] == this.val){
				selOptId=this.list.options.length-1;
				fl=true;
			}
		}

		if (fl == false){ //if no such value in combo list
			this.list.options[this.list.options.length]=new Option(this.text, this.val === null ? "" : this.val);
			selOptId=this.list.options.length-1;
		}
		document.body.appendChild(this.list) //nb:this.grid.objBox.appendChild(this.listBox);
		this.list.size="6";
		this.cstate=1;

		if (this.editable){
			this.cell.innerHTML="";
		}
		else {
			this.obj.style.width="0px";
			this.obj.style.height="0px";
		}
		this.cell.appendChild(this.obj);
		this.list.options[selOptId].selected=true;

		//fix for coro - FF scrolls grid in incorrect position
		if (this.editable){
			this.obj.focus();
			this.obj.focus();
		}

		if (!this.editable){
			this.obj.style.visibility="hidden";
			this.obj.style.position="absolute";
			this.list.focus();
			this.list.onkeydown=function(e){
				e=e||window.event;
				editor_obj.grid.setActive(true)

				if (e.keyCode < 30)
					return editor_obj.grid.doKey({
						target: editor_obj.cell,
						keyCode: e.keyCode,
						shiftKey: e.shiftKey,
						ctrlKey: e.ctrlKey
						})
			}
		}
	}

	this.getValue=function(){
		return ((this.cell.combo_value == window.undefined) ? "" : this.cell.combo_value);
	}
	this.detach=function(){
		if (this.val != this.getValue()){
			this.cell.wasChanged=true;
		}

		if (this.list.parentNode != null){
			if (this.editable){
					var ind = this.list.options[this.list.selectedIndex]
					if (ind&&ind.text == this.obj.value)
						this.setValue(this.list.value)
					else{
						var combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
						var val=combo.values._dhx_find(this.obj.value);
						if (val!=-1) this.setValue(combo.keys[val]);
						else this.setValue(this.cell.combo_value=this.obj.value);
					}
			}
			else
				this.setValue(this.list.value)
		}

		if (this.list.parentNode)
			this.list.parentNode.removeChild(this.list);

		if (this.obj.parentNode)
			this.obj.parentNode.removeChild(this.obj);

		return this.val != this.getValue();
	}
}
eXcell_co.prototype=new eXcell;
eXcell_co.prototype.getText=function(){
	return this.cell.innerHTML;
}
eXcell_co.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null
	this.cell.combo_value=val;
	
	if (val !== null){
		var label = (this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val);
		this.setCValue(label===null?val:label, val);
	}else
		this.setCValue("&nbsp;", val);

	
}
/**
*	@desc: selectbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_coro(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_coro.prototype=new eXcell_co;

function eXcell_cotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
}
eXcell_cotxt.prototype=new eXcell_co;
eXcell_cotxt.prototype.getText=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}
eXcell_cotxt.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null

	if (val !== null)
		this.setCTxtValue((this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val)||val, val);
	else
		this.setCTxtValue(" ", val);

	this.cell.combo_value=val;
}

function eXcell_corotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_corotxt.prototype=new eXcell_cotxt;
//#}

//#cp_excell:04062008{
/**
*	@desc: color picker editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cp(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("SPAN");
		this.obj.style.border="1px solid black";
		this.obj.style.position="absolute";
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox
		this.colorPanel(4, this.obj)
		document.body.appendChild(this.obj);          //this.grid.objBox.appendChild(this.obj);
		this.obj.style.left=arPos[0]+"px";
		this.obj.style.zIndex=1000;
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
	}
	this.toolDNum=function(value){
		if (value.length == 1)
			value='0'+value;
		return value;
	}
	this.colorPanel=function(index, parent){
		var tbl = document.createElement("TABLE");
		parent.appendChild(tbl)
		tbl.cellSpacing=0;
		tbl.editor_obj=this;
		tbl.style.cursor="default";
		tbl.onclick=function(e){
			var ev = e||window.event
			var cell = ev.target||ev.srcElement;
			var ed = cell.parentNode.parentNode.parentNode.editor_obj
			if (ed){
				ed.setValue(cell._bg);
				ed.grid.editStop();
			}
		}
		var cnt = 256 / index;
		for (var j = 0; j <= (256 / cnt); j++){
			var r = tbl.insertRow(j);

			for (var i = 0; i <= (256 / cnt); i++){
				for (var n = 0; n <= (256 / cnt); n++){
					R=new Number(cnt*j)-(j == 0 ? 0 : 1)
					G=new Number(cnt*i)-(i == 0 ? 0 : 1)
					B=new Number(cnt*n)-(n == 0 ? 0 : 1)
					var rgb =
						this.toolDNum(R.toString(16))+""+this.toolDNum(G.toString(16))+""+this.toolDNum(B.toString(16));
					var c = r.insertCell(i);
					c.width="10px";
					c.innerHTML="&nbsp;"; //R+":"+G+":"+B;//
					c.title=rgb.toUpperCase()
					c.style.backgroundColor="#"+rgb
					c._bg="#"+rgb;

					if (this.val != null&&"#"+rgb.toUpperCase() == this.val.toUpperCase()){
						c.style.border="2px solid white"
					}
				}
			}
		}
	}
	this.getValue=function(){
		return this.cell.firstChild._bg||""; //this.getBgColor()
	}
	this.getRed=function(){
		return Number(parseInt(this.getValue().substr(1, 2), 16))
	}
	this.getGreen=function(){
		return Number(parseInt(this.getValue().substr(3, 2), 16))
	}
	this.getBlue=function(){
		return Number(parseInt(this.getValue().substr(5, 2), 16))
	}
	this.detach=function(){
		if (this.obj.offsetParent != null)
			document.body.removeChild(this.obj);
		//this.obj.removeNode(true)
		return this.val != this.getValue();
	}
}
eXcell_cp.prototype=new eXcell;
eXcell_cp.prototype.setValue=function(val){
    this.setCValue("<div style='width:100%;height:"+((this.grid.multiLine?"100%":23))+";background-color:"+(val||"")
		+";border:0px;'>&nbsp;</div>",
		val);
	this.cell.firstChild._bg=val;
}
//#}

//#img_excell:04062008{
/**
*	@desc: image editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
/*
	The corresponding  cell value in XML should be a "^" delimited list of following values:
	1st - image src
	2nd - image alt text (optional)
	3rd - link (optional)
	4rd - target (optional, default is _self)
*/
function eXcell_img(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.getValue=function(){
		if (this.cell.firstChild.tagName == "IMG")
			return this.cell.firstChild.src+(this.cell.titFl != null
				? "^"+this.cell._brval
				: "");
			else if (this.cell.firstChild.tagName == "A"){
			var out = this.cell.firstChild.firstChild.src+(this.cell.titFl != null ? "^"+this.cell._brval : "");
			out+="^"+this.cell.lnk;

			if (this.cell.trg)
				out+="^"+this.cell.trg
			return out;
		}
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_img.prototype=new eXcell;
eXcell_img.prototype.getTitle=function(){
	return this.cell._brval
}
eXcell_img.prototype.setValue=function(val){
	var title = val;

	if ((val||"").indexOf("^") != -1){
		var ar = val.split("^");
		val=ar[0]
		title=this.cell._attrs.title||ar[1];

		//link
		if (ar.length > 2){
			this.cell.lnk=ar[2]

			if (ar[3])
				this.cell.trg=ar[3]
		}
		this.cell.titFl="1";
	}
	if (!this.grid.multiLine)
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0' style='max-height:"+(this.grid._srdh-4)+"px'>", val);
	else
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0'>", val);

	if (this.cell.lnk){
		this.cell.innerHTML="<a href='"+this.cell.lnk+"' target='"+this.cell.trg+"'>"+this.cell.innerHTML+"</a>"
	}
	this.cell._brval=title;
}
function eXcell_icon(cell){
	this.base=eXcell_ed;
	this.base(cell)
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}

	this.setValue=function(val){
		this.cell._raw_value = val;
		this.setCValue('<div class="dhx_grid_icon"><i class="fa fa-'+val.toString()._dhx_trim()+'"></i></div>');
	}
	this.getValue=function(){
		return this.cell._raw_value;
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_icon.prototype=new eXcell_ed;
//#}

//#price_excell:04062008{
/**
*	@desc: text editor with price (USD) formatting
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_price(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (this.cell.childNodes.length > 1)
			return this.cell.childNodes[1].innerHTML.toString()._dhx_trim()
		else
			return "0";
	}
}

eXcell_price.prototype=new eXcell_ed;
eXcell_price.prototype.setValue=function(val){
	if (isNaN(parseFloat(val))){
		val=this.val||0;
	}
	var color = "green";

	if (val < 0)
		color="red";

	this.setCValue("<span>$</span><span style='padding-right:2px;color:"+color+";'>"+val+"</span>", val);
}
//#}

//#dyn_excells:04062008{
/**
*	@desc: text editor with additional formatting for positive and negative numbers (arrow down/up and color)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_dyn(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		return this.cell.firstChild.childNodes[1].innerHTML.toString()._dhx_trim()
	}
}

eXcell_dyn.prototype=new eXcell_ed;
eXcell_dyn.prototype.setValue=function(val){
	if (!val||isNaN(Number(val))){
		if (val!=="")
			val=0;
	}

	if (val > 0){
		var color = "green";
		var img = "dyn_up.gif";
	} else if (val == 0){
		var color = "black";
		var img = "dyn_.gif";
	} else {
		var color = "red";
		var img = "dyn_down.gif";
	}
	this.setCValue("<div class='grid_cell_dyn'><img src='"+this.grid.imgURL+""+img
		+"'><span style='color:"+color+";'>"+val
		+"</span></div>",
		val);
}
//#}

/**
*	@desc: readonly editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ro(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell.innerHTML.toString()._dhx_trim();
	}
}
eXcell_ro.prototype=new eXcell;


window.eXcell_hidden = function(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell.val;
	}
}
eXcell_hidden.prototype=new eXcell;
eXcell_hidden.prototype.setValue = function(value){
	this.cell.val = value;
}

function eXcell_ron(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex).toString();
	}
}
eXcell_ron.prototype=new eXcell;
eXcell_ron.prototype.setValue=function(val){ 
	if (val === 0){}
	else if (!val||val.toString()._dhx_trim() == ""){
		this.setCValue("&nbsp;");
		return this.cell._clearCell=true;
	}
	this.cell._orig_value = val;
	this.cell._clearCell=false;
	this.setCValue(val?this.grid._aplNF(val, this.cell._cellIndex):"0");
}


/**
*	@desc: readonly pure text editor (without HTML support)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_rotxt(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.setValue=function(val){
		if (!val){
			val=" ";
			this.cell._clearCell = true;
		}
		else
			this.cell._clearCell = false;
			
		this.setCTxtValue(val);
	}
	this.getValue=function(){
		if (this.cell._clearCell)
			return "";
		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}	
}
eXcell_rotxt.prototype=new eXcell;

/**
	*	@desc: combobox object constructor (shouldn't be accessed directly - instead please use getCombo(...) method of the grid)
	*	@type: private
	*	@returns: combobox for dhtmlxGrid
	*/
function dhtmlXGridComboObject(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	/**
	*	@desc: puts new combination of key and value into combobox
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@param: value - object value of combobox line
	*/
	this.put=function(key, value){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.values[i]=value;
				return true;
			}
		}
		this.values[this.values.length]=value;
		this.keys[this.keys.length]=key;
	}
	/**
	*	@desc: gets value corresponding to the given key
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@returns: value correspond. to given key or null if no such key
	*/
	this.get=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				return this.values[i];
			}
		}
		return null;
	}
	/**
	*	@desc: clears combobox
	*	@type: public
	*/
	this.clear=function(){
		/*for(var i=0;i<this.keys.length;i++){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
		}*/
		this.keys=new dhtmlxArray();
		this.values=new dhtmlxArray();
	}
	/**
	*	@desc: remove pair of key-value from combobox with given key 
	*	@type: public
	*	@param: key - object to use as a key
	*/
	this.remove=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
				return true;
			}
		}
	}
	/**
	*	@desc: gets the size of combobox 
	*	@type: public
	*	@returns: current size of combobox
	*/
	this.size=function(){
		var j = 0;

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				j++;
		}
		return j;
	}
	/**
	*	@desc: gets array of all available keys present in combobox
	*	@type: public
	*	@returns: array of all available keys
	*/
	this.getKeys=function(){
		var keyAr = new Array(0);

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				keyAr[keyAr.length]=this.keys[i];
		}
		return keyAr;
	}

	/**
	*	@desc: save curent state
	*	@type: public
	*/
	this.save=function(){
		this._save=new Array();

		for (var i = 0; i < this.keys.length; i++)this._save[i]=[
			this.keys[i],
			this.values[i]
		];
	}


	/**
	*	@desc: restore saved state
	*	@type: public
	*/
	this.restore=function(){
		if (this._save){
			this.keys[i]=new Array();
			this.values[i]=new Array();

			for (var i = 0; i < this._save.length; i++){
				this.keys[i]=this._save[i][0];
				this.values[i]=this._save[i][1];
			}
		}
	}
	return this;
}

function Hashtable(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	return this;
}
Hashtable.prototype=new dhtmlXGridComboObject;

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachGrid = function() {
		
		this.callEvent("_onBeforeContentAttach",["grid"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		this.dataType = "grid";
		this.dataObj = new dhtmlXGridObject(obj);
		this.dataObj.setSkin(this.conf.skin);
		
		// fix for grid atatched to tabbar for safari on ios 5.1.7
		if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell && navigator.userAgent.match(/7[\.\d]* mobile/gi) != null && navigator.userAgent.match(/AppleWebKit/gi) != null) {
			this.dataObj.objBox.style.webkitOverflowScrolling = "auto";
		}
		
		// fix layout cell for material
		if (this.conf.skin == "material" && typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) {
			this.cell.childNodes[this.conf.idx.cont].style.overflow = "hidden";
		}
		
		
		// keep border for window and remove for other
		if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
			this.dataObj.entBox.style.border = "1px solid #a4bed4";
			this.dataObj._sizeFix = 0;
		} else {
			this.dataObj.entBox.style.border = "0px solid white";
			this.dataObj._sizeFix = 2;
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
	};
	
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableDragAndDrop=function(mode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

		this.dragAndDropOff=dhx4.s2b(mode);
		this._drag_validate=true;
		if (mode)
			this.objBox.ondragstart = function (e) {
				(e||event).cancelBubble = true;
				return false;
			}
       };

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling
*     @type: public
*     @param: mode - behavior name (child,sibling,complex)
*     @topic: 0
*/
dhtmlXGridObject.prototype.setDragBehavior=function(mode){
        this.dadmodec=this.dadmodefix=0;
      switch (mode) {
         case "child": this.dadmode=0; this._sbmod=false;  break;
         case "sibling": this.dadmode=1; this._sbmod=false;  break;
         case "sibling-next": this.dadmode=1; this._sbmod=true; break;
         case "complex": this.dadmode=2; this._sbmod=false;  break;
         case "complex-next": this.dadmode=2; this._sbmod=true;  break;
      }    };


/**
*     @desc: switch to mode when draged item, droped in target location in same order as they was in source grid
*     @type: public
*     @param: mode - true/false to enable/disable mode
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableDragOrder=function(mode){
        this._dndorder=dhx4.s2b(mode);
};


dhtmlXGridObject.prototype._checkParent=function(row,ids){
	var z=this._h2.get[row.idd].parent;
	if (!z.parent) return;
	for (var i=0; i<ids.length; i++) 
		if (ids[i]==z.id) return true;
		
	return this._checkParent(this.rowsAr[z.id],ids);
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXGridObject.prototype._createDragNode=function(htmlObject,e){
	  this.editStop();
	  if (window.dhtmlDragAndDrop.dragNode) return null;
      if (!this.dADTempOff) return null;
      htmlObject.parentObject=new Object();
      htmlObject.parentObject.treeNod=this;

	var text=this.callEvent("onBeforeDrag",[htmlObject.parentNode.idd,htmlObject._cellIndex, e]);
	if (!text) return null;

      var z=new Array();
//#__pro_feature:21092006{
      z=this.getSelectedId();
	  z=(((z)&&(z!=""))?z.split(this.delim):[]);
      var exst=false;
      for (var i=0; i<z.length; i++)
        if (z[i]==htmlObject.parentNode.idd)  exst=true;
      if (!exst){
      	this.selectRow(this.rowsAr[htmlObject.parentNode.idd],false,e.ctrlKey,false);
      	if (!e.ctrlKey) {
      		z=[];
  		}
//#}
          z[this.selMultiRows?z.length:0]=htmlObject.parentNode.idd;
//#__pro_feature:21092006{
    }
//#}

	//remove child in case of treeGrid
	if (this.isTreeGrid()){
		for (var i=z.length-1; i>=0; i--) 
			if (this._checkParent(this.rowsAr[z[i]],z)) z.splice(i,1);
				
	}
	

	var self=this;
	if (z.length && this._dndorder)
		z.sort(function(a,b){ return (self.rowsAr[a].rowIndex>self.rowsAr[b].rowIndex?1:-1); });

     var el = this.getFirstParentOfType(_isIE?e.srcElement:e.target,"TD");
     if (el) this._dndExtra=el._cellIndex;
      this._dragged=new Array();
      for (var i=0; i<z.length; i++)
          if (this.rowsAr[z[i]]){
          this._dragged[this._dragged.length]=this.rowsAr[z[i]];
          this.rowsAr[z[i]].treeNod=this;
          }

      htmlObject.parentObject.parentNode=htmlObject.parentNode;

   var dragSpan=document.createElement('div');
   dragSpan.innerHTML=(text!==true?text:this.rowToDragElement(htmlObject.parentNode.idd));
   dragSpan.style.position="absolute";
   dragSpan.className="dragSpanDiv";
   return dragSpan;
}



/**
*   @desc:  create a drag visual marker
*   @type:  private
*/
dhtmlXGridObject.prototype._createSdrgc=function(){
    this._sdrgc=document.createElement("DIV");
    this._sdrgc.innerHTML="&nbsp;";
    this._sdrgc.className="gridDragLine";
    this.objBox.appendChild(this._sdrgc);
}











/**
*   @desc:  create a drag context object
*   @type:  private
*/
function dragContext(a,b,c,d,e,f,j,h,k,l,m){
    this.source=a||"grid";
    this.target=b||"grid";
    this.mode=c||"move";
    this.dropmode=d||"child";
    this.sid=e||0;
    this.tid=f;
    this.sobj=j||null;
    this.tobj=h||null;
   this.sExtra=k||null;
   this.tExtra=l||null;
   this.before=m||false;
    return this;
}
/**
*   @desc:  check is operation possible
*   @type:  private
*/
dragContext.prototype.valid=function(){
   if (this.sobj!=this.tobj) return true;
   if (this.sid==this.tid) return false;
   if (this.target=="treeGrid"){
      var z=this.tid
      while (z = this.tobj.getParentId(z) ){
         if (this.sid==z) return false;
         }
   }
   return true;
}
/**
*   @desc:  close context
*   @type:  private
*/
dragContext.prototype.close=function(){
    this.sobj=null;
    this.tobj=null;
}
/**
*   @desc:  return copy of context
*   @type:  private
*/
dragContext.prototype.copy=function(){
    return new dragContext(this.source,this.target,this.mode,this.dropmode,this.sid,this.tid,this.sobj,this.tobj,this.sExtra,this.tExtra,this.before);
}
/**
*   @desc:  set a lue of context attribute
*   @type:  private
*/
dragContext.prototype.set=function(a,b){
    this[a]=b;
    return this;
}
/**
*   @desc:  generate an Id for new node
*   @type:  private
*/
dragContext.prototype.uid=function(a,b){
    this.nid=this.sid;
    while (this.tobj.rowsAr[this.nid])
        this.nid=this.nid+((new Date()).valueOf());

    return this;
}
/**
*   @desc:  get data array for grid row
*   @type:  private
*/
dragContext.prototype.data=function(){
    if (this.sobj==this.tobj)
        return this.sobj._getRowArray(this.sobj.rowsAr[this.sid]);
    if (this.source=="tree")
        return this.tobj.treeToGridElement(this.sobj,this.sid,this.tid);
    else
        return this.tobj.gridToGrid(this.sid,this.sobj,this.tobj);
}
dragContext.prototype.attrs=function(){
    if (this.source=="tree")
        return {};
    else
        return this.sobj.rowsAr[this.sid]._attrs;
}
dragContext.prototype.childs=function(){
    if (this.source=="treeGrid")
		return this.sobj._h2.get[this.sid]._xml_await?this.sobj._h2.get[this.sid].has_kids:null;
	return null;
}

/**
*   @desc:  return parent id for row in context
*   @type:  private
*/
dragContext.prototype.pid=function(){
    if (!this.tid) return 0;
	if (!this.tobj._h2) return 0;
    if (this.target=="treeGrid")
        if (this.dropmode=="child")
            return this.tid;
        else{
			var z=this.tobj.rowsAr[this.tid];
			var apid=this.tobj._h2.get[z.idd].parent.id;
			if ((this.alfa)&&(this.tobj._sbmod)&&(z.nextSibling)){
				var zpid=this.tobj._h2.get[z.nextSibling.idd].parent.id;
				if (zpid==this.tid)
            		return this.tid;
				if (zpid!=apid)
            		return zpid;
			}
	        return apid;
	   }
}
/**
*   @desc:  get index of target position
*   @type:  private
*/
dragContext.prototype.ind=function(){ 
    if (this.tid==window.unknown) return this.tobj.rowsBuffer.length;
    if (this.target=="treeGrid"){
      if (this.dropmode=="child")
            this.tobj.openItem(this.tid);
      else
         this.tobj.openItem(this.tobj.getParentId(this.tid));
   }
    var ind=this.tobj.rowsBuffer._dhx_find(this.tobj.rowsAr[this.tid]);
	if ((this.alfa)&&(this.tobj._sbmod)&&(this.dropmode=="sibling")){
		var z=this.tobj.rowsAr[this.tid];
		if ((z.nextSibling)&&(this._h2.get[z.nextSibling.idd].parent.id==this.tid))
			return ind+1;
	}

    return (ind+1+((this.target=="treeGrid" && ind>=0 && this.tobj._h2.get[this.tobj.rowsBuffer[ind].idd].state=="minus")?this.tobj._getOpenLenght(this.tobj.rowsBuffer[ind].idd,0):0));
}

/**
*   @desc:  get row related image
*   @type:  private
*/
dragContext.prototype.img=function(){
    if ((this.target!="grid")&&(this.sobj._h2))
      return this.sobj.getItemImage(this.sid);
   else return null;
}

/**
*   @desc:  return list of rows in context
*   @type:  private
*/
dragContext.prototype.slist=function(){
    var res=new Array();
    for (var i=0; i<this.sid.length; i++)
        res[res.length]=this.sid[i][(this.source=="tree")?"id":"idd"];

    return res.join(",");
}


/**
*   @desc:  drag entry point
*   @type:  private
*/
dhtmlXGridObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject,lastLanding){
   if (this._realfake) return this._fake._drag();

   var z=(this.lastLanding)
    //close unfinished tasks
    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

    //detect details
    var r1=targetHtmlObject.parentNode;
    var r2=sourceHtmlObject.parentObject;
    //drop on header
    if (!r1.idd) { r1.grid=this;    this.dadmodefix=0; }

    var c=new dragContext(0,0,0,((r1.grid.dadmode==1 || r1.grid.dadmodec)?"sibling":"child"));


    if (r2 && r2.childNodes)
        c.set("source","tree").set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
    else{
    	if (!r2) return true;
        if (r2.treeNod.isTreeGrid && r2.treeNod.isTreeGrid())
        	c.set("source","treeGrid");
        c.set("sobj",r2.treeNod).set("sid",c.sobj._dragged);
        }

    if (r1.grid.isTreeGrid())
        c.set("target","treeGrid");
	else
		c.set("dropmode","sibling");
    c.set("tobj",r1.grid).set("tid",r1.idd);

//#__pro_feature:21092006{
    //complex drag mode - adjust tartget element
    if (((c.tobj.dadmode==2)&&(c.tobj.dadmodec==1))&&(c.tobj.dadmodefix<0))
       if (c.tobj.obj.rows[1].idd!=c.tid) c.tid=r1.previousSibling.idd;
       else {
         if (this._h2 && c.tid)
           c.before = true;
         else c.tid=0;
       }
//#}

   var el = this.getFirstParentOfType(lastLanding,"TD")
   if (el) c.set("tExtra",el._cellIndex);
   if (el) c.set("sExtra",c.sobj._dndExtra);

    if (c.sobj.dpcpy) c.set("mode","copy");
    
    if (c.tobj._realfake) c.tobj=c.tobj._fake;
    if (c.sobj._realfake) c.sobj=c.sobj._fake;
    
    c.tobj._clearMove();
    
	if (r2 && r2.treeNod && r2.treeNod._nonTrivialRow)
		r2.treeNod._nonTrivialRow(this,c.tid,c.dropmode,r2);
	else {
		c.tobj.dragContext=c;
	    if (!c.tobj.callEvent("onDrag",[c.slist(),c.tid,c.sobj,c.tobj,c.sExtra,c.tExtra]))  return  c.tobj.dragContext=null;
	
	   //all ready, start mantras
	   var result=new Array();
	   if (typeof(c.sid)=="object"){
	        var nc=c.copy();
	        for (var i=0; i<c.sid.length; i++){
	         if (!nc.set("alfa",(!i)).set("sid",c.sid[i][(c.source=="tree"?"id":"idd")]).valid()) continue;
	            nc.tobj._dragRoutine(nc);
	            if (nc.target=="treeGrid" && nc.dropmode == "child") nc.tobj.openItem(nc.tid);
	            result[result.length]=nc.nid;
	         nc.set("dropmode","sibling").set("tid",nc.nid);
	            }
	        nc.close();
	        }
	    else
	       c.tobj._dragRoutine(c);		

	   //finish math if any awaiting
	   if (c.tobj.laterLink) c.tobj.laterLink();
	   //destroy context
		c.tobj.callEvent("onDrop",[c.slist(),c.tid,result.join(","),c.sobj,c.tobj,c.sExtra,c.tExtra]);
	}

   c.tobj.dragContext=null;
   c.close();
}


/**
*   @desc:  context drag routine
*   @type:  private
*/
dhtmlXGridObject.prototype._dragRoutine=function(c){
      if ((c.sobj==c.tobj)&&(c.source=="grid")&&(c.mode=="move")&&!this._fake){
         //special case for moving rows in same grid
         if (c.sobj._dndProblematic) return;
         var fr=c.sobj.rowsAr[c.sid];
         var bind=c.sobj.rowsCol._dhx_find(fr);
         c.sobj.rowsCol._dhx_removeAt(c.sobj.rowsCol._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_removeAt(c.sobj.rowsBuffer._dhx_find(fr));
         c.sobj.rowsBuffer._dhx_insertAt(c.ind(),fr);
         if (c.tobj._fake){
         	c.tobj._fake.rowsCol._dhx_removeAt(bind);
         	var tr=c.tobj._fake.rowsAr[c.sid];
         	tr.parentNode.removeChild(tr);
     	 }         
         c.sobj._insertRowAt(fr,c.ind()-(this.pagingOn?((this.currentPage-1)*this.rowsBufferOutSize):0));

         c.nid=c.sid;
         c.sobj.callEvent("onGridReconstructed",[]);
         return;
      }
      var new_row;
		if (this._h2 && typeof c.tid !="undefined" && c.dropmode=="sibling" && (this._sbmod || c.tid)){
      if (c.before)
        new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),c.tid,c.img(),c.childs());
			else if (c.alfa && this._sbmod && this._h2.get[c.tid].childs.length){
				this.openItem(c.tid)
				new_row=c.uid().tobj.addRowBefore(c.nid,c.data(),this._h2.get[c.tid].childs[0].id,c.img(),c.childs());
			}
			else
		  	new_row=c.uid().tobj.addRowAfter(c.nid,c.data(),c.tid,c.img(),c.childs());
		}
		else
        	new_row=c.uid().tobj.addRow(c.nid,c.data(),c.ind(),c.pid(),c.img(),c.childs());

          new_row._attrs = c.attrs();
		
		
        if (c.source=="tree"){
        	this.callEvent("onRowAdded",[c.nid]);            
            var sn=c.sobj._globalIdStorageFind(c.sid);
            if (sn.childsCount){
                var nc=c.copy().set("tid",c.nid).set("dropmode",c.target=="grid"?"sibling":"child");
              for(var j=0;j<sn.childsCount;j++){
                    c.tobj._dragRoutine(nc.set("sid",sn.childNodes[j].id));
                    if (c.mode=="move") j--;
                    }
                nc.close();
                }
        }
        else{
            c.tobj._copyUserData(c);
			this.callEvent("onRowAdded",[c.nid]);            
			
            if ((c.source=="treeGrid")){
            	
            	if (c.sobj==c.tobj) new_row._xml=c.sobj.rowsAr[c.sid]._xml;
                var snc=c.sobj._h2.get[c.sid];
                if ((snc)&&(snc.childs.length)){
                    var nc=c.copy().set("tid",c.nid);
                    if(c.target=="grid")
                        nc.set("dropmode","sibling");
                    else {
                        if (!nc.tobj.kidsXmlFile)
                    	   nc.tobj.openItem(c.tid);
                        nc.set("dropmode","child");
                        }
					var l=snc.childs.length;
                    if (!nc.tobj.kidsXmlFile)
                    for(var j=0;j<l;j++){
                    	c.sobj.render_row_tree(null,snc.childs[j].id);
                        c.tobj._dragRoutine(nc.set("sid",snc.childs[j].id));
                        if (l!=snc.childs.length) {  j--; l=snc.childs.length; }
                        }
                    nc.close();
                    }
            }
        }

        if (c.mode=="move"){
           c.sobj[(c.source=="tree")?"deleteItem":"deleteRow"](c.sid);
           if ((c.sobj==c.tobj)&&(!c.tobj.rowsAr[c.sid])) {
               c.tobj.changeRowId(c.nid,c.sid);
            c.nid=c.sid;
         }
      }
}


/**
*   @desc: redefine this method in your code to define how grid row values should be used in another grid
*   @param: rowId - id of draged row
*   @param: sgrid - source grid object
*   @param: tgrid - target grid object
*   @returns: array of values for cells in target grid row
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToGrid = function(rowId,sgrid,tgrid){
    var z=new Array();
    for (var i=0; i<sgrid.hdr.rows[0].cells.length; i++)
        z[i]=sgrid.cells(rowId,i).getValue();
   return z;
}

/**
*   @desc:  check if d-n-d is in allowed rules
*   @type:  private
*/
dhtmlXGridObject.prototype.checkParentLine=function(node,id){
    if ((!this._h2)||(!id)||(!node)) return false;
    if (node.id==id) return true;
    else return this.checkParentLine(node.parent,id);
}

/**
*   @desc:  called when drag moved over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){
                    if (!this.dADTempOff) return 0;
                    var tree=this.isTreeGrid();
                    var obj=shtmlObject.parentNode.idd?shtmlObject.parentNode:shtmlObject.parentObject;
                    
					if (this._drag_validate){
                    	if(htmlObject.parentNode==shtmlObject.parentNode)
                        	return 0;
                        	
	                    if ((tree)&&(this==obj.grid)&&((this.checkParentLine(this._h2.get[htmlObject.parentNode.idd],shtmlObject.parentNode.idd))))
    	                    return 0;
    	            }
                    if (!this.callEvent("onDragIn",[obj.idd||obj.id,htmlObject.parentNode.idd,obj.grid||obj.treeNod,(htmlObject.grid||htmlObject.parentNode.grid)]))
                        return this._setMove(htmlObject,x,y,true);

                    this._setMove(htmlObject,x,y);

                  if ((tree)&&(htmlObject.parentNode.expand!="")){
                    var self = this;
                    this._autoOpenTimer=window.setTimeout(function(){
                      self._autoOpenItem(null, self);
                      self = null;
                    },1000);
                    this._autoOpenId=htmlObject.parentNode.idd;
                  }
                  else
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);

                    return htmlObject;
}
/**
*   @desc:  open item on timeout
*   @type:  private
*/
dhtmlXGridObject.prototype._autoOpenItem=function(e,gridObject){
	   gridObject.openItem(gridObject._autoOpenId);
}

/**
*   @desc:  called on onmouseout event , when drag out landing zone
*   @type:  private
*/
dhtmlXGridObject.prototype._dragOut=function(htmlObject){
                    this._clearMove();
                    var obj=htmlObject.parentNode.parentObject?htmlObject.parentObject.id:htmlObject.parentNode.idd;
                    this.callEvent("onDragOut",[obj]);
                    if  (this._autoOpenTimer) window.clearTimeout(this._autoOpenTimer);
}
/**
*   @desc:  set visual effect for moving row over landing
*   @type:  private
*/
dhtmlXGridObject.prototype._setMove=function(htmlObject,x,y,skip){
   if (!htmlObject.parentNode.idd) return;
   var a1=dhx4.absTop(htmlObject);
   var a2=dhx4.absTop(this.objBox);
   

   //scroll down
   if ( (a1-a2)>(parseInt(this.objBox.offsetHeight)-50) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)+20;
   //scroll top
   if ( (a1-a2+parseInt(this.objBox.scrollTop))<(parseInt(this.objBox.scrollTop)+30) )
      this.objBox.scrollTop=parseInt(this.objBox.scrollTop)-20;
      
   if (skip) return 0;
   
    if (this.dadmode==2)
    {

        var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlObject.offsetHeight/2;
        if ((Math.abs(z)-htmlObject.offsetHeight/6)>0)
        {
        this.dadmodec=1;
      //sibbling zone
        if (z<0)  this.dadmodefix=-1; else   this.dadmodefix=1;
        }
        else this.dadmodec=0;
    }
    else
        this.dadmodec=this.dadmode;




    if (this.dadmodec){
      if (!this._sdrgc) this._createSdrgc();
      this._sdrgc.style.display="block";
      this._sdrgc.style.top=a1-a2+parseInt(this.objBox.scrollTop)+((this.dadmodefix>=0)?htmlObject.offsetHeight:0)+"px";
    }
    else{
      this._llSelD=htmlObject;
      if (htmlObject.parentNode.tagName=="TR")
      for (var i=0; i<htmlObject.parentNode.childNodes.length; i++)
      {
      var z= htmlObject.parentNode.childNodes[i];
	  z._bgCol=z.style.backgroundColor;
      z.style.backgroundColor="#FFCCCC";
      }
    }
}
/**
*   @desc:  remove all visual effects
*   @type:  private
*/
dhtmlXGridObject.prototype._clearMove=function(){
    if (this._sdrgc) this._sdrgc.style.display="none";
    if ((this._llSelD)&&(this._llSelD.parentNode.tagName=="TR")){
    	var coll = this._llSelD.parentNode.childNodes;
        for (var i=0; i<coll.length; i++)
           coll[i].style.backgroundColor=coll[i]._bgCol;
	}       

    this._llSelD=null;
}


/**
*   @desc: redefine this method in your code to define how grid row values should be displaied while draging
*   @param: gridRowId - id of grid row
*   @returns: html string representing dragging row 
*   @type: public
*   @topic: 7
*/
dhtmlXGridObject.prototype.rowToDragElement=function(gridRowId){
    var out=this.cells(gridRowId,0).getValue();
    return out;
}








/**
*   @desc:  copy user data for row
*   @type:  private
*/
dhtmlXGridObject.prototype._copyUserData = function(c){
			if(!c.tobj.UserData[c.nid] || c.tobj!=c.sobj)
            	c.tobj.UserData[c.nid] = new Hashtable();
            else return;

            var z1 = c.sobj.UserData[c.sid];
            var z2 = c.tobj.UserData[c.nid];
            if (z1) {
                z2.keys = z2.keys.concat(z1.keys);
                z2.values = z2.values.concat(z1.values);
            }
    }



/**
*     @desc: move row
*     @type:  public
*     @param: rowId - source row Id
*     @param: mode - moving mode (up,down,row_sibling)
*     @param: targetId - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRow=function(rowId,mode,targetId,targetGrid){
      switch(mode){
      case "row_sibling":
                    this.moveRowTo(rowId,targetId,"move","sibling",this,targetGrid);
         break;
      case "up":
               this.moveRowUp(rowId);
         break;
      case "down":
               this.moveRowDown(rowId);
          break;
      }
}





//#__pro_feature:21092006{

/**
*   @desc: move rows from grid to tree
*   @param: tree - object of tree
*   @param: targetObject - target node of tree
*   @param: beforeNode - anchor node of tree
*   @param: itemObject - dragged node
*   @param: z2 - flag of recursion
*   @type:  private
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype._nonTrivialNode=function(tree,targetObject,beforeNode,itemObject,z2)
{
    if ((tree.callEvent)&&(!z2))
          if (!tree.callEvent("onDrag",[itemObject.idd,targetObject.id,(beforeNode?beforeNode.id:null),this,tree])) return false;

    var gridRowId = itemObject.idd;
    var treeNodeId = gridRowId;
    while (tree._idpull[treeNodeId]) treeNodeId+=(new Date()).getMilliseconds().toString();

   var img=(this.isTreeGrid()?this.getItemImage(gridRowId):"")
	if (beforeNode){
		for (i=0; i<targetObject.childsCount; i++)
		    if (targetObject.childNodes[i]==beforeNode) break;
		
		if (i!=0)
		    beforeNode=targetObject.childNodes[i-1];
		else{
		    st="TOP";
		    beforeNode="";
		    }
	}   
   var newone=tree._attachChildNode(targetObject,treeNodeId,this.gridToTreeElement(tree,treeNodeId,gridRowId),"",img,img,img,"","",beforeNode);
    if (this._h2){
      var akids=this._h2.get[gridRowId];
      if (akids.childs.length)
      for (var i=0; i<akids.childs.length; i++){
          this._nonTrivialNode(tree,newone,0,this.rowsAr[akids.childs[i].id],1);
          if (!this.dpcpy) i--;
      }
    }

    if (!this.dpcpy) this.deleteRow(gridRowId);

    if ((tree.callEvent)&&(!z2))
       tree.callEvent("onDrop",[treeNodeId,targetObject.id,(beforeNode?beforeNode.id:null),this,tree]);
}

/**
*   @desc: redefine this method in your code to define how grid row values should be used in tree (using input parameters you can change id of new tree node, set label, set userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then grid row will be moved to tree, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.gridToTreeElement = function(treeObj,treeNodeId,gridRowId){
   return this.cells(gridRowId,0).getValue();
}

/**
*   @desc: redefine this method in your code to define how tree node values should be used in grid (using input parameters you can change id of new row, values for cells, userdata blocks etc.).
*   @param: treeObj - object of tree
*   @param: treeNodeId - id of node created in tree
*   @param: gridRowId - id of grid row
*   @returns: if true, then tree node should be moved to grid, else - copied
*   @type: public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.treeToGridElement = function(treeObj,treeNodeId,gridRowId){
    var w=new Array();
    var z=this.cellType._dhx_find("tree");
   if (z==-1) z=0;
   for(var i=0;i<this.getColumnCount();i++)
        w[w.length]=(i!=z)?(treeObj.getUserData(treeNodeId,this.getColumnId(i))||""):treeObj.getItemText(treeNodeId);
   return w;
}

/**
*     @desc: move row
*     @type:  public
*     @param: srowId - source row Id
*     @param: trowId - target row Id
*     @param: mode - move or copy
*     @param: dropmode - sibling or child
*     @param: sourceGrid - target row  in row_sibling mode
*     @param: targetGrid - used for moving between grids (optional)
*     @returns: moved item ID
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.moveRowTo=function(srowId,trowId,mode,dropmode,sourceGrid,targetGrid){
    var c=new dragContext((sourceGrid||this).isTreeGrid()?"treeGrid":"grid",(targetGrid||this).isTreeGrid()?"treeGrid":"grid",mode,dropmode||"sibling",srowId,trowId,sourceGrid||this,targetGrid||this);
    c.tobj._dragRoutine(c);
    c.close();
    return c.nid;
}

/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.toPDF=function(url,mode,header,footer,rows,target){
	var save_sel = {
		row: (this.getSelectedRowId()||"").split(this.delim),
		col: this.getSelectedCellIndex()
	};
	if (save_sel.row === null || save_sel.col === -1)
		save_sel = false;
	else {
		if (save_sel.row){
			for (var i=0; i<save_sel.row.length; i++){
				if (save_sel.row[i]){
					var el = this.cells(save_sel.row[i], save_sel.col).cell;
					el.parentNode.className = el.parentNode.className.replace(' rowselected', '');
					el.className = el.className.replace(' cellselected', '');
					save_sel.row[i] = el;
				}
			}
		} else 
			save_sel = false;
	}
	mode = mode || "color";	
	var full_color = mode == "full_color";
	var grid = this;
	grid._asCDATA = true;
	if (typeof(target) === 'undefined')
		this.target = " target=\"_blank\"";
	else
		this.target = target;
		
	eXcell_ch.prototype.getContent = function(){
		return this.getValue();
	};
	eXcell_ra.prototype.getContent = function(){
		return this.getValue();
	};
	function xml_top(profile) {
		var spans = [];
		for (var i=1; i<grid.hdr.rows.length; i++){
			spans[i]=[];
			for (var j=0; j<grid._cCount; j++){
				var cell = grid.hdr.rows[i].childNodes[j];
				if (!spans[i][j])
					spans[i][j]=[0,0];
				if (cell)
					spans[i][cell._cellIndexS]=[cell.colSpan, cell.rowSpan];
			}
		}
		
	    var xml = "<rows profile='"+profile+"'";
	       if (header)
	          xml+=" header='"+header+"'";
	       if (footer)
	          xml+=" footer='"+footer+"'";
	    xml+="><head>"+grid._serialiseExportConfig(spans).replace(/^<head/,"<columns").replace(/head>$/,"columns>");
	    for (var i=2; i < grid.hdr.rows.length; i++) {
                var empty_cols = 0;
                var row = grid.hdr.rows[i];
    	        var cxml="";
	    	for (var j=0; j < grid._cCount; j++) {
	    		if ((grid._srClmn && !grid._srClmn[j]) || (grid._hrrar[j] && ( !grid._fake || j >= grid._fake.hdrLabels.length))) {
	    			empty_cols++;
	    			continue;
    			}
	    		var s = spans[i][j];
	    		var rspan =  (( s[0] && s[0] > 1 ) ? ' colspan="'+s[0]+'" ' : "");
                        if (s[1] && s[1] > 1){
                             rspan+=' rowspan="'+s[1]+'" ';
                             empty_cols = -1;
                        }
                        
                
                var val = "";
                //split mode
                var frow = row;
                if (grid._fake && j < grid._fake._cCount)
                	frow = grid._fake.hdr.rows[i];

                for (var k=0; k<frow.cells.length; k++){
					if (frow.cells[k]._cellIndexS==j) {
						if (frow.cells[k].getElementsByTagName("SELECT").length)
							val="";
						else
							val = _isIE?frow.cells[k].innerText:frow.cells[k].textContent;
							val=val.replace(/[ \n\r\t\xA0]+/," ");
						break;
					}
				}
	    		if (!val || val==" ") empty_cols++;
	    		cxml+="<column"+rspan+"><![CDATA["+val+"]]></column>";
	    	};
	    	if (empty_cols != grid._cCount)
	    		xml+="\n<columns>"+cxml+"</columns>";
	    };
	    xml+="</head>\n";
	    xml+=xml_footer();
	    return xml;
	};
	
	function xml_body() {
		var xml =[];
	    if (rows)
	    	for (var i=0; i<rows.length; i++)
	    		xml.push(xml_row(grid.getRowIndex(rows[i])));
	    else
	    	for (var i=0; i<grid.getRowsNum(); i++)
	    		xml.push(xml_row(i));
	    return xml.join("\n");
	}
	function xml_footer() {
		var xml =["<foot>"];
		if (!grid.ftr) return "";
		for (var i=1; i < grid.ftr.rows.length; i++) {
			xml.push("<columns>");
			var row = grid.ftr.rows[i];
			for (var j=0; j < grid._cCount; j++){
				if (grid._srClmn && !grid._srClmn[j]) continue;
				if (grid._hrrar[j] && ( !grid._fake || j >= grid._fake.hdrLabels.length)) continue;
				for (var k=0; k<row.cells.length; k++){
				 	var val = "";
				 	var span = "";
					if (row.cells[k]._cellIndexS==j) {
						val = _isIE?row.cells[k].innerText:row.cells[k].textContent;
						val=val.replace(/[ \n\r\t\xA0]+/," ");
						
						if (row.cells[k].colSpan && row.cells[k].colSpan!=1)
							span = " colspan='"+row.cells[k].colSpan+"' ";
						
						if (row.cells[k].rowSpan && row.cells[k].rowSpan!=1)
							span = " rowspan='"+row.cells[k].rowSpan+"' ";
						break;
					}
				}
				xml.push("<column"+span+"><![CDATA["+val+"]]></column>");
			}
			xml.push("</columns>");
		};
		xml.push("</foot>");
	    return xml.join("\n");
	};
	function get_style(node, style){
		return (window.getComputedStyle?(window.getComputedStyle(node, null)[style]):(node.currentStyle?node.currentStyle[style]:null))||"";
	};
	
	function xml_row(ind){
		if (!grid.rowsBuffer[ind]) return "";
		var r = grid.render_row(ind);
		if (r.style.display=="none") return "";
		var level = grid.isTreeGrid() ? ' level="' + grid.getLevel(r.idd) + '"' : '';
		var xml = "<row" + level + ">";
		for (var i=0; i < grid._cCount; i++) {
			if (((!grid._srClmn)||(grid._srClmn[i]))&&(!grid._hrrar[i] || ( grid._fake && i < grid._fake.hdrLabels.length))){
				var cell = grid.cells(r.idd, i);
				if (full_color){
					var text_color	= get_style(cell.cell,"color");
		        	var bg_color	= get_style(cell.cell,"backgroundColor");
					var bold		= get_style(cell.cell, "font-weight") || get_style(cell.cell, "fontWeight");
					var italic		= get_style(cell.cell, "font-style") || get_style(cell.cell, "fontStyle");
					var align		= get_style(cell.cell, "text-align") || get_style(cell.cell, "textAlign");
					var font	 = get_style(cell.cell, "font-family") || get_style(cell.cell, "fontFamily");
		        	if (bg_color == "transparent" || bg_color == "rgba(0, 0, 0, 0)") bg_color = "rgb(255,255,255)";
		        	xml+="<cell bgColor='"+bg_color+"' textColor='" + text_color + "' bold='" + bold + "' italic='" + italic + "' align='"+align+"' font='" + font + "'>";
				} else 
					xml+="<cell>";
				
				xml+="<![CDATA["+(cell.getContent?cell.getContent():cell.getTitle())+"]]></cell>";
			}
		};
		return xml+"</row>";
	}
	function xml_end(){
	    var xml = "</rows>";
	    return xml;
	}


			
	var d=document.createElement("div");
	d.style.display="none";
	document.body.appendChild(d);
	var uid = "form_"+grid.uid();

	d.innerHTML = '<form id="'+uid+'" method="post" action="'+url+'" accept-charset="utf-8"  enctype="application/x-www-form-urlencoded"' + this.target + '><input type="hidden" name="grid_xml" id="grid_xml"/> </form>';
	document.getElementById(uid).firstChild.value = encodeURIComponent(xml_top(mode).replace("\u2013", "-") + xml_body() + xml_end());
	document.getElementById(uid).submit();
	d.parentNode.removeChild(d);


	grid = null;
	
	if (save_sel && save_sel.row.length) {
		for (var i = 0; i < save_sel.row.length; i++) {
			save_sel.row[i].parentNode.className += ' rowselected';
			if (save_sel.row.length == 1)
				save_sel.row[i].className += ' cellselected';
		}
	};
	save_sel = null;
};
dhtmlXGridObject.prototype._serialiseExportConfig=function(spans){
	function xmlentities(str) {
		if (typeof(str)!=='string') return str;
		str = str.replace(/&/g, "&amp;");
		str = str.replace(/"/g, "&quot;");
		str = str.replace(/'/g, "&apos;");
		str = str.replace(/</g, "&lt;");
		str = str.replace(/>/g, "&gt;");
		return str;
	}
	
	var out = "<head>";

	for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
		if (this._srClmn && !this._srClmn[i]) continue;
		if (this._hrrar[i] && ( !this._fake || i >= this._fake.hdrLabels.length)) continue;
		var sort = this.fldSort[i];
		if (sort == "cus"){
			sort = this._customSorts[i].toString();
			sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
		}
		var s = spans[1][i];
		var rpans = (( s[1] && s[1] > 1 ) ? ' rowspan="'+s[1]+'" ' : "")+(( s[0] && s[0] > 1 ) ? ' colspan="'+s[0]+'" ' : "");
		out+="<column "+rpans+" width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i] + "' hidden='" + ((this.isColumnHidden && this.isColumnHidden(i)) ? 'true' : 'false')
			+"' sort='"+(sort||"na")+"' color='"+(this.columnColor[i]||"")+"'"
			+(this.columnIds[i]
				? (" id='"+this.columnIds[i]+"'")
				: "")+">";
		if (this._asCDATA)
			out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
		else
			out+=this.getColumnLabel(i);
		var z = this.combos[i]?this.getCombo(i):null;

		if (z)
			for (var j = 0; j < z.keys.length; j++)out+="<option value='"+xmlentities(z.keys[j])+"'><![CDATA["+z.values[j]+"]]></option>";
		out+="</column>";
	}
	return out+="</head>";
};
if (window.eXcell_sub_row_grid)
	window.eXcell_sub_row_grid.prototype.getContent=function(){ return ""; };


dhtmlXGridObject.prototype.toExcel = function(url,mode,header,footer,rows) {
	if (!document.getElementById('ifr')) {
		var ifr = document.createElement('iframe');
		ifr.style.display = 'none';
		ifr.setAttribute('name', 'dhx_export_iframe');
		ifr.setAttribute('src', '');
		ifr.setAttribute('id', 'dhx_export_iframe');
		document.body.appendChild(ifr);
	}

	var target = " target=\"dhx_export_iframe\"";
	this.toPDF(url,mode,header,footer,rows,target);
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//please beware that function started from _in_header_ must not be obfuscated



/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterBy=function(column, value, preserve){
	if (this.isTreeGrid()) return this.filterTreeBy(column, value, preserve);
	if (this._f_rowsBuffer){
		if (!preserve){
			this.rowsBuffer=dhtmlxArray([].concat(this._f_rowsBuffer));
			if (this._fake) this._fake.rowsBuffer=this.rowsBuffer;
		}
	} else
		this._f_rowsBuffer=[].concat(this.rowsBuffer);	//backup copy
	
		
	if (!this.rowsBuffer.length) return;
	var d=true;
	this.dma(true)
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterA(column[j],value[j]);
	else
			this._filterA(column,value);
	this.dma(false)
	if (this.pagingOn && this.rowsBuffer.length/this.rowsBufferOutSize < (this.currentPage-1)) this.changePage(0);
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	if (!this.rowsBuffer.length) return;
	
	for (var i=this.rowsBuffer.length-1; i>=0; i--)
		if (d?(this._get_cell_value(this.rowsBuffer[i],column).toString().toLowerCase().indexOf(value)==-1):(!value.call(this, this._get_cell_value(this.rowsBuffer[i],column),this.rowsBuffer[i].idd)))
			this.rowsBuffer.splice(i,1);//filter row
}

dhtmlXGridObject.prototype.getFilterElement=function(index){
	if (!this.filters) return;
	for (var i=0; i < this.filters.length; i++) {
		if (this.filters[i][1]==index)
			return (this.filters[i][0].combo||this.filters[i][0]);
	};
	return null;
}

/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectValues=function(column){
	var evs = this.dhxevs.data.oncollectvalues;
	if (evs){
		var value = true;
		for (var key in evs){
			var nextvalue = evs[key].call(this, column);
			if (nextvalue !== true) value = nextvalue || value;
		}
		if (value !== true)
			return value;
 	}
 	
	if (this.isTreeGrid()) return this.collectTreeValues(column);
	this.dma(true)
	this._build_m_order();
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this.rowsBuffer;
	for (var i=0; i<col.length; i++){
		var val=this._get_cell_value(col[i],column);
		if (val && (!col[i]._childIndexes || col[i]._childIndexes[column]!=col[i]._childIndexes[column-1])) c[val]=true;
	}
	this.dma(false);
	var vals= (this.combos[column]||(this._col_combos?this._col_combos[column]:((this._sub_trees && this._sub_trees[column])?this._sub_trees[column][0]:false)));

	for (var d in c) 
		if (c[d]===true){
           if(vals){
               if(vals.get&&vals.get(d)){
                   d = vals.get(d);
               }
               else if(vals.getOption&&vals.getOption(d)){
                   d = vals.getOption(d).text;
               }
				else if(vals.getItemText){
                   var text = vals.getItemText(d);
                   var t = this._sub_trees[column][1] = this._sub_trees[column][1] || {};
                   t[text] = d;
                   d = text;
               }
           }
           f.push(d);
        }
	
	return f.sort();			
}

dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}
/**
*   @desc: force grid filtering by registered inputs ( created by # starting shortcuts, or by makeFilter function )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterByAll=function(){
	var a=[];
	var b=[];
	this._build_m_order();

	for (var i=0; i<this.filters.length; i++){
		var ind=this._m_order?this._m_order[this.filters[i][1]]:this.filters[i][1];
		if (ind >= this._cCount) continue;
		b.push(ind);

		var val=this.filters[i][0].old_value=this.filters[i][0].value;
		if (this.filters[i][0]._filter)
			val = this.filters[i][0]._filter();
		
		var vals;
		if (typeof val != "function" && (vals=(this.combos[ind]||(this._col_combos?this._col_combos[ind]:((this._sub_trees && this._sub_trees[ind])?this._sub_trees[ind][1]:false))))){
            if(vals.values){
                ind=vals.values._dhx_find(val);
			    val=(ind==-1)?val:vals.keys[ind];
            }
			else if(vals.getOptionByLabel){
                val=(vals.getOptionByLabel(val)?vals.getOptionByLabel(val).value:val);
            } else
            	val = vals[val];
		}
		a.push(val);
		
	}
	if (!this.callEvent("onFilterStart",[b,a])) return;

	this.filterBy(b,a);
	if (this._cssEven) this._fixAlterCss();
	this.callEvent("onFilterEnd",[this.filters]);

	if (this._f_rowsBuffer && this.rowsBuffer.length == this._f_rowsBuffer.length)
		this._f_rowsBuffer = null;
}

/**
*   @desc: create a filter from any input element (text filter), select (dropdown) or DIV (combobox based on dhtmlxCombo)
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*   @param: preserve - {bool} filter current state or initial one ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeFilter=function(id,column,preserve){
	if (!this.filters) this.filters=[];
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
	
	if (!id.style.width) id.style.width = "90%";
		
	if (id.tagName=='SELECT'){
		this.filters.push([id,column]);
		this._loadSelectOptins(id,column);
		id.onchange=function(){
			self.filterByAll();
		}
		if(_isIE)
			id.style.marginTop="1px";
			
		this.attachEvent("onEditCell",function(stage,a,ind){ 
			this._build_m_order();
			if (stage==2 && this.filters && ( this._m_order?(ind==this._m_order[column]):(ind==column) ))
				this._loadSelectOptins(id,column);
			return true;
		});
	} 
	else if (id.tagName=='INPUT'){
		this.filters.push([id,column]);
		id.old_value = id.value='';
		id.onkeydown=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value != id.old_value){
					self.filterByAll();
					id.old_value=id.value;
				}
			},500);
		};
	}
	else if (id.tagName=='DIV'){
		this.filters.push([id,column]);
		id.style.padding="0px";id.style.margin="0px";
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath=this.imgURL;
		var z=new dhtmlXCombo(id,"_filter","90%");
		z.filterSelfA=z.filterSelf;
		z.filterSelf=function(){
			if (this.getSelectedIndex()==0) this.setComboText("");
			this.filterSelfA.apply(this,arguments);
			this.optionsArr[0].hide(false);	
		}
         
         
		z.enableFilteringMode(true);
		id.combo=z;
		id.value="";
		
		this._loadComboOptins(id,column);
		z.attachEvent("onChange",function(){
			id.value=z.getSelectedValue();
			if (id.value === null) id.value = "";
			self.filterByAll();
		});
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
	
	this._filters_ready(); //set event handlers
}
	/**
	*   @desc: find cell in grid by value
	*   @param: value - search string
	*   @param: c_ind - index of column to search in (optional. if not specified, then search everywhere)
	*   @param: count - count of results to return
	*   @edition: Professional
	*   @returns: array each member of which contains array with row ID  and cell index
	*   @type:  public
	*/
	dhtmlXGridObject.prototype.findCell=function(value, c_ind, count, compare){ 
		var compare = compare || (function(master, check){
			return check.toString().toLowerCase().indexOf(master) != -1;
		});
		if (compare === true)
			compare = function(master, check){ return check.toString().toLowerCase() == master; };

		var res = new Array();
		value=value.toString().toLowerCase();
		if (typeof count != "number") count = count?1:0;
	
		if (!this.rowsBuffer.length)
			return res;
	
		for (var i = (c_ind||0); i < this._cCount; i++){
			if (this._h2)
				this._h2.forEachChild(0,function(el){
					if (count && res.length==count) return res;
					if (compare(value, this._get_cell_value(el.buff,i))){
						res.push([el.id,i]);
					}
				},this)
			else
				for (var j=0; j < this.rowsBuffer.length; j++) 
					if (compare(value, this._get_cell_value(this.rowsBuffer[j],i))){
						res.push([this.rowsBuffer[j].idd,i]);
						if (count && res.length==count) return res;
					}
						
			
		
			if (typeof (c_ind) != "undefined")
				return res;
		}
	
		return res;
	}
	
/**
*   @desc: create a search box (set selection to the row with found value) from any input
*   @type: public
*   @param: id - {string|object} input id or input html object
*   @param: column - {number} index of column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.makeSearch=function(id,column,strict){
	if (typeof(id)!="object")
		id=document.getElementById(id);
	if(!id) return;
	var self=this;
		
	if (id.tagName=='INPUT'){
		id.onkeypress=function(){
			if (this._timer) window.clearTimeout(this._timer);
			this._timer=window.setTimeout(function(){
				if (id.value=="") return;
				var z=self.findCell(id.value,column,true,strict);
				if (z.length){
					if (self._h2)
						self.openItem(z[0][0]);
					self.selectCell(self.getRowIndex(z[0][0]),(column||0))
				}
			},500);
		};
	}
	if (id.parentNode)
		id.parentNode.className+=" filter";
}
	
dhtmlXGridObject.prototype._loadSelectOptins=function(t,c){ 
		var l=this.collectValues(c);
		var v=t.value;
		t.innerHTML="";
		t.options[0]=new Option("","");
		var f=this._filter_tr?this._filter_tr[c]:null;
		for (var i=0; i<l.length; i++)
			t.options[t.options.length]=new Option(f?f(l[i]):l[i],l[i]);
		t.value=v;
}
dhtmlXGridObject.prototype.setSelectFilterLabel=function(ind,fun){ 
		if (!this._filter_tr) this._filter_tr=[];
		this._filter_tr[ind]=fun;
}

dhtmlXGridObject.prototype._loadComboOptins=function(t,c){
	if (!t.combo) return; // prevent calls from refreshFilters
	var l=this.collectValues(c);
	t.combo.clearAll();
	var opts = [["",""]];
	for (var i=0; i<l.length; i++) opts.push([l[i],l[i]]);
	t.combo.addOption(opts);
}

/**
*   @desc: refresh filtering ( can be used if data in grid changed and filters need to be updated )
*   @type: public
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.refreshFilters=function(){
        if(!this.filters) return;
	for (var i=0; i<this.filters.length; i++){
		switch(this.filters[i][0].tagName.toLowerCase()){
			case "input":
				break;
			case "select":
				this._loadSelectOptins.apply(this,this.filters[i]);
				break;
			case "div":
				this._loadComboOptins.apply(this,this.filters[i]);
				break;
		}
	}
}

dhtmlXGridObject.prototype._filters_ready=function(fl,code){
	this.attachEvent("onXLE",this.refreshFilters);
	this.attachEvent("onRowCreated",function(id,r){
		if (this._f_rowsBuffer)
			for (var i=0; i<this._f_rowsBuffer.length; i++)
				if (this._f_rowsBuffer[i].idd == id)
					return this._f_rowsBuffer[i]=r;
	})
	this.attachEvent("onClearAll",function(){ 
	    this._f_rowsBuffer=null; 
		if (!this.hdr.rows.length)
			this.filters=[];
	});
	/*
	if (window.dhtmlXCombo)
		this.attachEvent("onScroll",dhtmlXCombo.prototype.closeAll);
	*/
	this.attachEvent("onSetSizes", this._filters_resize_combo);
	this.attachEvent("onResize", this._filters_resize_combo);
	
	this._filters_ready=function(){};
}

dhtmlXGridObject.prototype._filters_resize_combo=function(){
	if (!this.filters) return;
	for (var q=0; q<this.filters.length; q++) {
		if (this.filters[q][0].combo != null) {
			this.filters[q][0].combo.setSize(Math.round(this.filters[q][0].offsetWidth*90/100));
		}
	}
	return true;
}

dhtmlXGridObject.prototype._in_header_text_filter=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_text_filter_inc=function(t,i){
	t.innerHTML="<input type='text'>";
	t.onclick=t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	this.makeFilter(t.firstChild,i);
	t.firstChild._filter=function(){ 
		if (t.firstChild.value=="") return "";
		return function(val){
			return (val.toString().toLowerCase().indexOf(t.firstChild.value.toLowerCase())==0); 
		}
	}
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_select_filter=function(t,i){
	t.innerHTML="<select></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._in_header_select_filter_strict=function(t,i){
	t.innerHTML="<select style='width:90%; font-size:8pt; font-family:Tahoma;'></select>";
	t.onclick=function(e){ (e||event).cancelBubble=true; return false; }
	this.makeFilter(t.firstChild,i);
	var combos = this.combos;
	t.firstChild._filter=function(){ 
		var value = t.firstChild.value;
		if (!value) return "";
		if (combos[i])
            value = combos[i].keys[combos[i].values._dhx_find(value)];
       	value = value.toLowerCase();
            
		return function(val){
			return (val.toString().toLowerCase()==value); 
		};
	};
	this._filters_ready();
}

dhtmlXGridObject.prototype._in_header_combo_filter=function(t,i){
	t.innerHTML="<div style='width:100%; padding-left:2px; overflow:hidden; ' class='combo'></div>";
	t.onselectstart=function(){ return (event.cancelBubble=true); }
	t.onclick=t.onmousedown=function(e){ (e||event).cancelBubble=true; return true; }
	this.makeFilter(t.firstChild,i);
}

dhtmlXGridObject.prototype._search_common=function(t, i){
	t.innerHTML="<input type='text' style='width:90%; '>";
	t.onclick= t.onmousedown = function(e){ (e||event).cancelBubble=true; return true; }
	t.onselectstart=function(){ return (event.cancelBubble=true); }
}
dhtmlXGridObject.prototype._in_header_text_search=function(t,i, strict){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i);
}
dhtmlXGridObject.prototype._in_header_text_search_strict=function(t,i){
	this._search_common(t, i);
	this.makeSearch(t.firstChild,i, true);
}

dhtmlXGridObject.prototype._in_header_numeric_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	t.firstChild._filter=function(){
		var v=this.value;
		
		var r; var op="=="; var num=parseFloat(v.replace("=","")); var num2=null;
		
		if (v){
			if (v.indexOf("..")!=-1){
				v=v.split("..");
				num=parseFloat(v[0]);
				num2=parseFloat(v[1]);
				return function(v){
					if (v>=num && v<=num2) return true;
					return false;
					}
			}
			r=v.match(/>=|<=|>|</)
			if (r) {
				op=r[0];
				num=parseFloat(v.replace(op,""));
			}
			return Function("v"," if (v "+op+" "+num+" ) return true; return false;");
		}
		return "";
	};
}

dhtmlXGridObject.prototype._in_header_master_checkbox=function(t,i,c){
	t.innerHTML=c[0]+"<input type='checkbox' />"+c[1];
	var self=this;
	t.getElementsByTagName("input")[0].onclick=function(e){
		self._build_m_order();
		var j=self._m_order?self._m_order[i]:i;
		var val=this.checked?1:0;
		self.forEachRowA(function(id){
			var c=this.cells(id,j);
			if (c.isCheckbox() && !c.isDisabled()) {
				c.setValue(val);
				c.cell.wasChanged = true;
			}
			this.callEvent("onEditCell",[1,id,j,val]);
			this.callEvent("onCheckbox", [id, j, val]);
			this.callEvent("onCheck", [id, j, val]);
		});
		(e||event).cancelBubble=true;
	}
}

dhtmlXGridObject.prototype._in_header_stat_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			summ+=isNaN(v)?0:v;
		}
		
		return this._maskArr[ii]?this._aplNF(summ,ii):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	for(var k = 0; k < cols.length;k++){
		cols[k]=parseInt(cols[k]);
	}
	var calck=function(){
		var summ=0;
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v = 1;
			for(var k = 0; k < cols.length;k++){
				v *= parseFloat(this._get_cell_value(this.rowsBuffer[j],cols[k]))
			}
			summ+=isNaN(v)?0:v;
		}
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	var track=[];
	for(var ind = 0; ind < cols.length;ind++){
		track[cols[ind]]=true;
	}
	this._stat_in_header(t,calck,track,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_max=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=-999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.max(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_min=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=999999999;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++)
			summ=Math.min(summ,parseFloat(this._get_cell_value(this.rowsBuffer[j],ii)));
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_average=function(t,i,c){
	var calck=function(){
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		
		var summ=0; var count=0;
		if (this.getRowsNum()==0) return "&nbsp;";
		for (var j=0; j<this.rowsBuffer.length; j++){
			var v=parseFloat(this._get_cell_value(this.rowsBuffer[j],ii));
			if (!isNaN(v)){
				summ+=v;
				count++;
			}
		}
		return this._maskArr[i]?this._aplNF(summ/count,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_count=function(t,i,c){
	var calck=function(){
		return this.getRowsNum();
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ( ind==i || ( i && i[ind]) ) ) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}



//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: load grid from CSV file
*   @param: path - path to file
*   @param: afterCall - function which will be called after xml loading
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVFile = function(path,afterCall){
    this.load(path,afterCall,"csv")
}

/**
*   @desc: enable mode, where ID for rows loaded from CSV autogenerated
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVAutoID = function(mode){
   this._csvAID=dhx4.s2b(mode);
}
/**
*   @desc: enable recognizing first row in CSV as header
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVHeader = function(mode){
   this._csvHdr=dhx4.s2b(mode);
}

/**
*   @desc: load grid from CSV string
*   @param: str - delimer used in CSV operations, comma by default ( only single char delimeters allowed )
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setCSVDelimiter = function(str){
   this.csv.cell=str;
}
dhtmlXGridObject.prototype._csvAID = true;

/**
*   @desc: load grid from CSV string
*   @param: str - CSV  string
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVString = function(str){
   this.parse(str,"csv")
}

/**
*   @desc: serialize to CSV string
*   @type: public
*	@param: text only - force serialization of text values ( skip HTML elements ) )
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToCSV = function(textmode){ 
    this.editStop()
    if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText || textmode)
    	this._agetm="getTitle";
    else this._agetm="getValue";

	var out=[];
	if (this._csvHdr){
		for (var j=1; j < this.hdr.rows.length; j++) {
			var a=[]; 
			for (var i=0; i<this._cCount; i++)
				if ((!this._srClmn)||(this._srClmn[i]))
					a.push(this.getColumnLabel(i,j-1));
    		out.push(this.csvParser.str(a,this.csv.cell, this.csv.row));
    	}
    }

    
    //rows collection
    var i=0;
    var leni=this.rowsBuffer.length;

   for(i; i<leni; i++){
		var temp=this._serializeRowToCVS(null,i)      	
		if (temp!="") out.push(temp);
  }

   return this.csvParser.block(out,this.csv.row);
}

/**
*   @desc: serialize TR to CSV
*   @param: r - TR or xml node (row)
*   @retruns: string - CSV representation of passed row
*   @type: private
*/
dhtmlXGridObject.prototype._serializeRowToCVS = function(r,i,start,end){
    var out = new Array();
    if (!r){
	    r=this.render_row(i)
	    if (this._fake && !this._fake.rowsAr[r.idd]) this._fake.render_row(i);
	}
    

    if (!this._csvAID)
       out[out.length]=r.idd;

	start = start||0;
	
    end = end||this._cCount;
    //cells
    var changeFl=false;
    var ind=start;
    //rowspans before block selection
    while (r.childNodes[start]._cellIndex>ind && start) start--; 
    
    
    for(var jj=start;ind<end;jj++){
    	if (!r.childNodes[jj]) break;
    	var real_ind=r.childNodes[jj]._cellIndex;
        if (((!this._srClmn)||(this._srClmn[real_ind])) && (!this._serialize_visible || !this._hrrar[real_ind])){
            var cvx=r.childNodes[jj];

            var zx=this.cells(r.idd,real_ind);
            while (ind!=real_ind){
            	ind++;
            	out.push("")
            	if (ind>=end) break;
            }
            if (ind>=end) break;
            ind++;
        /*	if (zx.getText)
        		zxVal=zx.getText();
        	else*/
            if (zx.cell)
				zxVal=zx[this._agetm]();
			else zxVal="";


		if ((this._chAttr)&&(zx.wasChanged()))
			changeFl=true;

            out[out.length]=((zxVal===null)?"":zxVal)
//#colspan:20092006{
            if ( this._ecspn && cvx.colSpan && cvx.colSpan >1 ){
                cvx=cvx.colSpan-1;
                for (var u=0; u<cvx; u++){
	                out[out.length] = "";
	                ind++;
                }
            }
//#}

 } else ind++;
    }
     if ((this._onlChAttr)&&(!changeFl)) return "";
      return this.csvParser.str(out,this.csv.cell, this.csv.row);
}

dhtmlXGridObject.prototype.toClipBoard=function(val){
    if (window.clipboardData)
      window.clipboardData.setData("Text",val);
   else
      (new Clipboard()).copy(val);

}
dhtmlXGridObject.prototype.fromClipBoard=function(){
   if (window.clipboardData)
      return window.clipboardData.getData("Text");
   else
      return (new Clipboard()).paste();
}

/**
*   @desc: copy value of cell to clipboard
*   @type: public
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.cellToClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd && cellInd !== 0)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   
   	var ed=this.cells(rowId,cellInd);
    this.toClipBoard(((ed.getLabel?ed.getLabel():ed.getValue())||"").toString());
}

/**
*   @desc: set value of cell from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateCellFromClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   	var ed=this.cells(rowId,cellInd);
    ed[ed.setImage?"setLabel":"setValue"](this.fromClipBoard());
}

/**
*   @desc: copy value of row to clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.rowToClipboard = function(rowId){
	var out="";
	if (this._mathSerialization)
		this._agetm="getMathValue";
	else if (this._strictText)
		this._agetm="getTitle";
	else 
		this._agetm="getValue";
    
  this._serialize_visible = !this._fake;

	if (rowId)
		out=this._serializeRowToCVS(this.getRowById(rowId));
	else {
   		var data = [];
		for (var i=0; i<this.selectedRows.length; i++){
			data[data.length] = this._serializeRowToCVS(this.selectedRows[i]);
			out = this.csvParser.block(data, this.csv.row);
		}
	}

  this._serialize_visible = false;
	this.toClipBoard(out);
}

/**
*   @desc: set value of row from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateRowFromClipboard = function(rowId){
	var csv=this.fromClipBoard();
	if (!csv) return;
	if (rowId)
		var r=this.getRowById(rowId);
	else
		var r=this.selectedRows[0];
	if (!r) return;
	
	var parser = this.csvParser;
	csv=parser.unblock(csv,this.csv.cell, this.csv.row)[0];
	if (!this._csvAID) csv.splice(0,1);
	for (var i=0; i<csv.length; i++){
		var ed=this.cells3(r,i);
		ed[ed.setImage?"setLabel":"setValue"](csv[i]);
	}
}

dhtmlXGridObject.prototype.csvParser={
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){
		var data = (str||"").split(row);	
		for (var i=0; i < data.length; i++)
			data[i]=(data[i]||"").split(cell);
    var last = data.length-1;
    if (data[last].length == 1 && data[last][0]=="")
      data.splice(last,1);
		return data;
	},
	str:function(data,cell,row){
		return data.join(cell);
	}
};
dhtmlXGridObject.prototype.csvExtParser={
	_quote:RegExp('"',"g"),
	_quote_esc:RegExp("\"\"","g"),
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){ 
		var out = [[]];
		var ind = 0;
		if (!str) return out;

		var quote_start = /^[ ]*"/;
		var quote_end   = /"[ ]*$/;
		var row_exp  = new RegExp(".*"+row+".*$");
		
		var data = str.split(cell);
		for (var i=0; i<data.length; i++){
			if (data[i].match(quote_start)){
				var buff = data[i].replace(quote_start, "");
				while (!data[i].match(quote_end)) {
					i++;
					buff+=data[i];
				}
				out[ind].push(buff.replace(quote_end, "").replace(this._quote_esc,'"'));
			} else if (data[i].match(row_exp)){
        var row_pos = data[i].indexOf(row);
				out[ind].push(data[i].substr(0, row_pos));
				ind++;
				out[ind] = [];
				data[i]=data[i].substr(row_pos+1); i--;
			} else {
				if (data[i] || i!=data.length-1)
					out[ind].push(data[i]);
			}
		}

    var last = out.length-1;
    if (last>0 && !out[last].length)
      out.splice(last,1);
    
		return out;	
	},
	str:function(data,cell,row){
		for (var i=0; i < data.length; i++)
			data[i] = '"'+data[i].replace(this._quote, "\"\"")+'"';
		return data.join(cell);
	}
};

/**
*   @desc: add new row from clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.addRowFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   var z=this.csvParser.unblock(csv, this.csv.cell, this.csv.row);
   for (var i=0; i<z.length; i++)
      if (z[i]){
         csv=z[i];
         if (!csv.length) continue;
         if (this._csvAID)
         	this.addRow(this.getRowsNum()+2,csv);
         else{
         	if (this.rowsAr[csv[0]])
         		csv[0]=this.uid();
         	this.addRow(csv[0],csv.slice(1));
     		}
      }
}

/**
*   @desc: copy grid in CSV to clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridToClipboard = function(){
   this.toClipBoard(this.serializeToCSV());
}

/**
*   @desc: init grid from CSV stored in clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   this.loadCSVString(csv);
}

/**
*   @desc: get grid as XML - php required
*   @param: path - path to server side code,optional
*   @type: private
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.getXLS = function(path){
   if (!this.xslform){
      this.xslform=document.createElement("FORM");
      this.xslform.action=(path||"")+"xls.php";
      this.xslform.method="post";
      this.xslform.target=(_isIE?"_blank":"");
      document.body.appendChild(this.xslform);
      var i1=document.createElement("INPUT");
      i1.type="hidden";
      i1.name="csv";
      this.xslform.appendChild(i1);
      var i2=document.createElement("INPUT");
      i2.type="hidden";
      i2.name="csv_header";
      this.xslform.appendChild(i2);
   }
      var cvs = this.serializeToCSV();
      this.xslform.childNodes[0].value = cvs;
        var cvs_header = [];
        var l = this._cCount;
        for (var i=0; i<l; i++) {
         cvs_header.push(this.getHeaderCol(i));
        }
      cvs_header = cvs_header.join(',');
      this.xslform.childNodes[1].value = cvs_header;
       this.xslform.submit();
}

/**
*   @desc: generate print friendly view
*   @type: public
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.printView = function(before,after){
	  var html="<style>TD { font-family:Arial; text-align:center; padding-left:2px;padding-right:2px; } \n td.filter input, td.filter select { display:none; }	\n  </style>";
	  var st_hr=null;
	  if (this._fake) {
	  	st_hr=[].concat(this._hrrar); 
	  	for (var i=0; i<this._fake._cCount; i++)
	  		this._hrrar[i]=null;
	  }
     var port = document.location.port;
     var hostname = document.location.hostname;
	   html+="<base  href='"+(document.location.protocol+"//"+hostname+(port?(":"+port):"")+document.location.pathname)+"'></base>";
	   if (!this.parentGrid) html+=(before||"");
       html += '<table width="100%" border="2px" cellpadding="0" cellspacing="0">';
       var row_length = Math.max(this.rowsBuffer.length,this.rowsCol.length); //paging and smartrendering
       var col_length = this._cCount;
      var width = this._printWidth();
      html += '<tr class="header_row_1">';
        for (var i=0; i<col_length; i++){
        	if (this._hrrar && this._hrrar[i]) continue;
         var hcell=this.hdr.rows[1].cells[this.hdr.rows[1]._childIndexes?this.hdr.rows[1]._childIndexes[parseInt(i)]:i];
         var colspan=(hcell.colSpan||1);
         var rowspan=(hcell.rowSpan||1);
         
         for (var j=1; j<colspan; j++)
         	width[i]+=width[j];
    	html += '<td rowspan="'+rowspan+'" width="'+width[i]+'%" style="background-color:lightgrey;" colspan="'+colspan+'">'+this.getHeaderCol(i)+'</td>';
         i+=colspan-1;
        }
      html += '</tr>';

	  	for (var i=2; i<this.hdr.rows.length; i++){
	  		if (_isIE){
	  			html+="<tr style='background-color:lightgrey' class='header_row_"+i+"'>";
	  			var cells=this.hdr.rows[i].childNodes;
	  			for (var j=0; j < cells.length; j++) 
	  				if (!this._hrrar || !this._hrrar[cells[j]._cellIndex]){
	  					html+=cells[j].outerHTML;
	  				}
	  			html+="</tr>";
	  			}
	  		else
				html+="<tr class='header_row_"+i+"' style='background-color:lightgrey'>"+(this._fake?this._fake.hdr.rows[i].innerHTML:"")+this.hdr.rows[i].innerHTML+"</tr>";
		}

       for (var i=0; i<row_length; i++) {
         html += '<tr>';
           if (this.rowsCol[i] && this.rowsCol[i]._cntr){
           	  html+=this.rowsCol[i].innerHTML.replace(/<img[^>]*>/gi,"")+'</tr>';
           	  continue;
           }
           if (this.rowsCol[i] && this.rowsCol[i].style.display=="none") continue;
           
           var row_id
           if (this.rowsCol[i])
           		row_id=this.rowsCol[i].idd;
           	else if (this.rowsBuffer[i]) 
           		row_id=this.rowsBuffer[i].idd;
           	else continue; //dyn loading 
           	
           for (var j=0; j<col_length; j++) {
           	   if (this._hrrar && this._hrrar[j]) continue;
           	   if(this.rowsAr[row_id] && this.rowsAr[row_id].tagName=="TR") {
	           	   var c=this.cells(row_id, j);
	           	   if (c._setState) var value="";
	           	   else if (c.getContent) value = c.getContent();
	           	   else if (c.getImage || c.combo) var value=c.cell.innerHTML;
	           	   else var value = c.getValue();
           	   } else 
	           	  var value=this._get_cell_value(this.rowsBuffer[i],j);
               var color = this.columnColor[j]?'background-color:'+this.columnColor[j]+';':'';
            var align = this.cellAlign[j]?'text-align:'+this.cellAlign[j]+';':'';
            var cspan =  c.getAttribute("colspan");
            html += '<td style="'+color+align+'" '+(cspan?'colSpan="'+cspan+'"':'')+'>'+(value===""?"&nbsp;":value)+'</td>';
            if (cspan) j+=cspan-1;
           }
         html += '</tr>';
         if (this.rowsCol[i] && this.rowsCol[i]._expanded){
         	 var sub=this.cells4(this.rowsCol[i]._expanded.ctrl);
         	 if (sub.getSubGrid)
         	 	html += '<tr><td colspan="'+col_length+'">'+sub.getSubGrid().printView()+'</td></tr>';
         	 else
         	 	html += '<tr><td colspan="'+col_length+'">'+this.rowsCol[i]._expanded.innerHTML+'</td></tr>';
         }
       }

	   if (this.ftr)
	  	for (var i=1; i<this.ftr.childNodes[0].rows.length; i++)
	  		html+="<tr style='background-color:lightgrey'>"+((this._fake)?this._fake.ftr.childNodes[0].rows[i].innerHTML:"")+this.ftr.childNodes[0].rows[i].innerHTML+"</tr>";
        		

      html += '</table>';
      if (this.parentGrid) return html;
      
      html+=(after||"");
      var d = window.open('', '_blank');
      d.document.write(html);
      d.document.write("<script>window.onerror=function(){return true;}</script>");
      d.document.close();
      if (this._fake) {
	  	this._hrrar=st_hr;
	  }
}
dhtmlXGridObject.prototype._printWidth=function(){
      var width = [];
      var total_width = 0;
      for (var i=0; i<this._cCount; i++) {
         var w = this.getColWidth(i);
         width.push(w);
         total_width += w;
      }
      var percent_width = [];
      var total_percent_width = 0;
      for (var i=0; i<width.length; i++) {
         var p = Math.floor((width[i]/total_width)*100);
         total_percent_width += p;
            percent_width.push(p);
      }
      percent_width[percent_width.length-1] += 100-total_percent_width;
      return percent_width;
   }

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enables block selection mode in grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableBlockSelection = function(mode)
{
	if (typeof this._bs_mode == "undefined"){
		var self = this;
		this.obj.onmousedown = function(e) {
			if (self._bs_mode) self._OnSelectionStart((e||event),this); return true;
		}
		this._CSVRowDelimiter = this.csv.row;
		this.attachEvent("onResize", function() {self._HideSelection(); return true;});
		this.attachEvent("onGridReconstructed", function() {self._HideSelection(); return true;});
		this.attachEvent("onFilterEnd",this._HideSelection);
	}
	if (mode===false){
		this._bs_mode=false;
		return this._HideSelection();
	} else this._bs_mode=true;

	if (!window.dhx4.isIPad){
		var area = this._clip_area = document.createElement("textarea");
		area.style.cssText = "position:absolute; width:1px; height:1px; overflow:hidden; color:transparent; background-color:transparent; bottom:1px; right:1px; border:none;";

		area.onkeydown=function(e){
	            e=e||event;
	            if (e.keyCode == 86 && (e.ctrlKey || e.metaKey))
					self.pasteBlockFromClipboard()
		};
	    document.body.insertBefore(this._clip_area,document.body.firstChild);

	    dhtmlxEvent(this.entBox,"click",function(){
	        if (!self.editor && self._clip_area)
	            self._clip_area.select();
	    });
	}
}
/**
*     @desc:  affect block selection, so it will copy|paste only visible text , not values behind
*	  @param: mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.forceLabelSelection = function(mode)
{
	this._strictText = dhx4.s2b(mode)
}


dhtmlXGridObject.prototype.selectBlock = function(sx, sy, ex, ey)
{
	sy = this.getRowIndex(sy);
	ey = this.getRowIndex(ey);

	myGrid._CreateSelection(sy, sx);
    myGrid._selectionArea = myGrid._RedrawSelectionPos(myGrid.cells2(sy, sx).cell, myGrid.cells2(ey, ex).cell);
    myGrid._ShowSelection();
}

dhtmlXGridObject.prototype._OnSelectionStart = function(event, obj)
{

	var self = this;
	if (event.button == 2) return;
	var src = event.srcElement || event.target;
	if (this.editor){
		if (src.tagName && (src.tagName=="INPUT" || src.tagName=="TEXTAREA"))   return;
		this.editStop();
	}
	
	self.setActive(true);
	var pos = this.getPosition(this.obj);
	var x = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));
	this._CreateSelection(x-4, y-4);

	if (src == this._selectionObj) {
		this._HideSelection();
		this._startSelectionCell = null;
	} else {
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    this._startSelectionCell = src;
	}
	
	if (this._startSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._startSelectionCell.parentNode.idd, this._startSelectionCell._cellIndex]))
			return this._startSelectionCell = null;
	}
	
	    //this._ShowSelection();
	    this.obj.onmousedown = null;
		this.obj[_isIE?"onmouseleave":"onmouseout"] = function(e){ if (self._blsTimer) window.clearTimeout(self._blsTimer); };	    
		this.obj.onmmold=this.obj.onmousemove;
		this._init_pos=[x,y];
	    this._selectionObj.onmousemove = this.obj.onmousemove = function(e) {e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;  self._OnSelectionMove(e);}
	    
	    
	    this._oldDMP=document.body.onmouseup;
	    document.body.onmouseup = function(e) {e = e||event; self._OnSelectionStop(e, this); return true; }
	this.callEvent("onBeforeBlockSelection",[]);
	document.body.onselectstart = function(){return false};//avoid text select	    
}

dhtmlXGridObject.prototype._getCellByPos = function(x,y){
	x=x;//+this.objBox.scrollLeft;
	if (this._fake)
		x+=this._fake.objBox.scrollWidth;
	y=y;//+this.objBox.scrollTop;
	var _x=0;
	for (var i=0; i < this.obj.rows.length; i++) {
		y-=this.obj.rows[i].offsetHeight;
		if (y<=0) {
			_x=this.obj.rows[i];
			break;
		}
	}
	if (!_x || !_x.idd) return null;
	for (var i=0; i < this._cCount; i++) {
		x-=this.getColWidth(i);
		if (x<=0) {
			while(true){
				if (_x._childIndexes && _x._childIndexes[i+1]==_x._childIndexes[i])
					_x=_x.previousSibling;
				else {
					return this.cells(_x.idd,i).cell;
				}
				
			}
		}
	}
	return null;
}

dhtmlXGridObject.prototype._OnSelectionMove = function(event)
{ 
	
	var self=this;
	this._ShowSelection();
	var pos = this.getPosition(this.obj);
	var X = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var Y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));

	if ((Math.abs(this._init_pos[0]-X)<5) && (Math.abs(this._init_pos[1]-Y)<5)) return this._HideSelection();
	
	var temp = this._endSelectionCell;
	if(this._startSelectionCell==null)
 		this._endSelectionCell  = this._startSelectionCell = this.getFirstParentOfType(event.srcElement || event.target,"TD");		
	else
		if (event.srcElement || event.target) {
			if ((event.srcElement || event.target).className == "dhtmlxGrid_selection")
				this._endSelectionCell=(this._getCellByPos(X,Y)||this._endSelectionCell);
			else {
				var t = this.getFirstParentOfType(event.srcElement || event.target,"TD");
				if (t.parentNode.idd) this._endSelectionCell = t;
			}
		}
		
	if (this._endSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._endSelectionCell.parentNode.idd, this._endSelectionCell._cellIndex]))
			this._endSelectionCell = temp;
	}
	
		/*
	//window.status = pos[0]+'+'+pos[1];
	var prevX = this._selectionObj.startX;
	var prevY = this._selectionObj.startY;
	var diffX = X - prevX;
	var diffY = Y - prevY;
	
	if (diffX < 0) {
        this._selectionObj.style.left = this._selectionObj.startX + diffX + 1+"px";
        diffX = 0 - diffX;
	} else {
		this._selectionObj.style.left = this._selectionObj.startX - 3+"px";
	}
	if (diffY < 0) {
		this._selectionObj.style.top = this._selectionObj.startY + diffY + 1+"px";
        diffY = 0 - diffY;
	} else {
		this._selectionObj.style.top = this._selectionObj.startY - 3+"px";
	}
    this._selectionObj.style.width = (diffX>4?diffX-4:0) + 'px';
    this._selectionObj.style.height = (diffY>4?diffY-4:0) + 'px';


/* AUTO SCROLL */
	var BottomRightX = this.objBox.scrollLeft + this.objBox.clientWidth;
	var BottomRightY = this.objBox.scrollTop + this.objBox.clientHeight;
	var TopLeftX = this.objBox.scrollLeft;
	var TopLeftY = this.objBox.scrollTop;

	var nextCall=false;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	
	if (X+20 >= BottomRightX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft+20;
		nextCall=true;
	} else if (X-20 < TopLeftX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft-20;
		nextCall=true;
	}
	if (Y+20 >= BottomRightY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop+20;
		nextCall=true;
	} else if (Y-20 < TopLeftY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop-20;
		nextCall=true;		
	}
	this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._endSelectionCell);
	

	if (nextCall){ 
		var a=event.clientX;
		var b=event.clientY;
		this._blsTimer=window.setTimeout(function(){self._OnSelectionMove({clientX:a,clientY:b})},100);
	}
	
}

dhtmlXGridObject.prototype._OnSelectionStop = function(event)
{
	var self = this;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	this.obj.onmousedown = function(e) {if (self._bs_mode)  self._OnSelectionStart((e||event), this); return true;}
	this.obj.onmousemove = this.obj.onmmold||null;
	this._selectionObj.onmousemove = null;
	document.body.onmouseup = this._oldDMP||null;
	if ( parseInt( this._selectionObj.style.width ) < 2 && parseInt( this._selectionObj.style.height ) < 2) {
		this._HideSelection();
	} else {
	    var src = this.getFirstParentOfType(event.srcElement || event.target,"TD");
	    if ((!src) || (!src.parentNode.idd)){
	    	src=this._endSelectionCell;
    		}
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    if (!src) 
	    	return this._HideSelection();
	    this._stopSelectionCell = src;
	    this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._stopSelectionCell);
		this.callEvent("onBlockSelected",[]);
	}
	document.body.onselectstart = function(){};//avoid text select
}

dhtmlXGridObject.prototype._RedrawSelectionPos = function(LeftTop, RightBottom)
{

	if (LeftTop.parentNode.grid != RightBottom.parentNode.grid)
		return this._selectionArea;

//	td._cellIndex
//
//	getRowIndex
	var pos = {};
	pos.LeftTopCol = LeftTop._cellIndex;
	pos.LeftTopRow = this.getRowIndex( LeftTop.parentNode.idd );
	pos.RightBottomCol = RightBottom._cellIndex;
	pos.RightBottomRow = this.getRowIndex( RightBottom.parentNode.idd );

	var LeftTop_width = LeftTop.offsetWidth;
	var LeftTop_height = LeftTop.offsetHeight;
	LeftTop = this.getPosition(LeftTop, this.obj);

	var RightBottom_width = RightBottom.offsetWidth;
	var RightBottom_height = RightBottom.offsetHeight;
	RightBottom = this.getPosition(RightBottom, this.obj);

    if (LeftTop[0] < RightBottom[0]) {
		var Left = LeftTop[0];
		var Right = RightBottom[0] + RightBottom_width;
    } else {
    	var foo = pos.RightBottomCol;
        pos.RightBottomCol = pos.LeftTopCol;
        pos.LeftTopCol = foo;
		var Left = RightBottom[0];
		var Right = LeftTop[0] + LeftTop_width;
    }

    if (LeftTop[1] < RightBottom[1]) {
		var Top = LeftTop[1];
		var Bottom = RightBottom[1] + RightBottom_height;
    } else {
    	var foo = pos.RightBottomRow;
        pos.RightBottomRow = pos.LeftTopRow;
        pos.LeftTopRow = foo;
		var Top = RightBottom[1];
		var Bottom = LeftTop[1] + LeftTop_height;
    }

    var Width = Right - Left;
    var Height = Bottom - Top;

	this._selectionObj.style.left = Left + 'px';
	this._selectionObj.style.top = Top + 'px';
	this._selectionObj.style.width =  Width  + 'px';
	this._selectionObj.style.height = Height + 'px';
	return pos;
}

dhtmlXGridObject.prototype._CreateSelection = function(x, y)
{
	if (this._selectionObj == null) {
		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.display = 'none';
        div.className = 'dhtmlxGrid_selection';
		this._selectionObj = div;
		this._selectionObj.onmousedown = function(e){
			e=e||event;
			if (e.button==2 || (_isMacOS&&e.ctrlKey))
				return this.parentNode.grid.callEvent("onBlockRightClick", ["BLOCK",e]);
		}
		this._selectionObj.oncontextmenu=function(e){(e||event).cancelBubble=true;return false;}
		this.objBox.appendChild(this._selectionObj);
	}
    //this._selectionObj.style.border = '1px solid #83abeb';
    this._selectionObj.style.width = '0px';
    this._selectionObj.style.height = '0px';
    //this._selectionObj.style.border = '0px';
	this._selectionObj.style.left = x + 'px';
	this._selectionObj.style.top  = y + 'px';
    this._selectionObj.startX = x;
    this._selectionObj.startY = y;
}

dhtmlXGridObject.prototype._ShowSelection = function()
{
	if (this._selectionObj)
	    this._selectionObj.style.display = '';
}

dhtmlXGridObject.prototype._HideSelection = function()
{
	
	if (this._selectionObj)
	    this._selectionObj.style.display = 'none';
    this._selectionArea = null;
    if (this._clip_area){
    	this._clip_area.value="";
    	this._clip_area.blur();
    }
}
/**
*     @desc: copy content of block selection into clipboard in csv format (delimiter as set for csv serialization)
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.copyBlockToClipboard = function()
{
	if (!this._clip_area) return;

	if ( this._selectionArea != null ) {
		var serialized = new Array();
	if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText)
    	this._agetm="getTitle";
    else this._agetm="getValue";

    this._serialize_visible = true;

		for (var i=this._selectionArea.LeftTopRow; i<=this._selectionArea.RightBottomRow; i++) {
			var data = this._serializeRowToCVS(this.rowsBuffer[i], null,  this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol+1);
			if (!this._csvAID)
				serialized[serialized.length] = data.substr( data.indexOf( this.csv.cell ) + 1 );	//remove row ID and add to array
			else
				serialized[serialized.length] = data;
		}
		serialized = serialized.join(this._CSVRowDelimiter);
		
		this._clip_area.value = serialized;
        this._clip_area.select();

	this._serialize_visible = false;
	}
}
/**
*     @desc: paste content of clipboard into block selection of grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.pasteBlockFromClipboard = function(){
	if (!this._clip_area) return;

	this._clip_area.select();
    var self = this;
    window.setTimeout(function(){
        self._pasteBlockFromClipboard();
        self=null;
    },1);
}
dhtmlXGridObject.prototype._pasteBlockFromClipboard = function()
{
	var serialized = this._clip_area.value;
	if (!serialized) return;

    if (this._selectionArea != null) {
        var startRow = this._selectionArea.LeftTopRow;
        var startCol = this._selectionArea.LeftTopCol;
    } else if (this.cell != null && !this.editor) {
        var startRow = this.getRowIndex( this.cell.parentNode.idd );
        var startCol = this.cell._cellIndex;
    } else {
        return false;
    }

	serialized = this.csvParser.unblock(serialized, this.csv.cell, this.csv.row);

    var endRow = startRow+serialized.length;
    var endCol = startCol+serialized[0].length;
    if (endCol > this._cCount)
		endCol = this._cCount;
    var k = 0;
    for (var i=startRow; i<endRow; i++) {
        var row = this.render_row(i);
        if (row==-1) continue;
        var l = 0;
        for (var j=startCol; j<endCol; j++) {
        	if (this._hrrar[j] && !this._fake){
        		endCol = Math.min(endCol+1, this._cCount);
        		continue;
        	}
        	var ed = this.cells3(row, j);
        	if (ed.isDisabled()) {
        	    l++;
        	    continue;
        	}
        	if (this._onEditUndoRedo)
        		this._onEditUndoRedo(2, row.idd, j, serialized[ k ][ l ], ed.getValue());
        	if (ed.combo){
				var comboVa = ed.combo.values;
				for(var n=0; n<comboVa.length; n++)
					if (serialized[ k ][ l ] == comboVa[n]){
						ed.setValue( ed.combo.keys[ n ]);
						comboVa=null;
						break;
					}
				if (comboVa!=null && ed.editable) ed.setValue( serialized[ k ][ l++ ] );
				else l++;
        	}else
        		ed[ ed.setImage ? "setLabel" : "setValue" ]( serialized[ k ][ l++ ] );
        	ed.cell.wasChanged=true;
        }
        this.callEvent("onRowPaste",[row.idd])
        k++;
    }
}

dhtmlXGridObject.prototype.getSelectedBlock = function() {
	// if block selection exists
	if (this._selectionArea)
		return this._selectionArea;
	else if (this.getSelectedRowId() !== null){
		// if one cell is selected
			return {
				LeftTopRow: this.getSelectedRowId(),
				LeftTopCol: this.getSelectedCellIndex(),
				RightBottomRow: this.getSelectedRowId(),
				RightBottomCol: this.getSelectedCellIndex()
			};
		} else
			return null;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable smart rendering mode
*   @type: public
*   @param: mode - true|false - enable|disable mode
*   @param: buffer - has sense only in dynamic loading mode, count of rows requrested from server by single operation, optional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSmartRendering=function(mode,buffer,reserved){
	if (arguments.length>2){
		if (buffer && !this.rowsBuffer[buffer-1]) this.rowsBuffer[buffer-1]=0;
		buffer=reserved;
	}
	this._srnd=dhx4.s2b(mode);
	this._srdh=this._srdh||20;
	this._dpref=buffer||0;
	
};
/**
*   @desc: allows to pre-render rows during scrolling, make scrolling more smooth, but with small drop in overall perfomance
*   @type: public
*   @param: buffer - count of rows, which will be prerendered
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePreRendering=function(buffer){
	this._srnd_pr=parseInt(buffer||50);
};
/**
*   @desc: force grid in dyn. srnd mode fully load itself from server side
*   @type: public
*   @param: buffer - how much rows grid can request from server side in one operation
*   @topic: 0
*/
dhtmlXGridObject.prototype.forceFullLoading=function(buffer, callback){
	for (var i=0; i<this.rowsBuffer.length; i++)
		if (!this.rowsBuffer[i]){
			var usedbuffer = buffer || (this.rowsBuffer.length-i);
			if (this.callEvent("onDynXLS",[i,usedbuffer])){
				var self=this;
				this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+usedbuffer, function(){
					window.setTimeout(function(){	self.forceFullLoading(buffer, callback); },100); 
				}, this._data_type);
			}
			return;
		}
	if (callback) callback.call(this);
};

/**
*   @desc: set height which will be used in smart rendering mode for row calculation, function need to be used if you use custom skin for grid which changes default row height
*   @type: public
   @param: {int} height - awaited height of row
*   @returns: void
*   @topic: 0
*/      
dhtmlXGridObject.prototype.setAwaitedRowHeight = function(height) {
   this._srdh=parseInt(height);
};

dhtmlXGridObject.prototype._get_view_size=function(){
	return Math.floor(parseInt(this.entBox.offsetHeight)/this._srdh)+2;
};
dhtmlXGridObject.prototype._add_filler=function(pos,len,fil,rsflag){
	if (!len) return null;
	var id="__filler__";
	var row=this._prepareRow(id);
	row.firstChild.style.width="1px";
	row.firstChild.style.borderWidth = row.firstChild.style.padding = row.firstChild.style.margin ="0px";

	for (var i=1; i<row.childNodes.length; i++)
	    row.childNodes[i].style.display='none';
 	row.firstChild.style.height=len*this._srdh+"px";
 	fil=fil||this.rowsCol[pos];
 	if (fil && fil.nextSibling) 
 		fil.parentNode.insertBefore(row,fil.nextSibling);
 	else
 		if (_isKHTML)
 			this.obj.appendChild(row);
 		else
 			this.obj.rows[0].parentNode.appendChild(row);
 			
 	this.callEvent("onAddFiller",[pos,len,row,fil,rsflag]);
 	return [pos,len,row];
};
dhtmlXGridObject.prototype._update_srnd_view=function(){
	    var min=Math.floor(this.objBox.scrollTop/this._srdh);
        var max=min+this._get_view_size();
        if (this.multiLine) {
        // Calculate the min, by Stephane Bernard
            var pxHeight = this.objBox.scrollTop;
            min = 0;
            while(pxHeight > 0) {
                pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
                min++;
            }
            // Calculate the max
            max=min+this._get_view_size();
            if (min>0) min--;
        }        
        max+=(this._srnd_pr||0);//pre-rendering
        if (max>this.rowsBuffer.length) max=this.rowsBuffer.length;

        for (var j=min; j<max; j++){ 
            if (!this.rowsCol[j]){
				var res=this._add_from_buffer(j);
				if (res==-1){
					if (this.xmlFileUrl){
						if (this._dpref && this.rowsBuffer[max-1]){
							//we have last row in sett, assuming that we in scrolling up process
							var rows_count = this._dpref?this._dpref:(max-j)
							var start_pos = Math.max(0, Math.min(j, max - this._dpref));
							this._current_load=[start_pos, max-start_pos];
						} else 
							this._current_load=[j,(this._dpref?this._dpref:(max-j))];
						if (this.callEvent("onDynXLS",this._current_load))
							this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+this._current_load[0]+"&count="+this._current_load[1], this._data_type);
					}
					return;
				} else {
	               	if (this._tgle){
	               		this._updateLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	               		this._updateParentLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	           		}
					if (j && j==(this._realfake?this._fake:this)["_r_select"]){
						this.selectCell(j, this.cell?this.cell._cellIndex:0, true);
					}
				}
            }
		}
	if (this._fake && !this._realfake && this.multiLine) 
		this._fake.objBox.scrollTop = this.objBox.scrollTop;		
}
dhtmlXGridObject.prototype._add_from_buffer=function(ind){
	    var row=this.render_row(ind);
	    if (row==-1) return -1;
	    if (row._attrs["selected"] || row._attrs["select"]){
			this.selectRow(row,false,true);
			row._attrs["selected"]=row._attrs["select"]=null;
		}
						
	    if (!this._cssSP){ 
		    if (this._cssEven && ind%2 == 0 )
				row.className=this._cssEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");
			else if (this._cssUnEven && ind%2 == 1 )
			    row.className=this._cssUnEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");				
			} else if (this._h2) {
				var x=this._h2.get[row.idd];
				row.className+=" "+((x.level%2)?(this._cssUnEven+" "+this._cssUnEven):(this._cssEven+" "+this._cssEven))+"_"+x.level+(this.rowsAr[x.id]._css||"");
			}
			

	    //now we need to get location of node
	    for (var i=0; i<this._fillers.length; i++){
	    	var f=this._fillers[i];
	    	if (f && f[0]<=ind && (f[0]+f[1])>ind ){
	    		//filler found
	    		var pos=ind-f[0];
	    		if (pos==0){
	    			//start
	    			this._insert_before(ind,row,f[2]);
	    			this._update_fillers(i,-1,1);
	    		} else if (pos == f[1]-1){
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-1,0);
	    		} else {
	    			this._fillers.push(this._add_filler(ind+1,f[1]-pos-1,f[2],1));
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-f[1]+pos,0);
	    		}
	    		return;
	    	}
	    }
}
dhtmlXGridObject.prototype._update_fillers=function(ind,right,left){
	var f=this._fillers[ind];
	f[1]=f[1]+right;
	f[0]=f[0]+left;
	if (!f[1]){
		this.callEvent("onRemoveFiller",[f[2]]);
		f[2].parentNode.removeChild(f[2]);
		this._fillers.splice(ind,1);
	} else {
		f[2].firstChild.style.height=parseFloat(f[2].firstChild.style.height)+right*this._srdh+"px";	
		this.callEvent("onUpdateFiller",[f[2]]);
	}
}
dhtmlXGridObject.prototype._insert_before=function(ind,row,fil){
	fil.parentNode.insertBefore(row,fil);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"before"]);
}
dhtmlXGridObject.prototype._insert_after=function(ind,row,fil){
	if (fil.nextSibling)
		fil.parentNode.insertBefore(row,fil.nextSibling);
	else
		fil.parentNode.appendChild(row);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"after"]);
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// validation
if (typeof(window.dhtmlxValidation) != "undefined") {
	dhtmlxValidation.trackInput = function(el,rule,callback_error,callback_correct) {
		dhtmlxEvent(el, "keyup", function(e){
			if (dhtmlxValidation._timer) {
				window.clearTimeout(dhtmlxValidation._timer);
				dhtmlxValidation._timer = null;
			}
			dhtmlxValidation._timer = window.setTimeout(function(){
				if (!dhtmlxValidation.checkInput(el,rule)){
					if (!callback_error || callback_error(el,el.value,rule)) el.className += " dhtmlx_live_validation_error";
				} else {
					el.className=el.className.replace(/[ ]*dhtmlx_live_validation_error/g,"");
					if (callback_correct) callback_correct(el, el.value, rule);
				}
			},250);
		});
	};
	dhtmlxValidation.checkInput = function(input,rule) {
		return dhtmlxValidation.checkValue(input.value,rule);
	};
	dhtmlxValidation.checkValue = function(value,rule) {
		if (typeof rule=="string") rule = rule.split(",");
		var final_res = true;
		for (var i=0; i<rule.length; i++) {
			if (!this["is"+rule[i]]) {
				alert("Incorrect validation rule: "+rule[i]);
			} else {
				final_res = final_res && this["is"+rule[i]](value);
			}
		}
		return final_res;
	};
};
// extension for the grid
dhtmlXGridObject.prototype.enableValidation=function(mode,live){
	mode=dhx4.s2b(mode);
	if (mode) this._validators = {data:[]}; else this._validators = false;
	if (arguments.length>1) this._validators._live=live;
	if (!this._validators._event) this._validators._event=this.attachEvent("onEditCell",this.validationEvent);
};
dhtmlXGridObject.prototype.setColValidators=function(vals){
	if (!this._validators) this.enableValidation(true);
	if (typeof vals == "string") vals=vals.split(this.delim);
	this._validators.data=vals;
};
dhtmlXGridObject.prototype.validationEvent=function(stage,id,ind,newval,oldval){
	var v=this._validators;
	if (!v) return true; // validators disabled
	var rule=(v.data[ind]||this.cells(id,ind).getAttribute("validate"))||"";
	
	if (stage==1 && rule) {
		var ed = this.editor||(this._fake||{}).editor;
		if (!ed) return true; //event was trigered by checkbox
		ed.cell.className=ed.cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");
		if (v._live){
			var grid=this;
			dhtmlxValidation.trackInput(ed.getInput(),rule,function(element,value,rule){
				return grid.callEvent("onLiveValidationError",[id,ind,value,element,rule]);
			}, function(element,value,rule){
				return grid.callEvent("onLiveValidationCorrect",[id,ind,value,element,rule]);
			});
		}
	}
	
	if (stage==2) this.validateCell(id,ind,rule,newval);
	
	return true;
};

dhtmlXGridObject.prototype.validateCell=function(id,ind,rule,value){
	rule=rule||(this._validators.data[ind]||this.cells(id,ind).getAttribute("validate"));
	value=value||this.cells(id,ind).getValue();
	if (!rule) return;
	var cell = this.cells(id,ind).cell;
	
	var result = true;
	if (typeof rule == "string")
		rule = rule.split(this.delim);
	
	for (var i=0; i < rule.length; i++) {
		if (!dhtmlxValidation.checkValue(value,rule[i])){
			if (this.callEvent("onValidationError",[id,ind,value,rule[i]]))
				cell.className+=" dhtmlx_validation_error";
			result = false;
		}
	}
	if (result){
		this.callEvent("onValidationCorrect",[id,ind,value,rule]);
		cell.className=cell.className.replace(/[ ]*dhtmlx_validation_error/g,"");		
	}
	return result;
};

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


function eXcell_stree(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_trees) return;
    	this._sub=this.grid._sub_trees[cell._cellIndex];
    	if (!this._sub) return;
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell._val;
	}
	this.setValue = function(val){
		this.cell._val=val;
		val = this._sub.getItemText(this.cell._val);
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		this._sub.parentObject.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.parentObject.style.top=arPos[1]+"px";
		this._sub.parentObject.style.left=arPos[0]+"px";
		this._sub.parentObject.style.position="absolute";
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		this._sub.parentObject.style.display='none';
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this._sub.getSelectedItemId());
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
	}
}
eXcell_stree.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubTree=function(tree,s_index){
		if (!this._sub_trees) 
			this._sub_trees=[];
		this._sub_trees[s_index]=[tree];
		tree.parentObject.style.display="none";
		var that=this;
		tree.parentObject.onclick = function(event) {(event || window.event).cancelBubble = true;return false;}
		tree.ev_onDblClick=null;
		tree.attachEvent("onDblClick",function(id){
			that._sub_id = id;
			that.editStop();
			return true;
		});
		tree._chRRS=true;
};
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_link(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
			var target = this.cell.firstChild.getAttribute("target")
			return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function(val){
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
			if(valsAr.length>1){
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<a "+valsAr[1]+" onclick='(_isIE?event:arguments[0]).cancelBubble = true;'>"+valsAr[0]+"</a>",valsAr);
	}
}

eXcell_link.prototype = new eXcell;
eXcell_link.prototype.getTitle=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.getAttribute("href"):"");
}
eXcell_link.prototype.getContent=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_grid(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_grids) return;
    	this._sub=this.grid._sub_grids[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return this.cell.val;
	}
	this.setValue = function(val){
		this.cell.val=val;
		
		if (this._sub.getRowById(val)) {
			val=this._sub.cells(val,this._sindex);
		if (val) val=val.getValue();
		else val="";
	 } 
		
		this.setCValue((val||"&nbsp;"),val);
		
	}
	this.edit = function(){ 
		this.val = this.cell.val;
		
		this._sub.entBox.style.display='block';
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		this._sub.entBox.style.top=arPos[1]+"px";
		this._sub.entBox.style.left=arPos[0]+"px";
		this._sub.entBox.style.position="absolute";
		this._sub.setSizes();
		
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		if (this._sub.getRowById(this.cell.val)) 
			this._sub.setSelectedRow(this.cell.val);
		this._sub.setActive(true)
		
		this.grid.editStop=a;
	}
	this.detach=function(){
		var old=this.cell.val;
		this._sub.entBox.style.display='none';
		if (this._sub.getSelectedId()===null) return false;
		this.setValue(this._sub.getSelectedId());
		this.grid.setActive(true)
		return this.cell.val!=old;
	}
}
eXcell_grid.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubGrid=function(grid,s_index,t_index){
		if (!this._sub_grids) 
			this._sub_grids=[];
		this._sub_grids[s_index]=[grid,t_index];
		grid.entBox.style.display="none";
		var that=this;

		grid.entBox.onclick = function(event) { (event || window.event).cancelBubble = true;return false; }
		grid.attachEvent("onRowSelect",function(id){
			that.editStop();
			return true;
		});
		grid._chRRS=false;
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_dhxCalendar(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated", [cal]);
			
			var sgrid = this.grid;
			cal.attachEvent("onClick",function(){
                    		this._last_operation_calendar=true;
                    		window.setTimeout(function(){sgrid.editStop()},1);
                    		return true;
                    	});
                    	
                    	var zFunc = function(e){ (e||event).cancelBubble=true; }
                    	dhtmlxEvent(cal.base, "click", zFunc);
                    	cal = null;
                }
	}
}
eXcell_dhxCalendar.prototype = new eXcell;

eXcell_dhxCalendar.prototype.edit = function() {
	
	var arPos = this.grid.getPosition(this.cell);
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0],arPos[1]+this.cell.offsetHeight);
	this.grid._grid_calendarA._last_operation_calendar = false;
	
	
	this.grid.callEvent("onCalendarShow", [this.grid._grid_calendarA, this.cell.parentNode.idd, this.cell._cellIndex]);
	//var arPos = this.grid.getPosition(this.cell);
	//var pval=this._date2str2(this.cell.val||new Date());
	//window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
	this.cell._cediton = true;
	this.val = this.cell.val;
	this._val = this.cell.innerHTML;
	// alert(this.cell.val);
	var t = this.grid._grid_calendarA.draw;
	this.grid._grid_calendarA.draw = function(){};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val||(new Date()));
	this.grid._grid_calendarA.draw = t;
	
	//this.grid._grid_calendarA.draw();
}
eXcell_dhxCalendar.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendar.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val) return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendar.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton = false; else return;
	
	if (this.grid._grid_calendarA._last_operation_calendar) {
		var z1=this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"));
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val = this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	return false;
}


eXcell_dhxCalendar.prototype.setValue = function(val) {
	
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else{
		this.cell._clearCell=false;
		this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell._clearCell=true;
		this.cell.val=new Date();
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


function eXcell_dhxCalendarA(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated",[cal]);
			
			var sgrid=this.grid;
			cal.attachEvent("onClick",function() {
				this._last_operation_calendar=true;
				window.setTimeout(function() {sgrid.editStop()},1);
				return true;
                    	});
                    	
                    	var zFunc=function(e) { (e||event).cancelBubble=true;  }
                    	dhtmlxEvent(cal.base,"click",zFunc);
                }      
	}
}
eXcell_dhxCalendarA.prototype = new eXcell;

eXcell_dhxCalendarA.prototype.edit = function() {
	var arPos = this.grid.getPosition(this.cell);
	
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0]*1+this.cell.offsetWidth,arPos[1]*1);
	this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
	this.grid._grid_calendarA._last_operation_calendar=false;
	
	this.cell._cediton=true;
	this.val=this.cell.val;
	this._val=this.cell.innerHTML;
	
	var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function() {};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val);
	this.grid._grid_calendarA.draw=t;
	
	this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF))?"INPUT":"TEXTAREA";
	
	this.obj = document.createElement(this.cell.atag);
	this.obj.style.height = (this.cell.offsetHeight-4)+"px";
	this.obj.className="dhx_combo_edit";
	this.obj.wrap = "soft";
	this.obj.style.textAlign = this.cell.align;
	this.obj.onclick = function(e) {(e||event).cancelBubble = true}
	this.obj.onmousedown = function(e) {(e||event).cancelBubble = true}
	this.obj.value = this.getValue();
	this.cell.innerHTML = "";
	this.cell.appendChild(this.obj);
	if (window.dhx4.isIE) {
		this.obj.style.overflow = "visible";
		if ((this.grid.multiLine)&&(this.obj.offsetHeight>=18)&&(this.obj.offsetHeight<40)) {
			this.obj.style.height = "36px";
			this.obj.style.overflow = "scroll";
		}
	}
	this.obj.onselectstart=function(e) {
		if (!e) e=event;
		e.cancelBubble = true;
		return true;
	};
	this.obj.focus()
	this.obj.focus()
	
}

eXcell_dhxCalendarA.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendarA.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val)
		return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendarA.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton=false; else return;
	if (this.grid._grid_calendarA._last_operation_calendar) {
		this.grid._grid_calendarA._last_operation_calendar=false;
		var z1=this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask||"%d/%m/%Y");
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val=this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	this.setValue(this.obj.value);
	var t = this.val;
	this.val = this._val;
	return (this.cell.val.valueOf()!=(t||"").valueOf());
}

eXcell_dhxCalendarA.prototype.setValue = function(val) {
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else {
		this.cell._clearCell = false;
		this.cell.val = new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell.val=new Date();
		this.cell._clearCell=true;
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: auto counter editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cntr(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
	if (!this.grid._ex_cntr_ready && !this._realfake){
		this.grid._ex_cntr_ready=true;
		if (this.grid._h2)
			this.grid.attachEvent("onOpenEn",function(id){
				this.resetCounter(cell._cellIndex);
			});
		var fix_cnt = function(){ 
			var that=this;
			window.setTimeout(function(){ 
				if (!that.resetCounter) return;
				if (that._fake && !that._realfake && cell._cellIndex<that._fake._cCount) 
					that._fake.resetCounter(cell._cellIndex); 
				else
				    that.resetCounter(cell._cellIndex);
			},1);
			return true;
		};

		this.grid.attachEvent("onBeforeSorting", fix_cnt);
		this.grid.attachEvent("onFilterEnd", fix_cnt);
	}
	
	

	this.edit = function(){}
	this.getValue = function(){
		return this.cell.innerHTML;
	}
	this.setValue = function(val){
		this.cell.style.paddingRight = "2px";
		var cell=this.cell;
		
		window.setTimeout(function(){
			if (!cell.parentNode) return;
			var val=cell.parentNode.rowIndex;
			if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
			if (val<=0) return;
			cell.innerHTML = val;
			if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
			cell=null;
		},100);
	}
}
dhtmlXGridObject.prototype.resetCounter=function(ind){
	if (this._fake && !this._realfake && ind < this._fake._cCount) this._fake.resetCounter(ind,this.currentPage);
	var i=arguments[0]||0;
	if (this.currentPage)
		i=(this.currentPage-1)*this.rowsBufferOutSize;
	for (i=0; i<this.rowsBuffer.length; i++)
		if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName == "TR" && this.rowsAr[this.rowsBuffer[i].idd])
			this.rowsAr[this.rowsBuffer[i].idd].childNodes[ind].innerHTML=i+1;
}
eXcell_cntr.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: skined checkbox editor 
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_acheck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		this.cell.obj = this;
	}catch(er){}
	this.changeState = function(){
					//nb:
					    if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled())) return;
						if(this.grid.callEvent("onEditCell",[0,this.cell.parentNode.idd,this.cell._cellIndex])!=false){
							this.val = this.getValue()
							if(this.val=="1")
								this.setValue("<checkbox state='false'>")
							else
								this.setValue("<checkbox state='true'>")
								
							this.cell.wasChanged=true;								
							//nb:
							this.grid.callEvent("onEditCell",[1,this.cell.parentNode.idd,this.cell._cellIndex]);
							this.grid.callEvent("onCheck",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);
                            this.grid.callEvent("onCheckbox",[this.cell.parentNode.idd,this.cell._cellIndex,(this.val!='1')]);

						}else{//preserve editing (not tested thoroughly for this editor)
							this.editor=null;
						}
				}
	this.getValue = function(){
						try{
							return this.cell.chstate.toString();
						}catch(er){
							return null;
						}
					}

	this.isCheckbox = function(){
						return true;
					}
	this.isChecked = function(){
						if(this.getValue()=="1")
							return true;
						else
							return false;
					}
	this.setChecked = function(fl){
	this.setValue(fl.toString())
	}
	this.detach = function(){
						return this.val!=this.getValue();
					}
    this.drawCurrentState=function(){
        if (this.cell.chstate==1)
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;'  style='cursor:pointer; font-weight:bold; text-align:center; '><span style='height:8px; width:8px; background:green; display:inline-block;'></span>&nbsp;Yes</div>";
        else
            return "<div  onclick='(new eXcell_acheck(this.parentNode)).changeState(); (arguments[0]||event).cancelBubble=true;' style='cursor:pointer;  text-align:center; '><span style='height:8px; width:8px; background:red; display:inline-block;'></span>&nbsp;No</div>";
    }
}
eXcell_acheck.prototype = new eXcell;
eXcell_acheck.prototype.setValue = function(val){
                        //val can be int
                        val=(val||"").toString();
						if(val.indexOf("1")!=-1 || val.indexOf("true")!=-1){
							val = "1";
							this.cell.chstate = "1";
						}else{
							val = "0";
							this.cell.chstate = "0"
						}
						var obj = this;
						this.setCValue(this.drawCurrentState(),this.cell.chstate);
					}

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_context(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
    
    	if (!this.grid._sub_context) return;
    	this._sub=this.grid._sub_context[cell._cellIndex];
    	if (!this._sub) return;
    	this._sindex=this._sub[1];
    	this._sub=this._sub[0];
    }
	
	this.getValue = function(){
		return _isIE?this.cell.innerText:this.cell.textContent;
	}
	this.setValue = function(val){
		this.cell._val=val;
		var item  = this._sub.itemPull[this._sub.idPrefix+this.cell._val];
		val = item?item.title:val;
		this.setCValue((val||"&nbsp;"),val);
	}
	this.edit = function(){
		var arPos = this.grid.getPosition(this.cell);//,this.grid.objBox
		
		this._sub.showContextMenu(arPos[0]+this.cell.offsetWidth,arPos[1]);
		var a=this.grid.editStop;
		this.grid.editStop=function(){};
		this.grid.editStop=a;
	}
	this.detach=function(){
		if (this.grid._sub_id != null) {
			var old=this.cell._val;
			this.setValue(this.grid._sub_id);
			this.grid._sub_id = null;
			return this.cell._val!=old;
		}
		this._sub.hideContextMenu();
	}
}
eXcell_context.prototype = new eXcell;


dhtmlXGridObject.prototype.setSubContext=function(ctx,s_index,t_index){
	var that=this;
	ctx.attachEvent("onClick",function(id,value){
		that._sub_id = id;
		that.editStop();
		ctx.hideContextMenu();
		return true;
	});
	if (!this._sub_context) 
		this._sub_context=[];
	this._sub_context[s_index]=[ctx,t_index];
	ctx.hideContextMenu();
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXGridFromTable(obj,init){
      if(typeof(obj)!='object')
         obj = document.getElementById(obj);
            var w=document.createElement("DIV");
            w.setAttribute("width",obj.getAttribute("gridWidth")||(obj.offsetWidth?(obj.offsetWidth+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["width"]:(obj.currentStyle?obj.currentStyle["width"]:0)));
            w.setAttribute("height",obj.getAttribute("gridHeight")||(obj.offsetHeight?(obj.offsetHeight+"px"):0)||(window.getComputedStyle?window.getComputedStyle(obj,null)["height"]:(obj.currentStyle?obj.currentStyle["height"]:0)));
			w.className = obj.className;
			obj.className="";
			if (obj.id) w.id = obj.id;

            var mr=obj;
            var drag=obj.getAttribute("dragAndDrop");
            mr.parentNode.insertBefore(w,mr);
            var f=mr.getAttribute("name")||("name_"+(new Date()).valueOf());

            var windowf=new dhtmlXGridObject(w);
            window[f]=windowf;

            var acs=mr.getAttribute("onbeforeinit");
            var acs2=mr.getAttribute("oninit");

			if (acs) eval(acs);

        	windowf.setImagePath(windowf.imgURL||(mr.getAttribute("imgpath")|| mr.getAttribute("image_path") ||""));
			var skin = mr.getAttribute("skin");
			if (skin) windowf.setSkin(skin);

        	if (init) init(windowf);

            var hrow=mr.rows[0];
            var za=[];
            var zb="";
            var zc="";
            var zd="";
            var ze="";

            for (var i=0; i<hrow.cells.length; i++){
                za.push(hrow.cells[i].innerHTML);
                var width=hrow.cells[i].getAttribute("width")||hrow.cells[i].offsetWidth||(window.getComputedStyle?window.getComputedStyle(hrow.cells[i],null)["width"]:(hrow.cells[i].currentStyle?hrow.cells[i].currentStyle["width"]:0));
                zb+=(zb?",":"")+(width=="*"?width:parseInt(width));
                zc+=(zc?",":"")+(hrow.cells[i].getAttribute("align")||"left");
                zd+=(zd?",":"")+(hrow.cells[i].getAttribute("type")||"ed");
                ze+=(ze?",":"")+(hrow.cells[i].getAttribute("sort")||"str");
            	var f_a=hrow.cells[i].getAttribute("format");
            	if (f_a)
            		if(hrow.cells[i].getAttribute("type").toLowerCase().indexOf("calendar")!=-1) 
            			windowf._dtmask=f_a;
            		else
            			windowf.setNumberFormat(f_a,i);
            }

        	windowf.setHeader(za);
        	windowf.setInitWidths(zb)
        	windowf.setColAlign(zc)
        	windowf.setColTypes(zd);
        	windowf.setColSorting(ze);
			if (obj.getAttribute("gridHeight")=="auto")
		    	windowf.enableAutoHeigth(true);

			if (obj.getAttribute("multiline")) windowf.enableMultiline(true);

			var lmn=mr.getAttribute("lightnavigation");
			if (lmn) windowf.enableLightMouseNavigation(lmn);

			var evr=mr.getAttribute("evenrow");
			var uevr=mr.getAttribute("unevenrow");

			if (evr||uevr) windowf.enableAlterCss(evr,uevr);
			if (drag) windowf.enableDragAndDrop(true);

            windowf.init();
            if (obj.getAttribute("split")) windowf.splitAt(obj.getAttribute("split"));

            windowf.callEvent("onXLS", []);
            //adding rows
            windowf._process_inner_html(mr,1);
            
			if (acs2) eval(acs2);            
			if (obj.parentNode && obj.parentNode.removeChild)
				obj.parentNode.removeChild(obj);

            windowf.callEvent("onXLE", []);
     return windowf;

            }
dhtmlXGridObject.prototype._process_html=function(xml){
	if (xml.tagName && xml.tagName == "TABLE") return this._process_inner_html(xml,0);
	var temp=document.createElement("DIV");
	temp.innerHTML=xml.xmlDoc.responseText;
	var mr = temp.getElementsByTagName("TABLE")[0];
	this._process_inner_html(mr,0);
}
dhtmlXGridObject.prototype._process_inner_html=function(mr,start){
	var n_l=mr.rows.length;
	for (var j=start; j<n_l; j++){
		var id=mr.rows[j].getAttribute("id")||j;
		this.rowsBuffer.push({ idd:id, data:mr.rows[j], _parser: this._process_html_row, _locator:this._get_html_data });
	}
	this.render_dataset();
	this.setSizes();
}
   
dhtmlXGridObject.prototype._process_html_row=function(r,xml){
	var cellsCol = xml.getElementsByTagName('TD');
    var strAr = [];
    
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<cellsCol.length;j++){
    	var cellVal=cellsCol[j];
        var exc=cellVal.getAttribute("type");
        if (r.childNodes[j]){
        	if (exc)
        		r.childNodes[j]._cellType=exc;
       		r.childNodes[j]._attrs=this._xml_attrs(cellsCol[j]);
   		}
       
		if (cellVal.firstChild)
		    strAr.push(cellVal.innerHTML);
		else strAr.push("");
        
        if (cellVal.colSpan>1){
            r.childNodes[j]._attrs["colspan"]=cellVal.colSpan;		
            for (var k=1; k<cellVal.colSpan; k++){
                strAr.push("")
            }
        }
		
}
	for(j<cellsCol.length; j<r.childNodes.length; j++)
        r.childNodes[j]._attrs={};

        
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_html_data=function(data,ind){
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName=="TD") ind--;
		if (ind<0) break;
		data=data.nextSibling;
	}
  return (data.firstChild?data.firstChild.data:"");
}



dhtmlxEvent(window,"load",function(){
    var z=document.getElementsByTagName("table");
    for (var a=0; a<z.length; a++)
        if (z[a].className=="dhtmlxGrid"){
            dhtmlXGridFromTable(z[a]);
            //we have found IT!
        }
});


//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_xmlA=function(xml){ 
	this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataA;
		this._process_xml_row = this._process_xml_rowA;
		return this._process_tree_xml(xml);
	}
	
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowA, _locator:this._get_xml_dataA };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xmlB=function(xml){
    
    this._parsing=true;
	var top=dhx4.ajax.xmltop(this.xml.top, xml);
	//#config_from_xml:20092006{
	this._parseHead(top);
	//#}
	var rows=dhx4.ajax.xpath(this.xml.row,top)
	var cr=parseInt(top.getAttribute("pos")||0);
	var total=parseInt(top.getAttribute("total_count")||0);
	if (total && !this.rowsBuffer[total-1]) this.rowsBuffer[total-1]=null;
	
	if (this.isTreeGrid()){
		this._get_xml_data = this._get_xml_dataB;
		this._process_xml_row = this._process_xml_rowB;
		return this._process_tree_xml(xml);
	}
			
	for (var i=0; i < rows.length; i++) {
		if (this.rowsBuffer[i+cr]) continue;
		var id=rows[i].getAttribute("id")||this.uid();
		this.rowsBuffer[i+cr]={ idd:id, data:rows[i], _parser: this._process_xml_rowB, _locator:this._get_xml_dataB };
		this.rowsAr[id]=rows[i];
		//this.callEvent("onRowCreated",[r.idd]);
	}
	this.render_dataset();
	this._parsing=false;
}

dhtmlXGridObject.prototype._process_xml_rowA=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load cell data
    for(var j=0;j<this.columnIds.length;j++){
    	var cid=this.columnIds[j];
    	var cellVal=r._attrs[cid]||"";
        if (r.childNodes[j])
       		r.childNodes[j]._attrs={};
   		
		strAr.push(cellVal);
	}
	    
    //back to common code
	this._fillRow(r,(this._c_order?this._swapColumns(strAr):strAr));
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataA=function(data,ind){
	return data.getAttribute(this.getColumnId(ind));
}

dhtmlXGridObject.prototype._process_xml_rowB=function(r,xml){
	var strAr = [];
	r._attrs=this._xml_attrs(xml);
	
	//load userdata
	if (this._ud_enabled){	
		var udCol = dhx4.ajax.xpath("./userdata",xml);
    	for (var i = udCol.length - 1; i >= 0; i--)
    		this.setUserData(udCol[i].getAttribute("name"),udCol[i].firstChild?udCol[i].firstChild.data:"");
	}
	
	//load cell data
	
	for (var jx=0; jx < xml.childNodes.length; jx++) {
		var cellVal=xml.childNodes[jx];
    	if (!cellVal.tagName) continue;
    	var j=this.getColIndexById(cellVal.tagName);
    	if (isNaN(j)) continue;
    		
        var exc=cellVal.getAttribute("type");
        if (exc)
        	r.childNodes[j]._cellType=exc;
       	r.childNodes[j]._attrs=this._xml_attrs(cellVal);
   		
		if (cellVal.getAttribute("xmlcontent"))
		{}
		else if (cellVal.firstChild)
			cellVal=cellVal.firstChild.data;
		else cellVal="";
        
		strAr[j]=cellVal;
	}
	for (var i=0; i < r.childNodes.length; i++) {
		if (!r.childNodes[i]._attrs) r.childNodes[i]._attrs={};
	};
            
    //back to common code
	this._fillRow(r,strAr);
    return r;
}
dhtmlXGridObject.prototype._get_xml_dataB=function(data,ind){
	var id=this.getColumnId(ind);
	data=data.firstChild;
	while (true){
		if (!data) return "";
		if (data.tagName==id) return (data.firstChild?data.firstChild.data:"")
		data=data.nextSibling;
	}
  return "";
}

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

   //next function switch grid between fast and normal operation modes
   //limitation - will not work for paging|smart_rendering|dynamic|split modes, most events will not be generated
   
/**
*   @desc: start fast operation mode, in such mode events are not generated, some time consuming actions applied only once, which allow to increase performance
*   @type: public
*   @topic: 0
*/   
   dhtmlXGridObject.prototype.startFastOperations   =    function(){
   		this._disF=["setSizes","callEvent","_fixAlterCss","cells4","forEachRow", "_correctMonolite"];
   		this._disA=[];
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this._disA[i]=this[this._disF[i]]; this[this._disF[i]]=function(){return true};
   		};
   		
   		this._cellCache=[];
   		this.cells4=function(cell){
   			var c=this._cellCache[cell._cellIndex]
   			if (!c){
   				c=this._cellCache[cell._cellIndex]=this._disA[3].apply(this,[cell]);
	   			c.destructor=function(){return true;}
   				c.setCValue=function(val){c.cell.innerHTML=val;}
   			}
   			
   			c.cell=cell;
   			c.combo=cell._combo||this.combos[cell._cellIndex];
   			return c;
   		}
   		
   }
/**
*   @desc: turn off fast operation mode, need to be executed to normalize view.
*   @type: public
*   @topic: 0
*/      
   dhtmlXGridObject.prototype.stopFastOperations   =    function(){
   		if (!this._disF) return;
   		for (var i = this._disF.length - 1; i >= 0; i--){
   			this[this._disF[i]]=this._disA[i];
   		};

         if (this._correctMonolite)  		
            this._correctMonolite();
   		this.setSizes();
   		this.callEvent("onGridReconstructed",[]);
   }
   
   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_number_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'num');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._in_header_string_filter=function(t,i){
	this._in_header_text_filter.call(this,t,i);
	var self = this;
	t.firstChild._filter=function(){
		var filters = self._get_filters(this.value, 'str');
		return function(value) {
			var result = filters.length > 0 ? false : true;
			for (var i = 0; i < filters.length; i++)
				result = result || filters[i](value);
			return result;
		}
	};
}


dhtmlXGridObject.prototype._get_filters=function(value, type) {
	var fs = value.split(',');
	var filters = [];
	
	for (var i = 0; i < fs.length; i++) {
		if (fs[i] == '') continue;
		var f = this['_get_' + type + '_filter'](fs[i]);
		filters.push(f);
	}
	return filters;
}


dhtmlXGridObject.prototype._get_str_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}
	
	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// not equals
	if (value.substr(0, 1) === '!') {
		var substr = value.substr(1);
		return new Function('value', 'if (value !== "' + substr + '") return true; return false;');
	}
	// contains
	if (value.substr(0, 1) === '~') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.indexOf("' + substr + '") !== -1) return true; return false;');
	}
	// ^keyword& 
	if (value.substr(0, 1) === '^' && value.substr(value.length - 1, 1) === '&') {
		value = '=' + value.substr(1, value.length - 2);
	}
	// start with
	if (value.substr(0, 1) === '^') {
		var substr = value.substr(1);
		return new Function('value', 'if (value.substr(0, ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// end with
	if (value.substr(value.length - 1, 1) === '&') {
		var substr = value.substr(0, value.length - 1);
		return new Function('value', 'if (value.substr(value.length - ' + substr.length + ') === "' + substr + '") return true; return false;');
	}
	// equals
	if (value.substr(0, 1) === '=')
		var substr = value.substr(1);
	else
		var substr = value;
	return new Function('value', 'if (value === "' + substr + '") return true; return false;');
}


dhtmlXGridObject.prototype._get_num_filter=function(value) {
	// empty, null
	if (value == 'null' || value == 'empty') {
		return new Function('value', 'if (value == null || value == "") return true; return false;');
	}

	// not empty, not null
	if (value == '!null' || value == '!empty') {
		return new Function('value', 'if (value == null || value == "") return false; return true;');
	}
	// in range
	var range = value.split('..');
	if (range.length == 2) {
		var num1 = parseFloat(range[0]);
		var num2 = parseFloat(range[1]);
		return new Function('value', 'if (value >= ' + num1 + ' && value <= ' + num2 + ') return true; return false;');
	}
	var r = value.match(/<>|>=|<=|>|<|=/);
	if (r) {
		var op = r[0];
		var num = parseFloat(value.replace(op, ""));
	} else {
		var op = '==';
		num = parseFloat(value);
	}
	if (op == '<>') op = '!=';
	if (op == '=') op = '==';
	return new Function("value"," if (value " + op + " " + num + " ) return true; return false;");
}

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.attachHeaderA=dhtmlXGridObject.prototype.attachHeader;
dhtmlXGridObject.prototype.attachHeader=function()
{
	this.attachHeaderA.apply(this,arguments);
	if (this._realfake) return true;
	this.formAutoSubmit();
	if (typeof(this.FormSubmitOnlyChanged)=="undefined")
		this.submitOnlyChanged(true);
		
	if (typeof(this._submitAR)=="undefined")
		this.submitAddedRows(true);
		
	var that=this;
	
	this._added_rows=[];
	this._deleted_rows=[];
	
	this.attachEvent("onRowAdded",function(id){ 
		that._added_rows.push(id);
		that.forEachCell(id,function(a){ a.cell.wasChanged=true; })
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		that._deleted_rows.push(id);
		return true;
	});
	
	this.attachHeader=this.attachHeaderA;
}

dhtmlXGridObject.prototype.formAutoSubmit = function()
{
	this.parentForm = this.detectParentFormPresent();
	if (this.parentForm === false) {
		return false;
	}
	if (this.formEventAttached)
		return;
    this.formInputs = new Array();
	var self = this;
	dhtmlxEvent(this.parentForm, 'submit', function() {if (self.entBox) self.parentFormOnSubmit();});
	this.formEventAttached = true;
}

dhtmlXGridObject.prototype.parentFormOnSubmit = function()
{
	this.formCreateInputCollection();
	if (!this.callEvent("onBeforeFormSubmit",[])) return false;
}

/**
*   @desc: include only changed rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyChanged = function(mode)
{
	this.FormSubmitOnlyChanged = dhx4.s2b(mode);
}

dhtmlXGridObject.prototype.submitColumns=function(names){
	if (typeof names == "string") names=names.split(this.delim);
	this._submit_cols=names;	
}

/**
*   @desc: allows to define input name which will be used for data sending, name may contain next auto-replaced elements - GRID_ID - ID of grids container, ROW_ID - ID of row, ROW_INDEX - index of row, COLUMN_ID - id of column, COLUMN_INDEX - index of column
*   @type: public
*   @param: name - input name mask
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFieldName=function(mask){
	mask=mask.replace(/\{GRID_ID\}/g,"'+a1+'");
	mask=mask.replace(/\{ROW_ID\}/g,"'+a2+'");
	mask=mask.replace(/\{ROW_INDEX\}/g,"'+this.getRowIndex(a2)+'");
	mask=mask.replace(/\{COLUMN_INDEX\}/g,"'+a3+'");
	mask=mask.replace(/\{COLUMN_ID\}/g,"'+this.getColumnId(a3)+'");
	this._input_mask=Function("a1","a2","a3","return '"+mask+"';");
}
 
   
/**
*   @desc: include serialized grid as part of form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitSerialization = function(mode)
{
	this.FormSubmitSerialization = dhx4.s2b(mode);
}

/**
*   @desc: include additional data with info about which rows was added and which deleted, enabled by default
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitAddedRows = function(mode)
{
	this._submitAR = dhx4.s2b(mode);
}




/**
*   @desc: include only selected rows in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlySelected = function(mode)
{
	this.FormSubmitOnlySelected = dhx4.s2b(mode);
}


/**
*   @desc: include only  row's IDS in form submit
*   @type: public
*   @param: mode - {boolean}  enable|disable mode
*   @topic: 0
*/
dhtmlXGridObject.prototype.submitOnlyRowID = function(mode)
{
	this.FormSubmitOnlyRowID = dhx4.s2b(mode);
}


dhtmlXGridObject.prototype.createFormInput = function(name,value){
    var input = document.createElement('input');
    input.type = 'hidden';
    if (this._input_mask && (typeof name != "string"))
    	input.name=this._input_mask.apply(this,name);
    else
    	input.name =((this.globalBox||this.entBox).id||'dhtmlXGrid')+'_'+name;
    input.value = value;
    this.parentForm.appendChild(input);
    this.formInputs.push(input);
}

dhtmlXGridObject.prototype.createFormInputRow = function(r){ 
	var id=(this.globalBox||this.entBox).id;
	for (var j=0; j<this._cCount; j++){
		var foo_cell = this.cells3(r, j);
		if (((!this.FormSubmitOnlyChanged) || foo_cell.wasChanged()) && (!this._submit_cols || this._submit_cols[j]))
			this.createFormInput(this._input_mask?[id,r.idd,j]:(r.idd+'_'+j),foo_cell.getValue());
	}
}


dhtmlXGridObject.prototype.formCreateInputCollection = function()
{
	if (this.parentForm == false) {
		return false;
	}
	for (var i=0; i<this.formInputs.length; i++) {
		this.parentForm.removeChild(this.formInputs[i]);
	}
    this.formInputs = new Array();
    
    if (this.FormSubmitSerialization){
    	this.createFormInput("serialized",this.serialize());
    } else if (this.FormSubmitOnlySelected){
    	//submit selected
    	if (this.FormSubmitOnlyRowID)
    		this.createFormInput("selected",this.getSelectedId());
    	else
    		for(var i=0;i<this.selectedRows.length;i++)
    			this.createFormInputRow(this.selectedRows[i]);
    	}
    else{
    	//submit all
    		if (this._submitAR){
    			if (this._added_rows.length)
    				this.createFormInput("rowsadded",this._added_rows.join(","));
    			if (this._deleted_rows.length)
    				this.createFormInput("rowsdeleted",this._deleted_rows.join(","));
	    		}
    		this.forEachRow(function(id){
    			 if (this.getRowById(id) !== -1)
    				this.createFormInputRow(this.rowsAr[id]);
			})
    		
    	}
}

dhtmlXGridObject.prototype.detectParentFormPresent = function()
{
	var parentForm = false;
	var parent = this.entBox;
	while(parent && parent.tagName && parent != document.body) {
		if (parent.tagName.toLowerCase() == 'form') {
			parentForm = parent;
			break;
		} else {
        	parent = parent.parentNode;
		}
	}
	return parentForm;
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.unGroup=function(){ 
	if (!this._groups) return;
	this._dndProblematic=false;
	
	delete this._groups;
	delete this._gIndex;	
	if (this._fake)	this._mirror_rowsCol();
	this.forEachRow(function(id){
		this.rowsAr[id].style.display='';
	})
	this._reset_view();
	this.callEvent("onGridReconstructed",[])
	this.callEvent("onUnGroup",[]);
}

dhtmlXGridObject.prototype._mirror_rowsCol=function(){ 
	this._fake._groups=this._groups;
	this._fake._gIndex=this._gIndex;
	this.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this.rowsCol.length; i++)
		if (!this.rowsCol[i]._cntr)
			this.rowsBuffer.push(this.rowsCol[i]);
	this._fake.rowsBuffer=dhtmlxArray(); 
	for (var i=0; i<this._fake.rowsCol.length; i++)
		if (!this._fake.rowsCol[i]._cntr)
			this._fake.rowsBuffer.push(this._fake.rowsCol[i]);
}
/**
*	@desc: group grid content by values of specified column
*	@param: ind - column index to group by
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.groupBy=function(ind,mask){
		
	if (this._groups) this.unGroup();
	this._dndProblematic=true;
	this._groups={};
	if (!mask) {
		mask=["#title"];
		for (var i=1; i<this._cCount; i++) mask.push("#cspan");
	}
	this._gmask=document.createElement("TR");
	this._gmask.origin = mask;
	var ltd,rindex=0;
	for (var i=0; i<mask.length; i++){
		if (mask[i]=="#cspan") 
			ltd.colSpan=(parseInt(ltd.colSpan)||1)+1
		else {
			ltd=document.createElement("TD");
			ltd._cellIndex=i;
			if (this._hrrar[i]) ltd.style.display="none";
			ltd.className="group_row";
			ltd.innerHTML="&nbsp;";
			if (mask[i]=="#title") this._gmask._title=rindex;
			else ltd.align=this.cellAlign[i]||"left";
			this._gmask.appendChild(ltd);
			if (mask[i].indexOf("#stat")==0){
				this._gmask._math=true;
				ltd._counter=[this["_g_"+mask[i].replace("#","")],i,rindex];
			}
			rindex++;
		}
	}
	for (var a in this._groups) this._groups[a]=this.undefined;
	this._gIndex=ind;
	
	if (this._fake &&!this._realfake){
		this._fake._groups=[];
		this._fake._gIndex=this._gIndex;
	}
	
	//keyboard commands
	this._nextRow=function(ind,dir){
		var r=this.rowsCol[ind+dir];
		if (r && ( r.style.display=="none" || r._cntr)) return this._nextRow(ind+dir,dir);
		return r;	
	}
	
	if (!this.__sortRowsBG){
		this._key_events=dhtmlx.extend({},this._key_events)
		this._key_events.k38_0_0=function(){
			if (this.editor && this.editor.combo)
				this.editor.shiftPrev();
			else{
				var rowInd = this.row.rowIndex;
				if (!rowInd) return;
				var nrow=this._nextRow(rowInd-1,-1);
				if (nrow)
	        		this.selectCell(nrow,this.cell._cellIndex,true);
			}
		}
		this._key_events.k13_1_0=this._key_events.k13_0_1=function(){};
	this._key_events.k40_0_0=function(){
		if (this.editor && this.editor.combo)
			this.editor.shiftNext();
		else{
			var rowInd = this.row.rowIndex;
			if (!rowInd) return;
			var nrow=this._nextRow(rowInd-1,1);
			if (nrow)
        		this.selectCell(nrow,this.cell._cellIndex,true);
		}
	}	
	
		this.attachEvent("onFilterStart",function(){
			if (this._groups) this._groups=this.undefined;
			return true;
		});
		this.attachEvent("onFilterEnd",function(){
			if (typeof this._gIndex != "undefined") this.groupBy(this._gIndex,this._gmask.origin);
		});
		this.sortRows_bg=this.sortRows;
		this.sortRows=function(ind,type,dir){
			if (typeof(this._groups)=="undefined") 
				return this.sortRows_bg.apply(this,arguments);

			type = type || this.fldSort[ind] || "str";
			dir = dir || "asc";
			if (this.callEvent("onBeforeSorting",[ind, type, dir])){
				if (typeof(this._groups)=="undefined") return true;
				if (ind==this._gIndex) this._sortByGroup(ind,type,dir);
				else this._sortInGroup(ind,type,dir);
				this.setSortImgState(true,ind,dir)
				if (this._fake){ 
					this._mirror_rowsCol();
					this._fake._groups=[];
					this._fake._reset_view();
				}
				this.setSortImgState(true,ind,dir);
				this.callEvent("onAfterSorting",[ind,type,dir]);
			}
			return false;
		};
		this.attachEvent("onClearAll",function(){ this.unGroup(); });
		this.attachEvent("onBeforeRowDeleted",function(id){ 
			if (!this._groups) return true;
			if (!this.rowsAr[id]) return true;
			var val=this.cells(id,this._gIndex).getValue();
			if (val==="") val=" ";
			var z=this._groups[val];
			this._dec_group(z);
			return true;
			});
		this.attachEvent("onAfterRowDeleted",function(id){ 
			this.updateGroups();
			});			
		this.attachEvent("onCheckbox",function(id,index,value){
			this.callEvent("onEditCell",[2,id,index,(value?1:0),(value?0:1)]);
		});
		this.attachEvent("onXLE",this.updateGroups);
		this.attachEvent("onColumnHidden",this.hideGroupColumn);
		this.attachEvent("onEditCell",function(stage,id,ind,val,oldval){
			if (!this._groups) return true;
			if (stage==2 && val!=oldval && ind==this._gIndex){
				if (oldval==="") oldval=" ";
				this._dec_group(this._groups[oldval]);
				var r=this.rowsAr[id];
				var i=this.rowsCol._dhx_find(r)
				var ni=this._inc_group(val);
				var n=this.rowsCol[ni];
				if (r==n) n=n.nextSibling;
					
				
				var p=r.parentNode;
				var o=r.rowIndex;
				
				p.removeChild(r);
				if (n)
					p.insertBefore(r,n);
				else
					p.appendChild(r);
				this.rowsCol._dhx_insertAt(ni,r);
				if (ni<i) i++;
				this.rowsCol._dhx_removeAt(i,r);
				this._fixAlterCss();
			} else if (stage==2 && val!=oldval) {
				this.updateGroups();
				this._updateGroupView(this._groups[this.cells(id,this._gIndex).getValue()||" "]);
				}
			return true;
			})
		this.__sortRowsBG=true;
	}
	
	
	this._groupExisting();	
	if (this._hrrar)
		for (var i=0; i<this._hrrar.length; i++)
			if (this._hrrar[i])
				this.hideGroupColumn(i,true);
	this.callEvent("onGroup",[]);
	if (this._ahgr || this._awdth) this.setSizes();
}
dhtmlXGridObject.prototype._sortInGroup=function(col,type,order){
	var b=this._groups_get();
	b.reverse();

	for (var i=0; i<b.length; i++){
		var c=b[i]._cntr._childs; var a={};
		for (var j=0; j<c.length; j++){
			var cell = this.cells3(c[j],col);
			a[c[j].idd]=cell.getDate?cell.getDate():cell.getValue();
		}
			
		this._sortCore(col,type,order,a,c);
	}
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.setSizes();
	this.callEvent("onGridReconstructed",[])
}

dhtmlXGridObject.prototype._sortByGroup=function(col,type,order){ 
	var b=this._groups_get();
	var a=[];
	for (var i=0; i<b.length; i++){
		b[i].idd="_sort_"+i;
		a["_sort_"+i]=b[i]._cntr.text;
	}
		
	this._sortCore(col,type,order,a,b);
	//add|delete|edit|ungroup
	this._groups_put(b);
	this.callEvent("onGridReconstructed",[])
	this.setSizes();
}
dhtmlXGridObject.prototype._inc_group=function(val,hidden,skip){
	if (val==="") val=" ";
	if (!this._groups[val]){ 
		this._groups[val]={text:val,row:this._addPseudoRow(),count:0,state:hidden?"plus":"minus"}; }
	var z=this._groups[val];
	//this._fixAlterCss();
	z.row._cntr=z;
		
	 
	var ind=this.rowsCol._dhx_find(z.row)+z.count+1;
	z.count++;
	
	if (!skip) {
	this._updateGroupView(z);
		this.updateGroups();
	}
	return ind;
}
dhtmlXGridObject.prototype._dec_group=function(z){
	if (!z) return;
	z.count--;
	if (z.count==0){
		z.row.parentNode.removeChild(z.row);
		this.rowsCol._dhx_removeAt(this.rowsCol._dhx_find(z.row));
		delete this._groups[z.text];
	}
	else
		this._updateGroupView(z);
	if (this._fake && !this._realfake)
		this._fake._dec_group(this._fake._groups[z.text]);
	this.updateGroups();
	return true;	
	}
dhtmlXGridObject.prototype._insertRowAt_gA=dhtmlXGridObject.prototype._insertRowAt;
dhtmlXGridObject.prototype._insertRowAt=function(r,ind,skip){
	if (typeof(this._groups)!="undefined"){
		if (this._realfake)
			var val=this._fake._bfs_cells(r.idd,this._gIndex).getValue();
		else
			if (this._bfs_cells3)
				var val=this._bfs_cells3(r,this._gIndex).getValue();
			else
				var val=this.cells3(r,this._gIndex).getValue();
			if (!val) val=" ";
			ind=this._inc_group(val,r.style.display=="none");		
	}
	var res=this._insertRowAt_gA(r,ind,skip);
	if (typeof(this._groups)!="undefined"){	
		this.expandGroup(val);
		this._updateGroupView(this._groups[val]);
		this.updateGroups();
	}
	return res;
}

dhtmlXGridObject.prototype._updateGroupView=function(z){ 
	if (this._fake && !this._realfake) return z.row.firstChild.innerHTML="&nbsp;";
	var mask = this._gmask||this._fake._gmask;
	var html="<img style='margin-bottom:-4px' src='"+this.imgURL+z.state+".gif'> ";
	if (this.customGroupFormat) html+=this.customGroupFormat(z.text,z.count);
	else html+=z.text+" ( "+z.count+" ) ";
	z.row.childNodes[mask._title].innerHTML=html;
}
dhtmlXGridObject.prototype._addPseudoRow=function(skip){
	
	var mask = this._gmask||this._fake._gmask;
	var r=mask.cloneNode(true)
	//cloneNode ignores custom attributes
	for (var i=0; i<r.childNodes.length; i++) {
		r.childNodes[i]._cellIndex=mask.childNodes[i]._cellIndex;
		if (this._realfake) r.childNodes[i].style.display="";
	}
	var that=this;
	
	r.onclick=function(e){ 
		if (!that.callEvent("onGroupClick",[this._cntr.text]))
			return;

		if (that._fake && that._realfake) 
			that._fake._switchGroupState(that._fake._groups[this._cntr.text].row); 
		else
			that._switchGroupState(this);
		(e||event).cancelBubble="true"; }
	r.ondblclick=function(e){ (e||event).cancelBubble="true"; }
	
	if (!skip){
		if (_isKHTML)
			this.obj.appendChild(r)
		else
			this.obj.firstChild.appendChild(r)
		this.rowsCol.push(r);
	}
	return r;
}

dhtmlXGridObject.prototype._groups_get=function(){
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (this.rowsCol[i]._cntr){
			this.rowsCol[i]._cntr._childs=a;
			a=[];
			b.push(this.rowsCol[i]);
		} else a.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  return b;
}

dhtmlXGridObject.prototype._groups_put=function(b){ 
	var sts = this.rowsCol.stablesort;
	this.rowsCol=new dhtmlxArray(0);
	this.rowsCol.stablesort = sts;
	
	for (var i=0; i<b.length; i++){
		var gr=b[i]._cntr;
		this.obj.firstChild.appendChild(gr.row);
		this.rowsCol.push(gr.row)
		gr.row.idd=null;
		for (var j=0; j<gr._childs.length; j++){
			this.obj.firstChild.appendChild(gr._childs[j]);
			this.rowsCol.push(gr._childs[j])
		}
		delete gr._childs;
	}
	this._temp_par.appendChild(this.obj);
}
dhtmlXGridObject.prototype._groupExisting=function(b){ 
	if (!this.getRowsNum()) return;
	var b=[];
	this._temp_par=this.obj.parentNode;
	this._temp_par.removeChild(this.obj);
	var a=[];
	
	var mlen=this.rowsCol.length;
	for (var i=0; i<mlen; i++){
		var val=this.cells4(this.rowsCol[i].childNodes[this._gIndex]).getValue();
		this.rowsCol[i].style.display = "";
		if (!val) val=" ";
		
		if (!this._groups[val]){
			this._groups[val]={text:val,row:this._addPseudoRow(true),count:0,state:"minus"};
			var z=this._groups[val];
			z.row._cntr=z;
			this._groups[val]._childs=[];
			b.push(z.row)
		}
		
		this._groups[val].count++;
		this._groups[val]._childs.push(this.rowsCol[i]);
		this.rowsCol[i].parentNode.removeChild(this.rowsCol[i]);
	}
  for (var i=0; i<b.length; i++)
 	this._updateGroupView(b[i]._cntr)
  this._groups_put(b);
  if (this._fake && !this._realfake) {
  	this._mirror_rowsCol();
  	this._fake._groups=[];
  	this._fake._reset_view();
  }
  this.callEvent("onGridReconstructed",[])
  this.updateGroups();
}

dhtmlXGridObject.prototype._switchGroupState=function(row){
	var z=row._cntr;
	if (this._fake && !this._realfake) {
		z.state=this._fake._groups[row._cntr.text].row._cntr.state;
		this._fake._switchGroupState(this._fake._groups[row._cntr.text].row)
	}
	
	var ind=this.rowsCol._dhx_find(z.row)+1;
	z.state=z.state=="minus"?"plus":"minus";
	var st=z.state=="plus"?"none":"";
	
	while(this.rowsCol[ind] && !this.rowsCol[ind]._cntr){
		this.rowsCol[ind].style.display=st;
		ind++;
	}

	this._updateGroupView(z);
	this.callEvent("onGroupStateChanged",[z.text, (z.state=="minus")]);
	this.setSizes();
}
/**
*	@desc: expand group of rows
*	@param: val - value to use to determine what group to expand (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandGroup=function(val){
	if (this._groups[val].state=="plus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: collapse group of rows
*	@param: val - value to use to determine what group to collapse (in other words this should be value common for all of them)
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseGroup=function(val){
	if (this._groups[val].state=="minus")
		this._switchGroupState(this._groups[val].row);
}
/**
*	@desc: expand all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.expandAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="plus")
			this._switchGroupState(this._groups[i].row);
}
/**
*	@desc: collapse all groups
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.collapseAllGroups=function(){
	for(var i in this._groups)
		if (this._groups[i] && this._groups[i].state=="minus")
			this._switchGroupState(this._groups[i].row);
}

dhtmlXGridObject.prototype.hideGroupColumn=function(ind,state){
	if (this._fake) return;
	var rind=-1;
	var row = this._gmask.childNodes;
	for (var i=0; i<row.length; i++)
		if (row[i]._cellIndex==ind) {
			rind = i;
			break;
	}
	if (rind == -1) return;
	for (var a in this._groups)
		this._groups[a].row.childNodes[rind].style.display=state?"none":"";
};
dhtmlXGridObject.prototype.groupStat=function(name,ind,math){
	math = this["_g_"+(math||"stat_total")];
	var summ=0; var index=0;
	this.forEachRowInGroup(name,function(id){
		summ=math(summ,this.cells(id,ind).getValue()*1,index)
		index++;
	})
	return summ;
}
dhtmlXGridObject.prototype.forEachRowInGroup=function(name,code){
	var row=this._groups[name].row.nextSibling;
	if (row){
		while (row && !row._cntr) {
			code.call(this,row.idd);
			row=row.nextSibling;
		}
	} else {
		var cs=this._groups[name]._childs;
		if (cs)
			for (var i=0; i<cs.length; i++)
				code.call(this,cs[i].idd);
	}
};
dhtmlXGridObject.prototype.updateGroups=function(){
	if (!this._gmask || !this._gmask._math || this._parsing) return;
	var r=this._gmask.childNodes;
	for (var i=0; i<r.length; i++)
		if (r[i]._counter) this._b_processing.apply(this,r[i]._counter)
}
dhtmlXGridObject.prototype._b_processing=function(a,ind,rind){
	var c=0,j=0; 
	//put editor in cache, so it can be used for custom html containers - can be moved in cells5(?)
	if (!this._ecache[this.cellType[ind]]) this.cells5({parentNode:{grid:this}},this.cellType[ind]);
	for (var i=this.rowsCol.length-1; i>=0; i--){
		if (!this.rowsCol[i]._cntr){
			c=a(c,this.cells3(this.rowsCol[i],ind).getValue()*1,j);
			j++;
		} else {
			this.cells5(this.rowsCol[i].childNodes[rind],this.cellType[ind]).setValue(c);
			j=c=0;
		}
	}
}

dhtmlXGridObject.prototype._g_stat_total=function(c,n,i){
	return c+n;
}
dhtmlXGridObject.prototype._g_stat_min=function(c,n,i){
	if (!i) c=Infinity;
	return Math.min(c,n);
}
dhtmlXGridObject.prototype._g_stat_max=function(c,n,i){
	if (!i) c=-Infinity;
	return Math.max(c,n);
}
dhtmlXGridObject.prototype._g_stat_average=function(c,n,i){
	return (c*i+n)/(i+1);
}
dhtmlXGridObject.prototype._g_stat_count=function(c,n,i){
	return ++c;
}
	
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._in_header_collapse=function(t,i,c){
	var rt=t.tagName=="TD"?t:t.parentNode;
	i=rt._cellIndexS;
	if (!this._column_groups) this._column_groups=[];
	var cols=c[1].split(":")
	var cols=c[1].split(":");
	cols = [cols.shift(), cols.join(':')];
	var count = parseInt(cols[0]); 
	t.innerHTML=c[0]+"<img src='"+this.imgURL+"minus.gif' style='padding-right:10px;height:16px'/><span style='position:relative; top:-6px;'>"+(cols[1]||"")+"<span>";
	t.style.paddingBottom='0px';
	var self = this;
	this._column_groups[i]=t.getElementsByTagName("IMG")[0];
	this._column_groups[i].onclick=function(e){
		(e||event).cancelBubble=true;
		this._cstate=!this._cstate;
		for (var j=i+1; j<(i+count); j++)
			self.setColumnHidden(j,this._cstate)
		if (this._cstate){
			if (rt.colSpan && rt.colSpan>0) {
				rt._exp_colspan=rt.colSpan;
				var delta=Math.max(1,rt.colSpan-count)
				if (!_isFF) //create additional cells to compensate colspan
				for (var z=0; z<rt.colSpan-delta; z++){
					var td=document.createElement("TD");
					if (rt.nextSibling)
						rt.parentNode.insertBefore(td,rt.nextSibling);
					else
						rt.parentNode.appendChild(td);
				}	
				rt.colSpan=delta;
			}
            self.callEvent("onColumnCollapse",[i,this._cstate]);
		} else 
			if (rt._exp_colspan){
				rt.colSpan=rt._exp_colspan;
				if (!_isFF)
				for (var z=1; z<rt._exp_colspan; z++)
					rt.parentNode.removeChild(rt.nextSibling);
                self.callEvent("onColumnCollapse",[i,this._cstate]);
			}
		this.src=self.imgURL+(this._cstate?"plus.gif":"minus.gif");
		
		if (self.sortImg.style.display!="none")
			self.setSortImgPos();		
	}	
}
dhtmlXGridObject.prototype.collapseColumns = function (ind) {
    if (!this._column_groups[ind] || this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}
dhtmlXGridObject.prototype.expandColumns = function (ind) {
    if (!this._column_groups[ind] || !this._column_groups[ind]._cstate) return;
    this._column_groups[ind].onclick({});
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable pop up menu which allows hidding/showing columns
*	@edition: Professional
*	@type: public
*/
dhtmlXGridObject.prototype.enableHeaderMenu=function(columns)
{
	if (!window.dhtmlXMenuObject)
		return dhtmlx.message("You need to include DHTMLX Menu");

	if (!this._header_menu){
		var menu = this._header_menu = new dhtmlXMenuObject();
		menu.renderAsContextMenu();

		var that=this;
		menu.attachEvent("onBeforeContextMenu", function(){
			that._showHContext(columns);
			return true;
		});
		menu.attachEvent("onClick", function(id){
			var checked = this.getCheckboxState(id);

			var row = that.hdr.rows[1];
			for (var j=0; j<row.cells.length; j++){
				var c = row.cells[j];
				if (c._cellIndexS == id){
					var len = c.colSpan || 1;
					for (var i=0; i<len; i++)
						that.setColumnHidden(id*1+i,!checked);
				}
			}
		});

		this.attachEvent("onInit",function(){
			menu.addContextZone(this.hdr);
		});
		if (this.hdr.rows.length) this.callEvent("onInit",[]);
	}
};

dhtmlXGridObject.prototype.getHeaderMenu=function(columns)
{
	return this._header_menu;
};

dhtmlXGridObject.prototype._hideHContext=function(){
	if (this._header_menu)
		this._header_menu.hide();
};

dhtmlXGridObject.prototype._showHContext=function(columns)
{
	if (typeof columns == "string")
		columns = columns.split(this.delim);
	
	var true_ind = 0;
	var j = 0;
	this._header_menu.clearAll();

	for (var i=0; i<this.hdr.rows[1].cells.length; i++){
		var c = this.hdr.rows[1].cells[i];
		if (!columns || (columns[true_ind] &&  columns[true_ind] != "false")){
			if (c.firstChild && c.firstChild.tagName=="DIV") var val=c.firstChild.innerHTML;
			else var val = c.innerHTML;
			val = val.replace(/<[^>]*>/gi,"");
			var visible = !(this.isColumnHidden(true_ind) || (this.getColWidth(true_ind)==0));
			this._header_menu.addCheckbox("child", this._header_menu.topId, j, true_ind, val, visible);
			j++;
		}
		true_ind+=(c.colSpan||1);
	}	
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_json_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
	};
	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	data = this._c_order?this._swapColumns(data.data):data.data;

	for (var i=0; i<data.length; i++)
		if (typeof data[i] == "object" && data[i] != null){
			r.childNodes[i]._attrs=data[i];
			if (data[i].type) r.childNodes[i]._cellType=data[i].type;
			data[i]=data[i].value;
		}
	this._fillRow(r, data);
	return r;
};


dhtmlXGridObject.prototype._process_js_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)
		r.childNodes[j]._attrs={};

	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	var arr = [];
	for (var i=0; i<this.columnIds.length; i++){
		arr[i] = data[this.columnIds[i]];
		if (typeof arr[i] == "object" && arr[i] != null){
			r.childNodes[i]._attrs=arr[i];
			if (arr[i].type) r.childNodes[i]._cellType=arr[i].type;
			arr[i]=arr[i].value;
		}
		if (!arr[i] && arr[i]!==0)
			arr[i]="";
	}

	this._fillRow(r, arr);
	return r;
};

dhtmlXGridObject.prototype.updateFromJSON = function(url, insert_new, del_missed, afterCall){
	if (typeof insert_new == "undefined")
		insert_new=true;
	this._refresh_mode=[
		true,
		insert_new,
		del_missed
	];
	
	this.load(url,afterCall,"json");
},
dhtmlXGridObject.prototype._refreshFromJSON = function(data){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var pid = data.parent||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = data.rows;
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.id;
			del[id]=false;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_json_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_json_row,
						_locator: this._get_json_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,pid)).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},

	dhtmlXGridObject.prototype._process_js=function(data){
		return this._process_json(data, "js");
	},

	dhtmlXGridObject.prototype._parseHeadJson=function(json){
		if (!json.head || !json.head.length) return;

		var headCol = json.head;
		var settings = json.settings;

		var awidthmet = "setInitWidths";
		var split = false;

		if (settings && settings.colwidth == "%")
			awidthmet="setInitWidthsP";
	
		if (settings && settings.splitat == "%")
			split=settings.splitat;

		//drop existing grid here, to prevent loss of initialization parameters
	    if (this.hdr.rows.length > 0) 
	    	this.clearAll(true);

		var sets = [
			[],
			[],
			[],
			[],
			[],
			[],
			[]
		];
	
		var attrs = ["value", "width", "type", "align", "sort","hidden", "id"];
		var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", 
					"", "setColumnIds"];
	
		for (var i = 0; i < headCol.length; i++)
			for (var j = 0; j < attrs.length; j++)
				sets[j].push(headCol[i][attrs[j]]);

		this.setHeader(sets[0]);
		for (var i = 0; i < calls.length; i++)
			if (calls[i])
				this[calls[i]](sets[i].join(this.delim));
	
		for (var i = 0; i < headCol.length; i++){
			var options = headCol[i].options
			if (headCol[i].options)
				if (this.cellType[i] == "clist"){
					this.registerCList(i, options);
				} else {
					var combo = this.getCombo(i);
					for (var j = 0; j < options.length; j++)
						combo.put(options[j].id, options[j].value);
				}
		}
			
	
		this.init();

        var param=sets[5].join(this.delim);
        //preserving state of hidden columns, if not specified directly
		if (this.setColHidden && param.replace(/,/g,"")!="")
			this.setColHidden(param);

		if ((split)&&(this.splitAt))
			this.splitAt(split);
	};

	dhtmlXGridObject.prototype._process_json=function(data, mode){
		this._parsing=true;
		try {
			var data = data.responseText || data;
			if (typeof data == "string"){
				eval("dhtmlx.temp="+data+";");
				data = dhtmlx.temp;
			}
		} catch(e){
				dhx4.callEvent("onLoadXMLError", ["Incorrect JSON",
					(data.xmlDoc||data),
					this
				]);
				data = {rows:[]};
		}
			
		if (this._refresh_mode) return this._refreshFromJSON(data);				

		if (data.head)
			this._parseHeadJson(data);

		var cr = parseInt(data.pos||0);
		var total = parseInt(data.total_count||0);
		
		var reset = false;
		if (total){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
			
		var userdata = mode === "js" ? data.userdata : data;
		for (var key in userdata){
			if (mode === "js" || key!="rows")
				this.setUserData("",key, userdata[key]);
		}

		if (mode == "js" && data.collections){
			for (var colkey in data.collections){
				var index = this.getColIndexById(colkey);
				var colrecs = data.collections[colkey];
				if (index !== window.undefined){
					if (this.cellType[index] == "clist"){
						colplaindata=[];
						for (var j=0; j<colrecs.length; j++)
							colplaindata.push(colrecs[j].label);
						this.registerCList(index, colplaindata);
					} else {
						var combo = this.getCombo(index);
						for (var j = 0; j < colrecs.length; j++)
							combo.put(colrecs[j].value, colrecs[j].label);
					}
				}
			}
		}
		
		if (this.isTreeGrid())
			return this._process_tree_json(data, null, null, mode);
			
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;

				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer[i+cr]={
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
				};

				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;
				var id = data.rows[i].id;
				this.rowsBuffer[i+cr]={
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
				};
	
				this.rowsAr[id]=data.rows[i];
			}
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
}

dhtmlXGridObject.prototype._get_json_data=function(data, ind){
	if (typeof data.data[ind] == "object")
		return data.data[ind].value;
	else
		return data.data[ind];
};

dhtmlXGridObject.prototype._process_tree_json=function(data,top,pid,mode){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=data;
		pid=top.parent||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	
	if (mode == "js"){
		if (top.data && !pid) 
			data = top.data;
		if (top.rows)
			top = top.rows;
		for (var i = 0; i < top.length; i++){
			var id = top[i].id;
			var row=this._h2.add(id,pid);
			row.buff={ idd:id, data:top[i], _parser: this._process_js_row, _locator:this._get_js_data };

			if (top[i].open)
			    row.state="minus";
				
			this.rowsAr[id]=row.buff;
		    this._process_tree_json(top[i],top[i],id,mode);
		}
	} else {
		if (top.rows) {
			for (var i = 0; i < top.rows.length; i++){
					var id = top.rows[i].id;
					var row=this._h2.add(id,pid);
					row.buff={ idd:id, data:top.rows[i], _parser: this._process_json_row, _locator:this._get_json_data };
					if (top.rows[i].open)
					    row.state="minus";
					
					this.rowsAr[id]=row.buff;
				    this._process_tree_json(top.rows[i],top.rows[i],id,mode);
			}
		}
	}
		
	if (main){ 
		
		if (pid!=0) this._h2.change(pid,"state","minus")
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		
		this.callEvent("onDataReady", []);
		if (pid!=0 && (this._srnd || this.pagingOn))
			this._renderSort();
		else
			this.render_dataset();
		
		
	
		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;

		if (pid!=0 && !this._srnd)
		   this.callEvent("onOpenEnd",[pid,1]);	
	}
}	


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

  /**
  *   @desc: sets marked cells support to enabled or disabled state
  *   @type: public
  *   @param: state - true or false
  */
 dhtmlXGridObject.prototype.enableMarkedCells = function(fl){
  	this.markedRowsArr = new dhtmlxArray(0);
	this.markedCellsArr = new Array(0);
	this.lastMarkedRow = null;
	this.lastMarkedColumn = null;
 	this.markedCells = true;
	this.lastMarkMethod = 0;
	if(arguments.length>0){
		if(!dhx4.s2b(fl))
			this.markedCells = false;
	}
 };
  /**
  *   @desc: occures on cell click
  *   @type: private
  *   @param: [el] - cell to click on
  *   @param: [markMethod] - 0 - simple click, 1 - shift, 2 - ctrl
  */
 dhtmlXGridObject.prototype.doMark = function(el,markMethod){ 

				var _rowId = el.parentNode.idd;
				this.setActive(true);
				if (!_rowId) return;
				this.editStop();
				this.cell=el;
				this.row=el.parentNode;
				var _cellIndex = el._cellIndex;				
				
				if(!markMethod) markMethod = 0;
				
           	    if(markMethod==0){
                    this.unmarkAll() ;	 
                }
				else if(markMethod==1){
					
					if(this.lastMarkedRow) {
						var r_start = Math.min(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						var r_end = Math.max(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						
						var c_start = Math.min(_cellIndex,this.lastMarkedColumn);
						var c_end = Math.max(_cellIndex,this.lastMarkedColumn);
					
						for(var i = r_start; i < r_end+1; i++){
							for(var j = c_start; j < c_end+1; j++){
								this.mark(this.getRowId(i),j,true);
								
							}
						}
					}
				}
				else if(markMethod==2){
					if(this.markedRowsArr._dhx_find(_rowId)!=-1){ 
						for(var ci = 0; ci < this.markedCellsArr[_rowId].length; ci++){
							if(this.markedCellsArr[_rowId][ci]==_cellIndex){
								this.mark(_rowId,_cellIndex,false);
								return true;
							}
						}
						
					}
					
				}
				
				if(!this.markedCellsArr[_rowId]) 
					this.markedCellsArr[_rowId] = new dhtmlxArray(0);
				
				if(markMethod!=1) 
					this.mark(_rowId,_cellIndex);
					
				this.moveToVisible(this.cells(_rowId,_cellIndex).cell);
				this.lastMarkedRow = _rowId;
				this.lastMarkedColumn = _cellIndex;
				this.lastMarkMethod = markMethod;
				
 }
/**
  	*   @desc: sets selection or removes selection from specified cell
    *   @param: r - row object or row index
    *   @param: cInd - cell index
    *   @param: state - true or false 
	*   @type: public
 */
dhtmlXGridObject.prototype.mark = function(rid,cindex,fl){
	if(arguments.length>2){
		if(!dhx4.s2b(fl)){
			this.cells(rid,cindex).cell.className = this.cells(rid,cindex).cell.className.replace(/cellselected/g,"");
			if(this.markedRowsArr._dhx_find(rid)!=-1){
				var ci = this.markedCellsArr[rid]._dhx_find(cindex);
				if(ci!=-1){
					this.markedCellsArr[rid]._dhx_removeAt(ci);
					if(this.markedCellsArr[rid].length==0){
						this.markedRowsArr._dhx_removeAt(this.markedRowsArr._dhx_find(rid));
					}
					this.callEvent("onCellUnMarked",[rid,cindex]);
				}
			}
			return true;
		}
	}
	this.cells(rid,cindex).cell.className+= " cellselected";
	
	if(this.markedRowsArr._dhx_find(rid)==-1) 
		this.markedRowsArr[this.markedRowsArr.length] = rid;
		
	if(!this.markedCellsArr[rid]) 
		this.markedCellsArr[rid] = new dhtmlxArray(0);
	if(this.markedCellsArr[rid]._dhx_find(cindex)==-1){
		this.markedCellsArr[rid][this.markedCellsArr[rid].length] = cindex;
		this.callEvent("onCellMarked",[rid,cindex]);
	}
	
}
/**
  	*   @desc: removes selection from all marked cell
   	*   @type: public
 */
dhtmlXGridObject.prototype.unmarkAll = function(){
	if(this.markedRowsArr){
		for(var ri = 0; ri < this.markedRowsArr.length; ri++){
			var rid = this.markedRowsArr[ri];
			if (this.rowsAr[rid])
				for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
					this.callEvent("onCellUnMarked",[rid,this.markedCellsArr[rid][ci]])
					this.cells(rid,this.markedCellsArr[rid][ci]).cell.className = this.cells(rid,this.markedCellsArr[rid][ci]).cell.className.replace(/cellselected/g,"");
				}
		} 
		this.markedRowsArr = new dhtmlxArray(0);
		this.markedCellsArr = new Array(0);
	}
	return true;
}
/**
  	*   @desc: gets marked cells
   	*   @returns: the array of marked cells	(pairs of row id and column index)
	*   @type: public
 */
dhtmlXGridObject.prototype.getMarked = function(){
	var marked = new Array();
	if(this.markedRowsArr)
	for(var ri = 0; ri < this.markedRowsArr.length; ri++){
		var rid = this.markedRowsArr[ri];
		for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
			marked[marked.length] = [rid,this.markedCellsArr[rid][ci]];
		}
	} 
	return marked;		
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: cell with support for math formulas
*	@param: cell - cell object
*	@type:  private
*   @edition: Professional
*/
function eXcell_math(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	this.edit = function(){
		this.grid.editor = new eXcell_ed(this.cell);
		this.grid.editor.fix_self=true;
		this.grid.editor.getValue=this.cell.original?(function(){ return this.cell.original}):this.getValue;
		this.grid.editor.setValue=this.setValue;
		this.grid.editor.edit();
	}
	this.isDisabled = function(){ return !this.grid._mathEdit; }
	this.setValue = function(val){
				val=this.grid._compileSCL(val,this.cell,this.fix_self);
                if (this.grid._strangeParams[this.cell._cellIndex])
    				this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).setValue(val);
                else{
                    this.setCValue(val);
    	            this.cell._clearCell=false;
	            }
    }
    this.getValue = function(){
        if (this.grid._strangeParams[this.cell._cellIndex])
			return this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).getValue();
        
        return this.cell.innerHTML;
    }
}
eXcell_math.prototype = new eXcell;

dhx4.attachEvent("onGridCreated", function(grid){
	grid._reset_math();
	grid.attachEvent("onClearAll", grid._reset_math);
	grid.attachEvent("onCellChanged",function(id,ind){
		if (this._mat_links[id]){ 
			var cell=this._mat_links[id][ind];
			if (cell){ 
				for (var i=0; i<cell.length; i++)
          if (cell[i].parentNode)
            this.cells5(cell[i]).setValue(this._calcSCL(cell[i]));
			}
		}
		if (!this._parsing && this._aggregators[ind]){
			var pid=this._h2.get[id].parent.id;
			if (pid!=0){
				var ed=this.cells(pid,ind);
				ed.setValue(this._calcSCL(ed.cell));
			}
		}
	})
	grid.attachEvent("onAfterRowDeleted",function(id,pid){ //will be called for each delete operation, may be optimized
		if (pid!=0)
			if (!this._parsing && this._aggregators.length){
				for (var ind=0; ind < this._aggregators.length; ind++) {
					if (this._aggregators[ind]){
							var ed=this.cells(pid,ind);
							ed.setValue(this._calcSCL(ed.cell));
					}
				};
			}
		return true;
	})
	grid.attachEvent("onXLE", grid._refresh_math);

});

dhtmlXGridObject.prototype._reset_math=function(){
  this._mat_links   = {};
  this._aggregators = [];
};
dhtmlXGridObject.prototype._refresh_math=function(){
  for (var i=0; i < this._aggregators.length; i++) {
    if (this._aggregators[i])
      this._h2.forEachChild(0,function(el){
        if (el.childs.length!=0){
          var ed=this.cells(el.id,i);
          ed.setValue(this._calcSCL(ed.cell));
        }
      },this);
  };
};

dhtmlXGridObject.prototype.refreshMath=function(status){
    this._mat_links = {};
    for (var i=0; i<this.getColumnsNum(); i++){
      if (this.getColType(i) == "math"){
        this.forEachRow(function(id){
          var cell = this.cells(id, i);
          cell.setValue(cell.cell.original || cell.getValue());
        });
      }
    }
};

/**
*	@desc: enable/disable serialization of math formulas
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathSerialization=function(status){
    this._mathSerialization=dhx4.s2b(status);
}
/**
*	@desc: enable/disable rounding while math calculations
*	@param: digits - set hom many digits must be rounded, set 0 for disabling
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setMathRound=function(digits){
	this._roundDl=digits;
    this._roundD=Math.pow(10,digits);
}
/**
*	@desc: enable/disable editing of math cells
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathEditing=function(status){
    this._mathEdit=dhx4.s2b(status);
}

/**
*	@desc: calculate value of math cell
*	@param: cell - math cell
*	@returns: cell value
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._calcSCL=function(cell){ 
    if (!cell._code) return this.cells5(cell).getValue();
    try{
    	dhtmlx.agrid=this;
    	var z=eval(cell._code);
    } catch(e){ return ("#SCL"); }
    if (this._roundD)
        { 
        	var pre=Math.abs(z)<1?"0":"";
         	if (z<0) pre="-"+pre;
            z=Math.round(Math.abs(z)*this._roundD).toString();
            if (z==0) return 0;
            if (this._roundDl>0){
            	var n=z.length-this._roundDl;
            	if (n<0) {
            		z=("000000000"+z).substring(9+n);
            		n=0;
            	}
            	return (pre+z.substring(0,n)+"."+z.substring(n,z.length));
            }
          return pre+z;
      }
    return z;      
}

dhtmlXGridObject.prototype._countTotal=function(row,cell){ 
	var b=0;
	var z=this._h2.get[row];
	for (var i=0; i<z.childs.length; i++){
		if (!z.childs[i].buff) return b;	// dnd of item with childs, item inserted in hierarchy but not fully processed
		if (z.childs[i].buff._parser){
      b = 0;
			this._h2.forEachChild(row,function(el){
				if (el.childs.length==0){
          var value = parseFloat(this._get_cell_value(el.buff,cell),10);
          if (value)
					 b += value;
        }
			},this)
			return b;
		}
    var value = parseFloat(this._get_cell_value(z.childs[i].buff,cell),10);
    if (value)
		  b += value;
	}
	return b;
}

/**
*	@desc: compile pseudo code to correct javascript
*	@param: code - pseudo code
*	@param: cell - math cell
*	@returns: valid js code
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._compileSCL=function(code,cell,fix){ 
		if (code === null || code === window.undefined) return code;
        code=code.toString();
        if (code.indexOf("=")!=0 || !cell.parentNode) {
        	this._reLink([],cell);
        	if (fix) cell._code = cell.original = null;
            return code;
        }
        cell.original=code;
        
        var linked=null;
        code=code.replace("=","");
        if (code.indexOf("sum")!=-1){ 
            code=code.replace("sum","(dhtmlx.agrid._countTotal('"+cell.parentNode.idd+"',"+cell._cellIndex+"))");
            if (!this._aggregators) this._aggregators=[];
            this._aggregators[cell._cellIndex]="sum";
            cell._code=code;
        	return  this._parsing?"":this._calcSCL(cell);
        }
        if (code.indexOf("[[")!=-1){
          var test = /(\[\[([^\,]*)\,([^\]]*)]\])/g;
          dhtmlx.agrid=this;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  if ($2=="-")
                      $2=cell.parentNode.idd;
                  if ($2.indexOf("#")==0)
                      $2=dhtmlx.agrid.getRowId($2.replace("#",""));
                      linked[linked.length]=[$2,$3];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+$2+"\","+$3+").getValue(),10))";
              }
          );
        }
        
        if (code.indexOf(":")!=-1){ 
          var test = /:(\w+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,dhtmlx.agrid.getColIndexById($1)];
                  return '(parseFloat(dhtmlx.agrid.cells("'+id+'",dhtmlx.agrid.getColIndexById("'+$1+'")).getValue(),10))';
              }
          );
        }
        else{
          var test = /c([0-9]+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,$1];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+id+"\","+$1+").getValue(),10))";
              }
          );
        }
        
        this._reLink(linked,cell);
        cell._code=code;
        return this._calcSCL(cell);
    }

/**
*	@desc: link math cells to it source cells
*	@param: ar - array of nodes for linking
*	@param: cell - math cell
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._reLink=function(ar,cell){
		if (!ar.length) return; // basically it would be good to clear unused math links, but it will require a symetric structure 
		for (var i=0; i<ar.length; i++){ 
			if (!this._mat_links[ar[i][0]]) this._mat_links[ar[i][0]]={};
			var t=this._mat_links[ar[i][0]];
			if (!t[ar[i][1]]) t[ar[i][1]]=[];
			t[ar[i][1]].push(cell);
		}
}

if (_isKHTML){
// replace callback support for safari.
 (function(){
   var default_replace = String.prototype.replace;
   String.prototype.replace = function(search,replace){
 // replace is not function
 if(typeof replace != "function"){
 return default_replace.apply(this,arguments)
 }
 var str = "" + this;
 var callback = replace;
 // search string is not RegExp
 if(!(search instanceof RegExp)){
 var idx = str.indexOf(search);
 return (
 idx == -1 ? str :
 default_replace.apply(str,[search,callback(search, idx, str)])
 )
 }
 var reg = search;
 var result = [];
 var lastidx = reg.lastIndex;
 var re;
 while((re = reg.exec(str)) != null){
 var idx  = re.index;
 var args = re.concat(idx, str);
 result.push(
 str.slice(lastidx,idx),
 callback.apply(null,args).toString()
 );
 if(!reg.global){
 lastidx += RegExp.lastMatch.length;
 break
 }else{
 lastidx = reg.lastIndex;
 }
 }
 result.push(str.slice(lastidx));
 return result.join("")
   }
 })();
 }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: add new column to the grid. Can be used after grid was initialized. At least one column should be in grid
*   @param: ind - index of column
*   @param: header - header content of column
*   @param: type - type of column
*   @param: width - width of column
*   @param: sort - sort type of column
*   @param: align - align of column
*   @param: valign - vertical align of column
*   @param: reserved - not used for now
*   @param: columnColor - background color of column
*   @type: public
*   @edition: Professional
*   @topic: 3
*/
dhtmlXGridObject.prototype.insertColumn=function(ind,header,type,width,sort,align,valign,reserved,columnColor){
	ind=parseInt(ind);
	if (ind>this._cCount) ind=this._cCount;
	if (!this._cMod) this._cMod=this._cCount;
	this._processAllArrays(this._cCount,ind-1,[(header||"&nbsp;"),(width||100),(type||"ed"),(align||"left"),(valign||""),(sort||"na"),(columnColor||""),"",this._cMod,(width||100)]);
	this._processAllRows("_addColInRow",ind);

	if (typeof(header)=="object")
		for (var i=1; i < this.hdr.rows.length; i++) {
			if (header[i-1]=="#rspan"){
         		var pind=i-1;
         		var found=false;
         		var pz=null;
         		while(!found){
            		var pz=this.hdr.rows[pind];
            		for (var j=0; j<pz.cells.length; j++)
               			if (pz.cells[j]._cellIndex==ind) {
                  			found=j;
                  			break;
		      		}
            		pind--;
	        	}
	        this.hdr.rows[pind+1].cells[j].rowSpan=(this.hdr.rows[pind].cells[j].rowSpan||1)+1;
			}
			else				
			this.setHeaderCol(ind,(header[i-1]||"&nbsp;"),i);
		}
	else
		this.setHeaderCol(ind,(header||"&nbsp;"));
	this.hdr.rows[0].cells[ind]
	this._cCount++;
	this._cMod++;
	this._master_row=null;
	this.setSizes();
}
/**
*   @desc: delete column
*   @param: ind - index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.deleteColumn=function(ind){
	ind=parseInt(ind);
	if (this._cCount==0) return;
	if (!this._cMod) this._cMod=this._cCount;
	if (ind>=this._cCount) return;
	this._processAllArrays(ind,this._cCount-1,[null,null,null,null,null,null,null,null,null,null,null]);
	this._processAllRows("_deleteColInRow",ind);
	this._cCount--;
	this._master_row=null;
	this.setSizes();

}

/**
*   @desc: call method for all rows in all collections
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllRows = function(method,oldInd,newInd){
	this[method](this.obj.rows[0],oldInd,newInd,0);

	var z=this.hdr.rows.length;
    for (var i=0; i<z; i++)
		this[method](this.hdr.rows[i],oldInd,newInd,i);
		
	if (this.ftr){
		var z=this.ftr.firstChild.rows.length;
	    for (var i=0; i<z; i++)
			this[method](this.ftr.firstChild.rows[i],oldInd,newInd,i);
	}

	this.forEachRow(function(id){
		if (this.rowsAr[id] && this.rowsAr[id].tagName=="TR")
			this[method](this.rowsAr[id],oldInd,newInd,-1);
	});			
	
}

/**
*   @desc: shift data in all arrays
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllArrays = function(oldInd,newInd,vals){
	var ars=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor","_hrrar","_c_order"];
	if (this.cellWidthPX.length) ars.push("cellWidthPX");
	if (this.cellWidthPC.length) ars.push("cellWidthPC");
	if (this._col_combos) ars.push("_col_combos");
    if (this._mCols) ars[ars.length]="_mCols";
    if (this.columnIds) ars[ars.length]="columnIds";
    if (this._maskArr) ars.push("_maskArr");
    if (this._drsclmW) ars.push("_drsclmW");
    if (this._RaSeCol) ars.push("_RaSeCol");
    if (this._hm_config) ars.push("_hm_config");
    if (this._drsclmn) ars.push("_drsclmn");

    if (this.clists) ars.push("clists");
    if (this._validators && this._validators.data) ars.push(this._validators.data);
    
    ars.push("combos");
    if (this._customSorts) ars.push("_customSorts");
    if (this._aggregators)  ars.push("_aggregators");
    var mode=(oldInd<=newInd);

	if (!this._c_order) {
		this._c_order=new Array();
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}

	for (var i=0; i<ars.length; i++)
		{
			var t=this[ars[i]]||ars[i];
			if (t){
				if (mode){
					var val=t[oldInd];
					for (var j=oldInd; j<newInd; j++)
						t[j]=t[j+1];
					t[newInd]=val;
				} else {
					var val=t[oldInd];
					for (var j=oldInd; j>(newInd+1); j--)
						t[j]=t[j-1];
					t[newInd+1]=val;
				}
				if (vals)
					t[newInd+(mode?0:1)]=vals[i];
			}
		}
}


/**
*   @desc: moves column of specified index to new position
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.moveColumn = function(oldInd,newInd){
	newInd--;
    oldInd=parseInt(oldInd); newInd=parseInt(newInd);
	if (newInd<oldInd) var tInd=newInd+1;
	else var tInd=newInd;
	

	if (!this.callEvent("onBeforeCMove",[oldInd,tInd]))  return false;
	if (oldInd==tInd) return;

	
	//replace data
	this.editStop();
    this._processAllRows("_moveColInRow",oldInd,newInd);
    this._processAllArrays(oldInd,newInd);

	//sorting image
	if (this.fldSorted)
		this.setSortImgPos(this.fldSorted._cellIndex);

  /*	for (var i=0; i<this.hdrLabels.length; i++)
		this._c_revers[this._c_order[i]]=i;*/
	this.callEvent("onAfterCMove",[oldInd,tInd]);
};


/**
*   @desc: swap columns in collection
*   @param: cols - collection of collumns
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._swapColumns = function(cols){
	var z=new Array();
	for (var i=0; i<this._cCount; i++){
		var n=cols[this._c_order[i]];
		if (typeof(n)=="undefined") n="";
		z[i]=n;
		}
	return z;
}

/**
*   @desc: move data in the row
*   @param: row - row object
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._moveColInRow = function(row,oldInd,newInd){


	var c=row.childNodes[oldInd];
	var ci=row.childNodes[newInd+1];
	if (!c) return;
	if (ci)
		row.insertBefore(c,ci);
	else
		row.appendChild(c);

	for (var i=0; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=i;

};
/**
*   @desc: add column in row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._addColInRow = function(row,ind,old,mod){
	var cind=ind;
	if (row._childIndexes){
		if (row._childIndexes[ind-1]==row._childIndexes[ind] || !row.childNodes[row._childIndexes[ind-1]]){
			for (var i=row._childIndexes.length; i>=ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
			row._childIndexes[ind]--;
			}
		else
		for (var i = row._childIndexes.length; i >= ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
		var cind=row._childIndexes[ind];
	}
	var c=row.childNodes[cind];
	var z=document.createElement((mod)?"TD":"TH");
	if (mod) { z._attrs={}; } //necessary for code compressor
	else z.style.width=(parseInt(this.cellWidthPX[ind])||"100")+"px";
	if (c)
		row.insertBefore(z,c);
	else
		row.appendChild(z);

	if (this.dragAndDropOff && row.idd) this.dragger.addDraggableItem(row.childNodes[cind],this);
	
	for (var i=cind+1; i<row.childNodes.length; i++){
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex+1;
	}
		
	if (row.childNodes[cind]) row.childNodes[cind]._cellIndex=row.childNodes[cind]._cellIndexS=ind;

	if (row.idd || typeof(row.idd)!="undefined"){
		this.cells3(row,ind).setValue("");
		z.align=this.cellAlign[ind];
		z.style.verticalAlign=this.cellVAlign[ind];
		z.bgColor=this.columnColor[ind];
		}
	else if (z.tagName=="TD"){
		if (!row.idd && this.forceDivInHeader) z.innerHTML="<div class='hdrcell'>&nbsp;</div>";
		else	z.innerHTML="&nbsp;";
	} 
};
/**
*   @desc: delete columns from row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._deleteColInRow = function(row,ind){
	var aind = ind; //logical index
	if (row._childIndexes) ind=row._childIndexes[ind];
	var c=row.childNodes[ind];
	if (!c) return;
	if (c.colSpan && c.colSpan>1 && c.parentNode.idd){
		var t=c.colSpan-1;
		var v=this.cells4(c).getValue();
		this.setColspan(c.parentNode.idd,c._cellIndex,1)
		if (t>1){
			var cind=c._cellIndex*1;
			this.setColspan(c.parentNode.idd,cind+1,t)
			this.cells(c.parentNode.idd,c._cellIndex*1+1).setValue(v)
			row._childIndexes.splice(cind,1)
			for (var i=cind; i < row._childIndexes.length; i++) 
				row._childIndexes[i]-=1;
				
		}
	} else if (row._childIndexes){
	    row._childIndexes.splice(aind,1);
	    for (var i=aind; i<row._childIndexes.length; i++) row._childIndexes[i]--;
	}
	if (c)
		row.removeChild(c);

	for (var i=ind; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex-1;
};


/**
*   @desc: enable move column functionality
*   @param: mode - true/false
*   @param: columns - list of true/false values, optional
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableColumnMove = function(mode,columns){
	this._mCol=dhx4.s2b(mode);
	if (typeof(columns)!="undefined")
		this._mCols=columns.split(",");
	if (!this._mmevTrue){
		dhtmlxEvent(this.hdr,"mousedown",this._startColumnMove);
		dhtmlxEvent(document.body,"mousemove",this._onColumnMove);
		dhtmlxEvent(document.body,"mouseup",this._stopColumnMove);
		this._mmevTrue=true;
	}
};

dhtmlXGridObject.prototype._startColumnMove = function(e){
	e=e||event;
	var el = e.target||e.srcElement;
//	var grid=globalActiveDHTMLGridObject;
	   	var zel=el;
	   	while(zel.tagName!="TABLE") zel=zel.parentNode;
		var grid=zel.grid;
		if (!grid) return; //somehow grid not found
		grid.setActive();
	if (!grid._mCol || e.button==2) return;
	
	el = grid.getFirstParentOfType(el,"TD")
    if(el.style.cursor!="default") return true;
	if ((grid)&&(!grid._colInMove)){
		grid.resized = null;
		if ((!grid._mCols)||(grid._mCols[el._cellIndex]=="true"))
	    	grid._colInMove=el._cellIndex+1;
	}
	grid._colInMovePos = {
		x: e.clientX, y: e.clientY
	};
	return true;
};
dhtmlXGridObject.prototype._onColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		var diff = Math.max(
			Math.abs(e.clientX - grid._colInMovePos.x),
			Math.abs(e.clientY - grid._colInMovePos.y)
		);
		if (diff < 20) return;


		if (grid._hideHContext) grid._hideHContext();
    	if (typeof(grid._colInMove)!="object"){
        	var z=document.createElement("DIV");
			z._aIndex=(grid._colInMove-1);
			z._bIndex=null;
			z.innerHTML=grid.getHeaderCol(z._aIndex);
			z.className="dhx_dragColDiv";
			z.style.position="absolute";
			document.body.appendChild(z);
            grid._colInMove=z;
		}
		
		var cor=[];
		cor[0]=(document.body.scrollLeft||document.documentElement.scrollLeft);
		cor[1]=(document.body.scrollTop||document.documentElement.scrollTop);
		
		
		grid._colInMove.style.left=e.clientX+cor[0]+8+"px";
		grid._colInMove.style.top=e.clientY+cor[1]+8+"px";
		
        var el = e.target||e.srcElement;
		while ((el)&&(typeof(el._cellIndexS)=="undefined"))
			el=el.parentNode;

		if (grid._colInMove._oldHe){
			grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove._bIndex=null;
			}
		if (el) {
			if (grid.hdr.rows[1]._childIndexes)
				var he=grid.hdr.rows[1].cells[grid.hdr.rows[1]._childIndexes[el._cellIndexS]];
			else
				var he=grid.hdr.rows[1].cells[el._cellIndexS];
			var z=e.clientX-(dhx4.absLeft(he)-grid.hdrBox.scrollLeft);
            if (z/he.offsetWidth>0.5){
				he.className+=" columnTargetR";
				grid._colInMove._bIndex=el._cellIndexS;
				}
			else {
				he.className+=" columnTargetL";
				grid._colInMove._bIndex=el._cellIndexS-1;
			}
			if (he.offsetLeft<(grid.objBox.scrollLeft+20))
				grid.objBox.scrollLeft=Math.max(0,he.offsetLeft-20);

			if ((he.offsetLeft+he.offsetWidth-grid.objBox.scrollLeft)>(grid.objBox.offsetWidth-20))
				grid.objBox.scrollLeft=Math.min(grid.objBox.scrollLeft+he.offsetWidth+20,grid.objBox.scrollWidth-grid.objBox.offsetWidth);	
				
            grid._colInMove._oldHe=he;
		}
		//prevent selection, or other similar reactions while column draged
		e.cancelBubble = true;  
        return false;  
	}
	return true;
};
dhtmlXGridObject.prototype._stopColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (typeof(grid._colInMove)=="object"){
			grid._colInMove.parentNode.removeChild(grid._colInMove);
			if (grid._colInMove._bIndex!=null)
				grid.moveColumn(grid._colInMove._aIndex,grid._colInMove._bIndex+1);

			if (grid._colInMove._oldHe)
				grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove.grid=null;
			grid.resized = true;
			}
        grid._colInMove=0;
	}
	return true;
};



//(c)dhtmlx ltd. www.dhtmlx.com



/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.mouseOverHeader=function(func){
		var self=this;
		dhtmlxEvent(this.hdr,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
dhtmlXGridObject.prototype.mouseOver=function(func){
		var self=this;	
		dhtmlxEvent(this.obj,"mousemove",function(e){
				e=e||window.event;
				var el=e.target||e.srcElement;
            	if(el.tagName!="TD")
                	el = self.getFirstParentOfType(el,"TD")				
                if (el && (typeof(el._cellIndex)!="undefined"))
					func(el.parentNode.rowIndex,el._cellIndex);
		});
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*  @desc: enable smart paging mode
*  @type: public
*  @param: fl - true|false - enable|disable mode
*  @param: pageSize - count of rows per page
*  @param: pagesInGrp - count of visible page selectors
*  @param: parentObj - ID or container which will be used for showing paging controls
*  @param: showRecInfo - true|false - enable|disable showing of additional info about paging state
*  @param: recInfoParentObj - ID or container which will be used for showing paging state
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.enablePaging = function(fl,pageSize,pagesInGrp,parentObj,showRecInfo,recInfoParentObj){
	this._pgn_parentObj = typeof(parentObj)=="string" ? document.getElementById(parentObj) : parentObj;
	this._pgn_recInfoParentObj = typeof(recInfoParentObj)=="string" ? document.getElementById(recInfoParentObj) : recInfoParentObj;
	
	this.pagingOn = fl;
	this.showRecInfo = showRecInfo;
	this.rowsBufferOutSize = parseInt(pageSize);
	this.currentPage = 1;
	this.pagesInGroup = parseInt(pagesInGrp);
	this._init_pgn_events()
	this.setPagingSkin("default");
}
/**
*  @desc: allow to configure settings of dynamical paging
*  @type: public
*  @param: filePath - path which will be used for requesting data ( parth from load command used by default )
*  @param: buffer -  count of rows requrested from server by single operation, optional
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.setXMLAutoLoading = function(filePath,bufferSize){
	this.xmlFileUrl = filePath;
	this._dpref = bufferSize;
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: ind - correction ( -1,1,2  etc) to current active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePageRelative = function(ind){ 
	this.changePage(this.currentPage+ind);
}
/**
*  @desc: change current page in grid
*  @type: public
*  @param: pageNum -  new active page
*  @edition: Professional
*  @topic: 0
*/
dhtmlXGridObject.prototype.changePage = function(pageNum){ 
	if (arguments.length==0) pageNum=this.currentPage||0;
	pageNum=parseInt(pageNum);
	pageNum=Math.max(1,Math.min(pageNum,Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)));
	
	if(!this.callEvent("onBeforePageChanged",[this.currentPage,pageNum]))
		return;
	
	this.currentPage = parseInt(pageNum);
	this._reset_view();
	this._fixAlterCss();			
	this.callEvent("onPageChanged",this.getStateOfView());
}
/**
*  @desc: allows to set custom paging skin
*  @param: name - skin name (default,toolbar,bricks)
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingSkin = function(name){
	this._pgn_skin=this["_pgn_"+name];
	if (name=="toolbar") this._pgn_skin_tlb=arguments[1];
}
/**
*  @desc: allows to set paging templates for default skin
*  @param: a - template for zone A
*  @param: b - template for zone B
*  @type:  public
*/
dhtmlXGridObject.prototype.setPagingTemplates = function(a,b){
	this._pgn_templateA=this._pgn_template_compile(a);
	this._pgn_templateB=this._pgn_template_compile(b);
	this._page_skin_update();
}
dhtmlXGridObject.prototype._page_skin_update = function(name){
	if (!this.pagesInGroup) this.pagesInGroup=Math.ceil(Math.min(5,this.rowsBuffer.length/this.rowsBufferOutSize));
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	if (totalPages && totalPages<this.currentPage)
		return this.changePage(totalPages);
	if (this.pagingOn && this._pgn_skin) this._pgn_skin.apply(this,this.getStateOfView());
}
dhtmlXGridObject.prototype._init_pgn_events = function(name){
	this.attachEvent("onXLE",this._page_skin_update)
	this.attachEvent("onClearAll",this._page_skin_update)
	this.attachEvent("onPageChanged",this._page_skin_update)
	this.attachEvent("onGridReconstructed",this._page_skin_update)
	
	this._init_pgn_events=function(){};
}

// default paging
dhtmlXGridObject.prototype._pgn_default=function(page,start,end){
	if (!this.pagingBlock){
		this.pagingBlock = document.createElement("DIV");
		this.pagingBlock.className = "pagingBlock";
		this.recordInfoBlock = document.createElement("SPAN");
		this.recordInfoBlock.className = "recordsInfoBlock";
		if (!this._pgn_parentObj) return;
		this._pgn_parentObj.appendChild(this.pagingBlock)
		if(this._pgn_recInfoParentObj && this.showRecInfo)
			this._pgn_recInfoParentObj.appendChild(this.recordInfoBlock)
		
		//this._pgn_template="{prev:} {current:-1},{current},{current:+1} {next:>}"
		if (!this._pgn_templateA){
			this._pgn_templateA=this._pgn_template_compile("[prevpages:&lt;:&nbsp;] [currentpages:,&nbsp;] [nextpages:&gt;:&nbsp;]");
			this._pgn_templateB=this._pgn_template_compile("Results <b>[from]-[to]</b> of <b>[total]</b>");
		}
	}
	
	var details=this.getStateOfView();
	this.pagingBlock.innerHTML = this._pgn_templateA.apply(this,details);
	this.recordInfoBlock.innerHTML = this._pgn_templateB.apply(this,details);
	this._pgn_template_active(this.pagingBlock);
	this._pgn_template_active(this.recordInfoBlock);
	
	this.callEvent("onPaging",[]);
}

dhtmlXGridObject.prototype._pgn_block=function(sep){ 
	var start=Math.floor((this.currentPage-1)/this.pagesInGroup)*this.pagesInGroup;
	var max=Math.min(Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize),start+this.pagesInGroup);
	var str=[];
	for (var i=start+1; i<=max; i++)
		if (i==this.currentPage)
		str.push("<a class='dhx_not_active'><b>"+i+"</b></a>");
	else
		str.push("<a onclick='this.grid.changePage("+i+"); return false;'>"+i+"</a>");
	return str.join(sep);
}
dhtmlXGridObject.prototype._pgn_link=function(mode,ac,ds){
	if (mode=="prevpages" || mode=="prev"){
		if (this.currentPage==1) return ds;
		return '<a onclick=\'this.grid.changePageRelative(-1*'+(mode=="prev"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="nextpages" || mode=="next"){
		if (this.rowsBuffer.length/this.rowsBufferOutSize <= this.currentPage ) return ds;
		if (this.rowsBuffer.length/(this.rowsBufferOutSize*(mode=="next"?'1':this.pagesInGroup)) <= 1 ) return ds;
		return '<a onclick=\'this.grid.changePageRelative('+(mode=="next"?'1':'this.grid.pagesInGroup')+'); return false;\'>'+ac+'</a>'
	}
	
	if (mode=="current"){
		var i=this.currentPage+(ac?parseInt(ac):0);
		if (i<1 || Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize) < i ) return ds;
		return '<a '+(i==this.currentPage?"class='dhx_active_page_link' ":"")+'onclick=\'this.grid.changePage('+i+'); return false;\'>'+i+'</a>'
	}
	return ac;
}

dhtmlXGridObject.prototype._pgn_template_active=function(block){
	var tags=block.getElementsByTagName("A");
	if (tags)
	for (var i=0; i < tags.length; i++) {
		tags[i].grid=this;
	};
}
dhtmlXGridObject.prototype._pgn_template_compile=function(template){
	/*
	[prev],[next]
	[currentpages]
	[from],[to],[total]
	*/
	template=template.replace(/\[([^\]]*)\]/g,function(a,b){
			b=b.split(":");
			switch (b[0]){
			case "from": 
				return '"+(arguments[1]*1+(arguments[2]*1?1:0))+"';
			case "total":
				return '"+arguments[3]+"';
			case "to":
				return '"+arguments[2]+"';
			case "current":
			case "prev":
			case "next":
			case "prevpages":
			case "nextpages":
				return '"+this._pgn_link(\''+b[0]+'\',\''+b[1]+'\',\''+b[2]+'\')+"'
			case "currentpages":
				return '"+this._pgn_block(\''+b[1]+'\')+"'
			}
			//do it here
	})
	return new Function('return "'+template+'";')
}

dhtmlXGridObject.prototype.i18n.paging={
	results:"Results",
	records:"Records from ",
	to:" to ",
	page:"Page ",
	perpage:"rows per page",
	first:"To first Page",
	previous:"Previous Page",
	found:"Found records",
	next:"Next Page",
	last:"To last Page",
	of:" of ",
	notfound:"No Records Found"
}
/**
*  @desc: configure paging with toolbar mode ( must be called BEFORE enablePaging)
*  @param: navButtons - enable/disable navigation buttons
*  @param: navLabel - enable/disable navigation label
*  @param: pageSelect - enable/disable page selector
*  @param: perPageSelect - an array of "per page" select options ([5,10,15,20,25,30] by default)
*  @type: public
*  @edition: Professional
*/
dhtmlXGridObject.prototype.setPagingWTMode = function(navButtons,navLabel,pageSelect,perPageSelect){
	this._WTDef=[navButtons,navLabel,pageSelect,perPageSelect];
}
/**
*  @desc: Bricks skin for paging
*/
dhtmlXGridObject.prototype._pgn_bricks = function(page, start, end){
	//set class names depending on grid skin
	var tmp = (this.skin_name||"").split("_")[1];
	var sfx="";
	if(tmp=="light" || tmp=="modern" || tmp=="skyblue")
		sfx = "_"+tmp;
	
	this.pagerElAr = new Array();
	this.pagerElAr["pagerCont"] = document.createElement("DIV");
	this.pagerElAr["pagerBord"] = document.createElement("DIV");
	this.pagerElAr["pagerLine"] = document.createElement("DIV");
	this.pagerElAr["pagerBox"] = document.createElement("DIV");
	this.pagerElAr["pagerInfo"] = document.createElement("DIV");
	this.pagerElAr["pagerInfoBox"] = document.createElement("DIV");
	var se = (this.globalBox||this.objBox);
	this.pagerElAr["pagerCont"].style.width = se.clientWidth+"px";
	this.pagerElAr["pagerCont"].style.overflow = "hidden";
	this.pagerElAr["pagerCont"].style.clear = "both";
	this.pagerElAr["pagerBord"].className = "dhx_pbox"+sfx;
	this.pagerElAr["pagerLine"].className = "dhx_pline"+sfx;
	this.pagerElAr["pagerBox"].style.clear = "both";
	this.pagerElAr["pagerInfo"].className = "dhx_pager_info"+sfx;
	
	//create structure
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerBord"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerLine"]);
	this.pagerElAr["pagerCont"].appendChild(this.pagerElAr["pagerInfo"]);
	this.pagerElAr["pagerLine"].appendChild(this.pagerElAr["pagerBox"]);
	this.pagerElAr["pagerInfo"].appendChild(this.pagerElAr["pagerInfoBox"]);
	this._pgn_parentObj.innerHTML = "";
	this._pgn_parentObj.appendChild(this.pagerElAr["pagerCont"]);
	
	
	
	
	if(this.rowsBuffer.length>0){
		var lineWidth = 20;
		var lineWidthInc = 22;
		
		//create left arrow if needed
		if(page>this.pagesInGroup){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&larr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		//create pages
		for(var i=1;i<=this.pagesInGroup;i++){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageNumber = ((Math.ceil(page/this.pagesInGroup)-1)*this.pagesInGroup)+i;
			if(pageNumber>Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize))
				break;
			pageBox.innerHTML = pageNumber;
			pageCont.appendChild(pageBox);
			if(page==pageNumber){
				pageCont.className += " dhx_page_active"+sfx;
				pageBox.className = "dhx_page_active"+sfx;
			}else{
				var self = this;
				pageCont.pgnum = pageNumber;
				pageCont.onclick = function(){
					self.changePage(this.pgnum);
				}
			}
			lineWidth +=(parseInt(lineWidthInc/3)*pageNumber.toString().length)+15;
			pageBox.style.width = (parseInt(lineWidthInc/3)*pageNumber.toString().length)+8+"px";
			this.pagerElAr["pagerBox"].appendChild(pageCont);
		}
		//create right arrow if needed
		if(Math.ceil(page/this.pagesInGroup)*this.pagesInGroup<Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize)){
			var pageCont = document.createElement("DIV");
			var pageBox = document.createElement("DIV");
			pageCont.className = "dhx_page"+sfx;
			pageBox.innerHTML = "&rarr;";
			pageCont.appendChild(pageBox);
			this.pagerElAr["pagerBox"].appendChild(pageCont);
			var self = this;
			pageCont.pgnum = (Math.ceil(page/this.pagesInGroup)*this.pagesInGroup)+1;
			pageCont.onclick = function(){
				self.changePage(this.pgnum);
			}
			lineWidth +=lineWidthInc;
		}
		
		this.pagerElAr["pagerLine"].style.width = lineWidth+"px";
	}
	
	//create page info
	if(this.rowsBuffer.length>0 && this.showRecInfo)
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+this.i18n.paging.of+this.rowsBuffer.length;
	else if(this.rowsBuffer.length==0){
		this.pagerElAr["pagerLine"].parentNode.removeChild(this.pagerElAr["pagerLine"]);
		this.pagerElAr["pagerInfoBox"].innerHTML = this.i18n.paging.notfound;
	}
	//add whitespaces where necessary
	this.pagerElAr["pagerBox"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerBord"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.pagerElAr["pagerCont"].appendChild(document.createElement("SPAN")).innerHTML = "&nbsp;";
	this.callEvent("onPaging",[]);			
}


/**
*  @desc: web toolbar skin for paging
*/
dhtmlXGridObject.prototype._pgn_toolbar = function(page, start, end){
	if (!this.aToolBar) this.aToolBar = this._pgn_createToolBar();
	var totalPages=Math.ceil(this.rowsBuffer.length/this.rowsBufferOutSize);
	
	if (this._WTDef[0]){
		this.aToolBar.enableItem("right");
		this.aToolBar.enableItem("rightabs");
		this.aToolBar.enableItem("left");
		this.aToolBar.enableItem("leftabs");
		if(this.currentPage>=totalPages){
			this.aToolBar.disableItem("right");
			this.aToolBar.disableItem("rightabs");
		}
		if(this.currentPage==1){
			this.aToolBar.disableItem("left");
			this.aToolBar.disableItem("leftabs");
		}
	}
	if (this._WTDef[2]){
		var that = this;
		this.aToolBar.forEachListOption("pages", function(id){
			that.aToolBar.removeListOption("pages", id);
		});
		var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 14}[this.aToolBar.conf.skin];
		for (var i=0; i<totalPages; i++) {
			this.aToolBar.addListOption("pages", "pages_"+(i+1), NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+this.i18n.paging.page+(i+1)+"</span>", "paging_page.gif");
		}
		this.aToolBar.setItemText("pages", this.i18n.paging.page+page);
	}
	// pButton.setSelected(page.toString())
	
	
	if (this._WTDef[1]){
		if (!this.getRowsNum())
			this.aToolBar.setItemText('results',this.i18n.paging.notfound);
		else
			this.aToolBar.setItemText('results',"<div style='width:100%; text-align:center'>"+this.i18n.paging.records+(start+1)+this.i18n.paging.to+end+"</div>");
	}
	if (this._WTDef[3])
		this.aToolBar.setItemText("perpagenum", this.rowsBufferOutSize.toString()+" "+this.i18n.paging.perpage);
	
	this.callEvent("onPaging",[]);
}
dhtmlXGridObject.prototype._pgn_createToolBar = function(){
	this.aToolBar = new dhtmlXToolbarObject({
		parent: this._pgn_parentObj,
		skin: (this._pgn_skin_tlb||this.skin_name),
		icons_path: this.imgURL
	});
	if (!this._WTDef) this.setPagingWTMode(true, true, true, true);
	var self = this;
	this.aToolBar.attachEvent("onClick", function(val){
		val = val.split("_");
		switch (val[0]){
			case "leftabs":
				self.changePage(1);
				break;
			case "left":
				self.changePage(self.currentPage-1);
				break;
			case "rightabs":
				self.changePage(99999);
				break;
			case "right":
				self.changePage(self.currentPage+1);
				break;
			case "perpagenum":
				if (val[1]===this.undefined) return;
				self.rowsBufferOutSize = parseInt(val[1]);
				self.changePage();
				self.aToolBar.setItemText("perpagenum", val[1]+" "+self.i18n.paging.perpage);
				break;
			case "pages":
				if (val[1]===this.undefined) return;
				self.changePage(val[1]);
				self.aToolBar.setItemText("pages", self.i18n.paging.page+val[1]);
				break;
		}
	});
	// add buttons
	if (this._WTDef[0]) {
		this.aToolBar.addButton("leftabs", NaN, null, "ar_left_abs.gif", "ar_left_abs_dis.gif");
		this.aToolBar.addButton("left", NaN, null, "ar_left.gif", "ar_left_dis.gif");
	}
	if (this._WTDef[1]) {
		this.aToolBar.addText("results", NaN, this.i18n.paging.results);
		this.aToolBar.setWidth("results", "150");
		this.aToolBar.disableItem("results");
	}
	if (this._WTDef[0]) {
		this.aToolBar.addButton("right", NaN, null, "ar_right.gif", "ar_right_dis.gif");
		this.aToolBar.addButton("rightabs", NaN, null, "ar_right_abs.gif", "ar_right_abs_dis.gif");
	}
	if (this._WTDef[2]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("pages", NaN, "select page", [], "paging_pages.gif", null, false, true);
	}
	var arr;
	if (arr = this._WTDef[3]) {
		if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
		this.aToolBar.addButtonSelect("perpagenum", NaN, "select size", [], "paging_rows.gif", null, false, true);
		if (typeof arr != "object") arr = [5,10,15,20,25,30];
		var w = {dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 18}[this.aToolBar.conf.skin];
		for (var k=0; k<arr.length; k++) {
			this.aToolBar.addListOption("perpagenum", "perpagenum_"+arr[k], NaN, "button", "<span style='padding: 0px "+w+"px 0px 0px;'>"+arr[k]+" "+this.i18n.paging.perpage+"</span>", "paging_page.gif");
		}
	}
	
	//var td = document.createElement("TD"); td.width = "5"; this.aToolBar.tr.appendChild(td);
	//var td = document.createElement("TD"); td.width = "100%"; this.aToolBar.tr.appendChild(td);
	
	return this.aToolBar;
}

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

	dhtmlXGridObject.prototype.post = function(url, post, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		type=type||"xml";
	
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;

		this.xmlLoader = this.doLoadDetails;

		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc]);
	
			if (call){
				call();
				call=null;
			}
		};
		dhx4.ajax.post(url, (post||""), this.xmlLoader);
	}

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: set rowspan with specified length starting from specified cell
*   @param: rowID - row Id
*	@param: colInd - column index
*	@param: length - length of rowspan
*	@edition: professional
*   @type:  public
*/
dhtmlXGridObject.prototype.setRowspan=function(rowID,colInd,length){
    var c=this[this._bfs_cells?"_bfs_cells":"cells"](rowID,colInd).cell;    
   var r=this.rowsAr[rowID];

   if (c.rowSpan && c.rowSpan!=1){
		var ur=r.nextSibling;   
		for (var i=1; i<c.rowSpan; i++){
			var tc=ur.childNodes[ur._childIndexes[c._cellIndex+1]]
			var ti=document.createElement("TD"); 
			ti.innerHTML="&nbsp;"; 
			ti._cellIndex=c._cellIndex;
			ti._clearCell=true;
			if (tc)
				tc.parentNode.insertBefore(ti,tc);
			else
				ur.parentNode.appendChild(ti);
			this._shiftIndexes(ur,c._cellIndex,-1);
	    	ur=ur.nextSibling;
	    }
    }

    c.rowSpan=length;
    if (!this._h2)
		r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
	else
		r=this.rowsAr[ this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1].id ];
		
	var kids=[];
	for (var i=1; i<length; i++){
	    var ct=null;
		if (this._fake && !this._realfake)
		    ct=this._bfs_cells3(r,colInd).cell;
		else
		    ct=this.cells3(r,colInd).cell;
		
		

		this._shiftIndexes(r,c._cellIndex,1);
		if (ct)
    	ct.parentNode.removeChild(ct);
    	kids.push(r);
    	
    	if (!this._h2)
			r=r.nextSibling||this.rowsCol[this.rowsCol._dhx_find(r)+1];
		else { 
			var r=this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index+1];
			if (r) r=this.rowsAr[ r.id ];
		}
    }
    
    this.rowsAr[rowID]._rowSpan=this.rowsAr[rowID]._rowSpan||{};
    this.rowsAr[rowID]._rowSpan[colInd]=kids;
    if (this._fake && !this._realfake && colInd<this._fake._cCount) 
        this._fake.setRowspan(rowID,colInd,length)
}


dhtmlXGridObject.prototype._shiftIndexes=function(r,pos,ind){
		if (!r._childIndexes){
    	r._childIndexes=new Array();
        for (var z=0; z<r.childNodes.length; z++)
            r._childIndexes[z]=z;
		}
		
		for (var z=0; z<r._childIndexes.length; z++)
			if (z>pos)
            	r._childIndexes[z]=r._childIndexes[z]-ind;
				
}

/**
*   @desc: enable rowspan in grid
*   @type:  public
*	@edition: professional
*/
dhtmlXGridObject.prototype.enableRowspan=function(){
    this._erspan=true;
	this.enableRowspan=function(){};
	this.attachEvent("onAfterSorting",function(){
		if (this._dload) return; //can't be helped
		for (var i=1; i<this.obj.rows.length; i++)	
		  if (this.obj.rows[i]._rowSpan){
		  	var master=this.obj.rows[i];
		  	for (var kname in master._rowSpan){
			  	var row=master;
				var kids=row._rowSpan[kname];
			  	for (var j=0; j < kids.length; j++) {
			  		if(row.nextSibling)
			  			row.parentNode.insertBefore(kids[j],row.nextSibling);
			  		else 
			  			row.parentNode.appendChild(kids[j]);
			  		if (this._fake){ // split mode
			  		    var frow=this._fake.rowsAr[row.idd];
			  		    var fkid=this._fake.rowsAr[kids[j].idd];
			  		    if(frow.nextSibling)
			  		  	    frow.parentNode.insertBefore(fkid,frow.nextSibling);
			  		    else 
			  			  frow.parentNode.appendChild(fkid);
			  			 this._correctRowHeight(row.idd);
			  		}
			 		row=row.nextSibling;
			  	}
		    }
	  }
	  var t = this.rowsCol.stablesort;
	  this.rowsCol=new dhtmlxArray();
	  this.rowsCol.stablesort=t;
	  
	  for (var i=1; i<this.obj.rows.length; i++)	
	  	this.rowsCol.push(this.obj.rows[i]);
	  
	}) 
	
	this.attachEvent("onXLE",function(a,b,c,xml){
		for (var i=0; i<this.rowsBuffer.length; i++){
			var row = this.render_row(i);
			var childs = row.childNodes;
			for (var j=0; j<childs.length; j++){
				if (childs[j]._attrs["rowspan"]){
					this.setRowspan(row.idd, childs[j]._cellIndex, childs[j]._attrs["rowspan"]);
				}
			}
		}
	});
}


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
    Limitation:
        a) Width of column in px
        b) Grid not autoresizable
        c) Initialize grid in visible state
*/

dhx4.attachEvent("onGridCreated", function(grid){
    if (grid._split_later)
        grid.splitAt(grid._split_later);
});


/**
*   @desc:  split grid in two parts, with separate scrolling
*   @param:  ind - index of column to split after
*   @edition: Professional
*   @type:  public$
*/
dhtmlXGridObject.prototype.splitAt=function(ind){
    if (!this.obj.rows[0]) return this._split_later=ind;
    ind=parseInt(ind);
    
    var leftBox=document.createElement("DIV");
    this.entBox.appendChild(leftBox);
    var rightBox=document.createElement("DIV");
    this.entBox.appendChild(rightBox);
    
    for (var i=this.entBox.childNodes.length-3; i>=0; i--)
    	rightBox.insertBefore(this.entBox.childNodes[i],rightBox.firstChild);
    
    this.entBox.style.position="relative";	
    this.globalBox=this.entBox;
    this.entBox=rightBox; rightBox.grid=this;
    

    leftBox.style.cssText+="border:0px solid red !important;";
    rightBox.style.cssText+="border:0px solid red !important;";
    
	rightBox.style.top="0px";
    rightBox.style.position="absolute";
        
    leftBox.style.position="absolute";
    leftBox.style.top="0px";
    leftBox.style.left="0px";
    leftBox.style.zIndex=11;
        
    rightBox.style.height=leftBox.style.height=this.globalBox.clientHeight;
    
    
    this._fake=new dhtmlXGridObject(leftBox);
    
    this.globalBox=this._fake.globalBox=this.globalBox;
    this._fake._fake=this;
    this._fake._realfake=true;
    
	//copy properties    
    this._treeC=this.cellType._dhx_find("tree");
    this._fake.delim=this.delim;
    this._fake.customGroupFormat=this.customGroupFormat;
    
    this._fake.setImagesPath(this._imgURL);
    this._fake.iconURL = this.iconURL;
    this._fake._customSorts=this._customSorts;
	this._fake.noHeader=this.noHeader;
	this._fake._enbTts=this._enbTts;
	this._fake._drsclmW = this._drsclmW;
	this._fake._htkebl = this._htkebl;
	this._fake.clists = this.clists;
    this._fake.fldSort=new Array();
    this._fake.selMultiRows=this.selMultiRows;
    this._fake.multiLine=this.multiLine;
    this._fake._key_events = this._key_events;
    this._fake.smartTabOrder = this.smartTabOrder;
    this._fake._RaSeCol = this._RaSeCol;
   
    if (this.multiLine || this._erspan){
    	this.attachEvent("onCellChanged",this._correctRowHeight);
    	this.attachEvent("onRowAdded",this._correctRowHeight);
    	var corrector=function(){
    		this.forEachRow(function(id){
    			this._correctRowHeight(id);
			})
		};
		this.attachEvent("onPageChanged",corrector);
    	this.attachEvent("onXLE",corrector);
    	this.attachEvent("onResizeEnd",corrector);
    	if (!this._ads_count) //in case of distribute parsing - use special event instead
    		this.attachEvent("onAfterSorting",corrector);
        if (this._srnd)
            this.attachEvent("onFilterEnd", corrector);
    	this.attachEvent("onDistributedEnd",corrector);
		
    	//this._fake.attachEvent("onCellChanged",this._correctRowHeight);
    	}
    this.attachEvent("onGridReconstructed",function(){
    	this._fake.objBox.scrollTop = this.objBox.scrollTop;
	})
    
	this._fake.loadedKidsHash=this.loadedKidsHash;
	if (this._h2) this._fake._h2=this._h2;
	this._fake._dInc=this._dInc;
	
	//collect grid configuraton
    var b_ha=[[],[],[],[],[],[],[]];
    var b_ar=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor"];
    var b_fu=["setHeader","setInitWidths","setColTypes","setColAlign","setColVAlign","setColSorting","setColumnColor"];

    this._fake.callEvent=function(){
    	var result = true;
    	this._fake._split_event=true;
    	var hidden = (arguments[0] == "onScroll");
    	if (arguments[0]=="onGridReconstructed" || hidden)
    		this._fake.callEvent.apply(this,arguments);
    	
    	if (!hidden) result = this._fake.callEvent.apply(this._fake,arguments);
    	this._fake._split_event=false;	
    	return result;
    }
    	
    if (this._elmn)
		this._fake.enableLightMouseNavigation(true);

    if (this._cssEven||this._cssUnEven)
        this._fake.attachEvent("onGridReconstructed",function(){
            this._fixAlterCss();
        });

	this._fake._cssSP=this._cssSP;
	this._fake.isEditable=this.isEditable;
	this._fake._edtc=this._edtc;
	if (this._sst) this._fake.enableStableSorting(true);

	this._fake._sclE=this._sclE;
	this._fake._dclE=this._dclE;
	this._fake._f2kE=this._f2kE;
	this._fake._maskArr=this._maskArr;
	this._fake._dtmask=this._dtmask;
	this._fake.combos=this.combos;

    var width=0;

	var m_w=this.globalBox.offsetWidth;
    for (var i=0; i<ind; i++){
        for (var j=0; j<b_ar.length; j++){
            if (this[b_ar[j]])
                b_ha[j][i]=this[b_ar[j]][i];
            if (typeof b_ha[j][i] == "string") b_ha[j][i]=b_ha[j][i].replace(new RegExp("\\"+this.delim,"g"),"\\"+this.delim);
        }
        if (_isFF) b_ha[1][i]=b_ha[1][i]*1;
		if ( this.cellWidthType == "%"){
			b_ha[1][i]=Math.round(parseInt(this[b_ar[1]][i])*m_w/100);
			width+=b_ha[1][i];
		} else
	        width+=parseInt(this[b_ar[1]][i]);
        	this.setColumnHidden(i,true);
        }


    for (var j=0; j<b_ar.length; j++){
        var str=b_ha[j].join(this.delim);
       
	if (b_fu[j]!="setHeader"){
		if (str!="")
    		this._fake[b_fu[j]](str);
	} else
	    this._fake[b_fu[j]](str,null,this._hstyles);
    }


	this._fake._strangeParams=this._strangeParams;
    this._fake._drsclmn=this._drsclmn;

	width = Math.min(this.globalBox.offsetWidth, width);
    rightBox.style.left=width+"px";    leftBox.style.width=width+"px";
    rightBox.style.width=Math.max(this.globalBox.offsetWidth-width,0);

    if (this._ecspn) this._fake._ecspn=true;

//    this._fake.setNoHeader(true);
    this._fake.init();
    if (this.dragAndDropOff)
		this.dragger.addDragLanding(this._fake.entBox, this);
		
    this._fake.objBox.style.overflow="hidden";
    if (!dhtmlx.$customScroll)
    	this._fake.objBox.style.overflowX="scroll";
	else    
		this._fake.objBox._custom_scroll_mode = "";

   	this._fake._srdh=this._srdh||20;
   	this._fake._srnd=this._srnd;
	this._fake._cssEven=this._cssEven;
	this._fake._cssUnEven=this._cssUnEven;
	if (this.skin_name != this._fake.skin_name)
		this._fake.setSkin(this.skin_name);

   	var selfmaster = this;
	function _on_wheel(e){
		var cont = selfmaster.objBox;
		if (cont.scrollHeight - cont.offsetHeight > 2){
			var dir  = e.wheelDelta/-40;
			if (e.wheelDelta === window.undefined)
				dir = e.detail;
			cont.scrollTop += dir*40;
			
			if (e.preventDefault)
				e.preventDefault();
		}
	}
	dhtmlxEvent(this._fake.objBox,"mousewheel",_on_wheel);
	dhtmlxEvent(this._fake.objBox,"DOMMouseScroll",_on_wheel);


//inner methods

	
		function change_td(a,b){ 
			b.style.whiteSpace="";
			var c=b.nextSibling;
			var cp=b.parentNode;
			a.parentNode.insertBefore(b,a);
			if (!c)
				cp.appendChild(a);
			else
				cp.insertBefore(a,c);
			var z=a.style.display;
			a.style.display=b.style.display;
			b.style.display=z;
				}
		function proc_hf(i,rows,mode,frows){
			var temp_header=(new Array(ind)).join(this.delim);
			var temp_rspan=[];
			if (i==2)
				for (var k=0; k<ind; k++){
					var r=rows[i-1].cells[rows[i-1]._childIndexes?rows[i-1]._childIndexes[k]:k];
					if (r.rowSpan && r.rowSpan>1){
						temp_rspan[r._cellIndex]=r.rowSpan-1;
						frows[i-1].cells[frows[i-1]._childIndexes?frows[i-1]._childIndexes[k]:k].rowSpan=r.rowSpan;
						r.rowSpan=1;
					}
				}
				
				for (i; i<rows.length; i++){
					this._fake.attachHeader(temp_header,null,mode);
					frows=frows||this._fake.ftr.childNodes[0].rows;
					var max_ind=ind;
					var r_cor=0;
					for (var j=0; j<max_ind; j++){
						
						if (temp_rspan[j]) { 
							temp_rspan[j]=temp_rspan[j]-1;
							if (_isIE || _isOpera) {
								var td=document.createElement("TD");
								if (_isFF) td.style.display="none";
								rows[i].insertBefore(td,rows[i].cells[0])
							}
							
							r_cor++;
							continue;
						}

						var a=frows[i].cells[j-r_cor];
						var b=rows[i].cells[j-(_isIE?0:r_cor)];
						var t=b.rowSpan;
						
						change_td(a,b);
						if (t>1){ 
							temp_rspan[j]=t-1;
							b.rowSpan=t;
						}
						if (frows[i].cells[j].colSpan>1){
							rows[i].cells[j].colSpan=frows[i].cells[j].colSpan;
							max_ind-=frows[i].cells[j].colSpan-1;
							for (var k=1; k < frows[i].cells[j].colSpan; k++) 
								frows[i].removeChild(frows[i].cells[j+1]);
				}
		}
	}
		}
		
		if (this.hdr.rows.length>2)
			proc_hf.call(this,2,this.hdr.rows,"_aHead",this._fake.hdr.rows);
		if (this.ftr){
			proc_hf.call(this,1,this.ftr.childNodes[0].rows,"_aFoot");
			this._fake.ftr.parentNode.style.bottom=(_isFF?2:1)+"px";
		}
		

        if (this.saveSizeToCookie){
		   this.saveSizeToCookie=function(name,cookie_param){
		   		if (this._realfake)
					return this._fake.saveSizeToCookie.apply(this._fake,arguments);

				if (!name) name=this.entBox.id;
				var z=new Array();
				var n="cellWidthPX";
		
				for (var i=0; i<this[n].length; i++)
					if (i<ind)
						z[i]=this._fake[n][i];
					else
						z[i]=this[n][i];
				z=z.join(",")
				this.setCookie(name,cookie_param,0,z);
				var z=(this.initCellWidth||(new  Array)).join(",");
				this.setCookie(name,cookie_param,1,z);

			    return true;
			}
		this.loadSizeFromCookie=function(name){
			if (!name) name=this.entBox.id;
			var z=this._getCookie(name,1);

			if (!z) return
			this.initCellWidth=z.split(",");
			var z=this._getCookie(name,0);
			var n="cellWidthPX";
			this.cellWidthType="px";
			
            var summ2=0;
			if ((z)&&(z.length)){
				z=z.split(",");
				for (var i=0; i<z.length; i++)
					if (i<ind){
					   this._fake[n][i]=z[i];
					   summ2+=z[i]*1;
					   }
					else
					   this[n][i]=z[i];
			}

    		this._fake.entBox.style.width=summ2+"px";
    		this._fake.objBox.style.width=summ2+"px";
   			var pa=this.globalBox.childNodes[1];
			    pa.style.left=summ2-(_isFF?0:0)+"px";
			if (this.ftr)
	    		this.ftr.style.left=summ2-(_isFF?0:0)+"px";
    			pa.style.width=this.globalBox.offsetWidth-summ2+"px";

			this.setSizes();
		    return true;
		}
		   	this._fake.onRSE=this.onRSE;
		}


			this.setCellTextStyleA=this.setCellTextStyle;
			this.setCellTextStyle=function(row_id,i,styleString){
				if  (i<ind) this._fake.setCellTextStyle(row_id,i,styleString);
				this.setCellTextStyleA(row_id,i,styleString);
			}
			this.setRowTextBoldA=this.setRowTextBold;
   			this.setRowTextBold = function(row_id){
				this.setRowTextBoldA(row_id);
				this._fake.setRowTextBold(row_id);
            }
            
            this.setRowColorA=this.setRowColor;
   			this.setRowColor = function(row_id,color){
				this.setRowColorA(row_id,color);
				this._fake.setRowColor(row_id,color);
            } 
                       
			this.setRowHiddenA=this.setRowHidden;
   			this.setRowHidden = function(id,state){
				this.setRowHiddenA(id,state);
				this._fake.setRowHidden(id,state);
            }

			this.setRowTextNormalA=this.setRowTextNormal;
   			this.setRowTextNormal = function(row_id){
				this.setRowTextNormalA(row_id);
				this._fake.setRowTextNormal(row_id);
            }


			this.getChangedRows = function(and_added){
				var res = new Array();
				function test(row){
						for (var j = 0; j < row.childNodes.length; j++) 
							if (row.childNodes[j].wasChanged)
								return res[res.length]=row.idd;
				}
				this.forEachRow(function(id){
					var row = this.rowsAr[id];
					var frow = this._fake.rowsAr[id];
					if (row.tagName!="TR" || !frow || frow.tagName!="TR") return;
					if (and_added && row._added)
						res[res.length]=row.idd;
					else{
						if (!test(row)) test(frow);
					}
				});
				return res.join(this.delim);
			};
			this.setRowTextStyleA=this.setRowTextStyle;
   			this.setRowTextStyle = function(row_id,styleString){
				this.setRowTextStyleA(row_id,styleString);
				if (this._fake.rowsAr[row_id])
				this._fake.setRowTextStyle(row_id,styleString);
            }

			this.lockRowA = this.lockRow;
			this.lockRow = function(id,mode){ this.lockRowA(id,mode); this._fake.lockRow(id,mode); }
			
			this.getColWidth = function(i){
				if  (i<ind) return parseInt(this._fake.cellWidthPX[i]);
				else return parseInt(this.cellWidthPX[i]);
            };
            this.getColumnLabel = function(i){
            	return this._fake.getColumnLabel.apply(((i<ind)?this._fake:this) ,arguments);
            };
			this.setColWidthA=this._fake.setColWidthA=this.setColWidth;
			this.setColWidth = function(i,value){
				i=i*1;
				if  (i<ind) this._fake.setColWidthA(i,value);
				else this.setColWidthA(i,value);
				if ((i+1)<=ind) this._fake._correctSplit(Math.min(this._fake.objBox.offsetWidth,this._fake.obj.offsetWidth));
            }
			this.adjustColumnSizeA=this.adjustColumnSize;
			this.setColumnLabelA=this.setColumnLabel;
			this.setColumnLabel=function(a,b,c,d){
				var that  = this;
				if (a<ind) that = this._fake;
				return this.setColumnLabelA.apply(that,[a,b,c,d]);
			}
			this.adjustColumnSize=function(aind,c){
				if  (aind<ind) {
					if (_isIE) this._fake.obj.style.tableLayout="";
					this._fake.adjustColumnSize(aind,c);
					if (_isIE) this._fake.obj.style.tableLayout="fixed";
				    this._fake._correctSplit();
					}
				else return this.adjustColumnSizeA(aind,c);
			}

            var zname="cells";
            this._bfs_cells=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind){
                        return this._fake.cells.apply(this._fake,arguments);
                    } else
                        return this._bfs_cells.apply(this,arguments);
                    }
            
            this._bfs_isColumnHidden=this.isColumnHidden;        
            this.isColumnHidden=function(){
				if (parseInt(arguments[0])<ind)
					return this._fake.isColumnHidden.apply(this._fake,arguments);
				else
					return this._bfs_isColumnHidden.apply(this,arguments);
            }                    


            this._bfs_setColumnHidden=this.setColumnHidden;        
            this.setColumnHidden=function(){
                    if (parseInt(arguments[0])<ind){
                        this._fake.setColumnHidden.apply(this._fake,arguments);
                        return this._fake._correctSplit();
            		}
                    else
                        return this._bfs_setColumnHidden.apply(this,arguments);
                    }                    

            var zname="cells2";
            this._bfs_cells2=this[zname];
            this[zname]=function(){
                    if (arguments[1]<ind)
                        return this._fake.cells2.apply(this._fake,arguments);
                    else
                        return this._bfs_cells2.apply(this,arguments);
                    }

            var zname="cells3";
            this._bfs_cells3=this[zname];
            this[zname]=function(a,b){
                    if (arguments[1]<ind && this._fake.rowsAr[arguments[0].idd]){
                        //fall back for totally rowspanned row
                        if (this._fake.rowsAr[a.idd] && this._fake.rowsAr[a.idd].childNodes.length==0)  return this._bfs_cells3.apply(this,arguments);
                        arguments[0]=arguments[0].idd;
                        return this._fake.cells.apply(this._fake,arguments);
                        }
                    else
                        return this._bfs_cells3.apply(this,arguments);
                    }

            var zname="changeRowId";
            this._bfs_changeRowId=this[zname];
            this[zname]=function(){
                this._bfs_changeRowId.apply(this,arguments);
                if (this._fake.rowsAr[arguments[0]])
                	this._fake.changeRowId.apply(this._fake,arguments);
            }
            this._fake.getRowById=function(id){
            	var row = this.rowsAr[id];
            	if (!row && this._fake.rowsAr[id]) row=this._fake.getRowById(id);
				
			
				if (row){
					if (row.tagName != "TR"){
						for (var i = 0; i < this.rowsBuffer.length; i++)
							if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
								return this.render_row(i);
						if (this._h2) return this.render_row(null,row.idd);
					}
					return row;
				}
				return null;
			}

            if (this.collapseKids){
				//tree grid
	            this._fake["_bfs_collapseKids"]=this.collapseKids;
				this._fake["collapseKids"]=function(){
					return this._fake["collapseKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
				}
				
	            this["_bfs_collapseKids"]=this.collapseKids;
				this["collapseKids"]=function(){
					var z=this["_bfs_collapseKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				
	            this._fake["_bfs_expandKids"]=this.expandKids;
				this._fake["expandKids"]=function(){
					this._fake["expandKids"].apply(this._fake,[this._fake.rowsAr[arguments[0].idd]]);
					if (!this._cssSP) this._fake._fixAlterCss();
				}
				

				this["_bfs_expandAll"]=this.expandAll;
				this["expandAll"]=function(){
					this._bfs_expandAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}

				this["_bfs_collapseAll"]=this.collapseAll;
				this["collapseAll"]=function(){
					this._bfs_collapseAll();
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}								
				
	            this["_bfs_expandKids"]=this.expandKids;
				this["expandKids"]=function(){
					var z=this["_bfs_expandKids"].apply(this,arguments);
					this._fake._h2syncModel();
					if (!this._cssSP) this._fake._fixAlterCss();
				}				
				
				this._fake._h2syncModel=function(){
					if (this._fake.pagingOn) this._fake._renderSort();
					else this._renderSort();
				}
				this._updateTGRState=function(a){
					return this._fake._updateTGRState(a);
				}
			}



				//split


      if (this._elmnh){
			this._setRowHoverA=this._fake._setRowHoverA=this._setRowHover;
			this._unsetRowHoverA=this._fake._unsetRowHoverA=this._unsetRowHover;
			this._setRowHover=this._fake._setRowHover=function(){
				var that=this.grid;
				that._setRowHoverA.apply(this,arguments);
				var z=(_isIE?event.srcElement:arguments[0].target);
				z=that._fake.rowsAr[that.getFirstParentOfType(z,'TD').parentNode.idd];
				if (z){
					that._fake._setRowHoverA.apply(that._fake.obj,[{target:z.childNodes[0]},arguments[1]]);
				   	}
			};
			this._unsetRowHover=this._fake._unsetRowHover=function(){
				if (arguments[1]) var that=this;
				else	var that=this.grid;
				that._unsetRowHoverA.apply(this,arguments);
				that._fake._unsetRowHoverA.apply(that._fake.obj,arguments);
			};
		  		this._fake.enableRowsHover(true,this._hvrCss);
		  		this.enableRowsHover(false);
		  		this.enableRowsHover(true,this._fake._hvrCss);
			}

			this._updateTGRState=function(z){ 
				if (!z.update || z.id==0) return;
				if (this.rowsAr[z.id].imgTag)
					this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				if (this._fake.rowsAr[z.id] && this._fake.rowsAr[z.id].imgTag)
					this._fake.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
				z.update=false;
			}
			this.copy_row=function(row){
				    var x=row.cloneNode(true);
                    x._skipInsert=row._skipInsert;
                    var r_ind=ind;
                    x._attrs={};
                    x._css = row._css;
                    
                    if (this._ecspn){
                    	r_ind=0;
                    	for (var i=0; (r_ind<x.childNodes.length && i<ind); i+=(x.childNodes[r_ind].colSpan||1))
                    		r_ind++;
                    }
                                
                    while (x.childNodes.length>r_ind)
                        x.removeChild(x.childNodes[x.childNodes.length-1]);
                        var zm=r_ind;
                    for (var i=0; i<zm; i++){
                    	
						if (this.dragAndDropOff)
							this.dragger.addDraggableItem(x.childNodes[i], this);                        
                        x.childNodes[i].style.display=(this._fake._hrrar?(this._fake._hrrar[i]?"none":""):"");
                        x.childNodes[i]._cellIndex=i;
                        //TODO - more universal solution
                        x.childNodes[i].combo_value=arguments[0].childNodes[i].combo_value;
                        x.childNodes[i]._clearCell=arguments[0].childNodes[i]._clearCell;
                        x.childNodes[i]._cellType=arguments[0].childNodes[i]._cellType;
						x.childNodes[i]._brval=arguments[0].childNodes[i]._brval;
						x.childNodes[i].val =arguments[0].childNodes[i].val;
						x.childNodes[i]._combo =arguments[0].childNodes[i]._combo;
						x.childNodes[i]._attrs=arguments[0].childNodes[i]._attrs;
						x.childNodes[i].chstate=arguments[0].childNodes[i].chstate;
						if (row._attrs['style']) x.childNodes[i].style.cssText = row._attrs['style']+";"+x.childNodes[i].style.cssText;
						

						if(x.childNodes[i].colSpan>1) 
							x._childIndexes = arguments[0]._childIndexes;
					}
                    
                    if (this._h2 && this._treeC < ind){
						var trow=this._h2.get[arguments[0].idd];
                		x.imgTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level];
						x.valTag=x.childNodes[this._treeC].childNodes[0].childNodes[trow.level+2];
                        }

					
                        x.idd=row.idd;
                        x.grid=this._fake;
                        
                	return x;
                        	}
                    	
            var zname="_insertRowAt";
            this._bfs_insertRowAt=this[zname];
            this[zname]=function(){ 
                        var r=this["_bfs_insertRowAt"].apply(this,arguments);
                        arguments[0]=this.copy_row(arguments[0]);

                        var r2=this._fake["_insertRowAt"].apply(this._fake,arguments);
                        if (r._fhd){
							r2.parentNode.removeChild(r2);
                            this._fake.rowsCol._dhx_removeAt(this._fake.rowsCol._dhx_find(r2));
							r._fhd=false;
						}

						return r;
            }
            /*
var quirks = (_isIE && document.compatMode=="BackCompat");
		
		var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		var isHScroll = this.parentGrid?false:(this.objBox.scrollWidth > this.objBox.offsetWidth); 
		var scrfix = _isFF?20:18;
		
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;
				
		var gridWidth=this.entBox.clientWidth;
		var gridHeight=this.entBox.clientHeight;
		*/
            this._bfs_setSizes=this.setSizes;
            this.setSizes=function(){
            		if (this._notresize) return;
                	this._bfs_setSizes(this,arguments);
                	
					this.sync_headers()
					if (this.sync_scroll() && this._ahgr) this.setSizes(); //if scrolls was removed - check once more to correct auto-height
					
					var height = this.dontSetSizes ? (this.entBox.offsetHeight+"px") : this.entBox.style.height;
					this._fake.entBox.style.height = height;

                    this._fake.objBox.style.height=this.objBox.style.height;
                    this._fake.hdrBox.style.height=this.hdrBox.style.height;
                    
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    
                    this._fake.setColumnSizes(this._fake.entBox.clientWidth);
                    
                    this.globalBox.style.width=parseInt(this.entBox.style.width)+parseInt(this._fake.entBox.style.width);
                    if (!this.dontSetSizes)
                    	this.globalBox.style.height = height;
                    
            }
            
            this.sync_scroll=this._fake.sync_scroll=function(end){
            		var old=this.objBox.style.overflowX;
            	    if (this.obj.offsetWidth<=this.objBox.offsetWidth)
                    {
                    	if (!end) return this._fake.sync_scroll(true);
                        this.objBox.style.overflowX="hidden";
                        this._fake.objBox.style.overflowX="hidden";
                    }
                    else if (!dhtmlx.$customScroll){
                        this.objBox.style.overflowX="scroll";
                        this._fake.objBox.style.overflowX="scroll";
                    }
                    return old!=this.objBox.style.overflowX;
        	}
            this.sync_headers=this._fake.sync_headers=function(){
            	if (this.noHeader || (this._fake.hdr.scrollHeight==this.hdr.offsetHeight) || this.noHeaderResize) return;
            //	if (this.hdr.rows.length!=2){
            		for (var i=1; i<this.hdr.rows.length; i++){
            			var td = ind;
            			while (!this.hdr.rows[i].childNodes[td]) td--;
            			var ha=Math.min(this.hdr.rows[i].childNodes[td].scrollHeight+2, this.hdr.rows[i].scrollHeight);
						var hb=this._fake.hdr.rows[i].scrollHeight;
						if (ha!=hb)
							this._fake.hdr.rows[i].style.height=this.hdr.rows[i].style.height=Math.max(ha,hb)+"px";
						if (window._KHTMLrv) {
							var lindex = 0;
							while (this._fake._hrrar[lindex]) lindex++;
							this._fake.hdr.rows[i].childNodes[lindex].style.height=this.hdr.rows[i].childNodes[td].style.height=Math.max(ha,hb)+"px";
						}
					}
					this._fake.sync_headers;
			//	} else this._fake.hdr.style.height=this.hdr.offsetHeight+"px";
        	}
        	this._fake._bfs_setSizes=this._fake.setSizes;
            this._fake.setSizes=function(){
            		if (this._fake._notresize) return;
            		this._fake.setSizes();
            }

            var zname="_doOnScroll";
            this._bfs__doOnScroll=this[zname];
            this[zname]=function(){
                    this._bfs__doOnScroll.apply(this,arguments);
                    this._fake.objBox.scrollTop=this.objBox.scrollTop;
                    this._fake["_doOnScroll"].apply(this._fake,arguments);
            }
            
            var zname="selectAll";
            this._bfs__selectAll=this[zname];
            this[zname]=function(){
                    this._bfs__selectAll.apply(this,arguments);
                    this._bfs__selectAll.apply(this._fake,arguments);
            }
            
            



            var zname="doClick";
            this._bfs_doClick=this[zname];
            this[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex>=ind);
							if (!arguments[0].parentNode.idd) return;
							if (!fl)
                            	arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                            //item selected but it left part not rendered yet
							if (!this._fake.rowsAr[arguments[0].parentNode.idd])
								this._fake.render_row(this.getRowIndex(arguments[0].parentNode.idd));
                            arguments[0]=this._fake.cells(arguments[0].parentNode.idd,(fl?0:arguments[0]._cellIndex)).cell;
                            if (fl) this._fake.cell=null;
                            this._fake["_bfs_doClick"].apply(this._fake,arguments);
                            if (fl) this._fake.cell=this.cell;
                            else this.cell=this._fake.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
                                this._fake.cell=this.cell;                                
                                }
                            else{
                                this.objBox.scrollTop=this._fake.objBox.scrollTop;
	                            }
                        }
            }
            this._fake._bfs_doClick=this._fake[zname];
            this._fake[zname]=function(){
                    this["_bfs_doClick"].apply(this,arguments);
                        if (arguments[0].tagName=="TD"){
                            var fl=(arguments[0]._cellIndex<ind);
							if (!arguments[0].parentNode.idd) return;
                            arguments[0]=this._fake._bfs_cells(arguments[0].parentNode.idd,(fl?ind:arguments[0]._cellIndex)).cell;
                            this._fake.cell=null;
this._fake["_bfs_doClick"].apply(this._fake,arguments);
							this._fake.cell=this.cell;
                            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
                            if (fl) {
                                arguments[0].className=arguments[0].className.replace(/cellselected/g,"");
                                globalActiveDHTMLGridObject=this;
								this._fake.cell=this.cell;                                
								this._fake.objBox.scrollTop=this.objBox.scrollTop;
                                }
                        }
            }


this.clearSelectionA = this.clearSelection;
this.clearSelection = function(mode){
    if (mode) this._fake.clearSelection();
    this.clearSelectionA();
}


this.moveRowUpA = this.moveRowUp;
this.moveRowUp = function(row_id){
	if (!this._h2)
    	this._fake.moveRowUp(row_id);
    this.moveRowUpA(row_id);
    if (this._h2) this._fake._h2syncModel();
}
this.moveRowDownA = this.moveRowDown;
this.moveRowDown = function(row_id){
	if (!this._h2)
    	this._fake.moveRowDown(row_id);
    this.moveRowDownA(row_id);
    if (this._h2) this._fake._h2syncModel();
}



this._fake.getUserData=function(){	return this._fake.getUserData.apply(this._fake,arguments); }
this._fake.setUserData=function(){	return this._fake.setUserData.apply(this._fake,arguments); }

this.getSortingStateA=this.getSortingState;
this.getSortingState = function(){
	var z=this.getSortingStateA();
	if (z.length!=0) return z;
	return this._fake.getSortingState();
}

this.setSortImgStateA=this._fake.setSortImgStateA=this.setSortImgState;
this.setSortImgState = function(a,b,c,d){
	this.setSortImgStateA(a,b,c,d);
	if (b*1<ind) {
		this._fake.setSortImgStateA(a,b,c,d);
		this.setSortImgStateA(false);
	} else 
		this._fake.setSortImgStateA(false);
}


this._fake.doColResizeA = this._fake.doColResize;
this._fake.doColResize = function(ev,el,startW,x,tabW){ 
    var a=-1;
    var z=0;
    if (arguments[1]._cellIndex==(ind-1)){
            a = this._initalSplR + (ev.clientX-x);
            if (!this._initalSplF) this._initalSplF=arguments[3]+this.objBox.scrollWidth-this.objBox.offsetWidth;
            if (this.objBox.scrollWidth==this.objBox.offsetWidth && (this._fake.alter_split_resize || (ev.clientX-x)>0 )){
            	arguments[3]=(this._initalSplF||arguments[3]);
            	z=this.doColResizeA.apply(this,arguments);
            } 
            else
            	z=this.doColResizeA.apply(this,arguments);
    }
    else{
        if (this.obj.offsetWidth<this.entBox.offsetWidth)
    		a=this.obj.offsetWidth;
    	z=this.doColResizeA.apply(this,arguments);
	}
	
	if (z !== false){
		this._correctSplit(a);
		this.resized=this._fake.resized=1;
	}
    return z;
}

		this._fake.changeCursorState = function(ev){
                     var el = ev.target||ev.srcElement;
                     if(el.tagName!="TD")
                           el = this.getFirstParentOfType(el,"TD")
                           if ((el.tagName=="TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex])) return;
                           var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName=="DIV"))?el.offsetLeft:0);
                           var pos = parseInt(this.getPosition(el,this.hdrBox)); 
                           
                           if(((el.offsetWidth - (ev.offsetX||(pos-check)*-1))<(_isOpera?20:10))||((this.entBox.offsetWidth - (ev.offsetX?(ev.offsetX+el.offsetLeft):check) + this.objBox.scrollLeft - 0)<(_isOpera?20:10))){
                              el.style.cursor = "E-resize";
                           }else
                              el.style.cursor = "default";
                       if (_isOpera) this.hdrBox.scrollLeft = this.objBox.scrollLeft;
                        }
			
		this._fake.startColResizeA = this._fake.startColResize;
		this._fake.startColResize = function(ev){
                                    var z=this.startColResizeA(ev);
                                    this._initalSplR=this.entBox.offsetWidth;
                                    this._initalSplF=null;
                                    if (this.entBox.onmousemove){
                                        var m=this.entBox.parentNode;   
                                        if (m._aggrid) return z;
										m._aggrid=m.grid;   m.grid=this;
                                        this.entBox.parentNode.onmousemove=this.entBox.onmousemove;
                                        this.entBox.onmousemove=null;
                                        }
                                    return z;
								}

		this._fake.stopColResizeA = this._fake.stopColResize;
		this._fake.stopColResize = function(ev){
                                    if (this.entBox.parentNode.onmousemove){
                                        var m=this.entBox.parentNode;   m.grid=m._aggrid;   m._aggrid=null;
                                        this.entBox.onmousemove=this.entBox.parentNode.onmousemove;
                                        this.entBox.parentNode.onmousemove=null;
                                        if (this.obj.offsetWidth<this.entBox.offsetWidth)
                                        	this._correctSplit(this.obj.offsetWidth);
                                        }
                                    return this.stopColResizeA(ev);
								}



this.doKeyA = this.doKey;
this._fake.doKeyA = this._fake.doKey;

function inner_runner(index, rindex, master, ev){
	var dir = ev.shiftKey ? -1 : 1;
	var end = ev.shiftKey ? -1 : master._cCount;
	var next = false;

	for (var i=index+dir; i!=end; i+=dir){
		if (master.smartTabOrder){
			next = master.cells2(rindex, i).isDisabled() ? false : i;
		} else 
			next = i;

		if (next !== false){
			var editmode = !master._key_events.k_other;
			master.selectCell( rindex, next, false, false, editmode, true);
			ev.cancelBubble = true;
			if (ev.preventDefault) ev.preventDefault();
			return true;
		}
	}
}

this._fake.doKey=this.doKey=function(ev){
                            if (!ev) return true;
                            if (this._htkebl) return true;
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);

			if ((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1))
				return true;
		}
		                            
    switch (ev.keyCode){
        case 9:
        	var master = this._realfake ? this._fake : this;
        	if (!master.callEvent("onTab",[true])) return true;

                    if (this.cell){
        		var index = this.cell._cellIndex;
							
				var rindex = master.getRowIndex(this.cell.parentNode.idd);
				while (!inner_runner(index, rindex, master, ev)){
					rindex += (ev.shiftKey ? -1 : 1);
					if (rindex < 0 || rindex >= master.rowsBuffer.length) return;
					index = ev.shiftKey ? master._cCount : -1;					
                }
				return;
            }
       break;
    }
    return  this.doKeyA(ev);
}


this.editCellA=this.editCell;
this.editCell=function(){
	if (this.cell && this.cell.parentNode.grid != this) return this._fake.editCell();
	return this.editCellA();
}

this.deleteRowA = this.deleteRow;
this.deleteRow=function(row_id,node){
/*	if (!this._realfake)
		this._fake.loadedKidsHash=this.loadedKidsHash;*/

    if (this.deleteRowA(row_id,node)===false) return false;
    if (this._fake.rowsAr[row_id])
    	this._fake.deleteRow(row_id);
}

this.clearAllA = this.clearAll;
this.clearAll=function(){
    this.clearAllA();
    this._fake.clearAll();
}
this.editStopA = this.editStop;
this.editStop=function(mode){
	if (this._fake.editor)
		this._fake.editStop(mode);
	else 
    	this.editStopA(mode);
};


this.attachEvent("onAfterSorting",function(i,b,c){
	if (i>=ind) 
		this._fake.setSortImgState(false)
});



this._fake.sortField = function(a,b,c){ 
	this._fake.sortField.call(this._fake,a,b,this._fake.hdr.rows[0].cells[a]);
	if (this.fldSort[a]!="na" && this._fake.fldSorted){
		var mem = this._fake.getSortingState()[1];
		this._fake.setSortImgState(false);
		this.setSortImgState(true,arguments[0],mem)
	}
}

this.sortTreeRowsA = this.sortTreeRows;
this._fake.sortTreeRowsA = this._fake.sortTreeRows;
this.sortTreeRows=this._fake.sortTreeRows=function(col,type,order,ar){
    if (this._realfake) return this._fake.sortTreeRows(col,type,order,ar)

    this.sortTreeRowsA(col,type,order,ar);
    this._fake._h2syncModel();

                this._fake.setSortImgStateA(false);
	this._fake.fldSorted=null;
    }

/* SRND mode */
this._fake._fillers=[];
this._fake.rowsBuffer=this.rowsBuffer;
this.attachEvent("onClearAll",function(){
	this._fake.rowsBuffer=this.rowsBuffer;	
})
this._add_filler_s=this._add_filler;
this._add_filler=function(a,b,c,e){
	if (!this._fake._fillers) this._fake._fillers=[];
	if (this._realfake || !e){
		var d;
		if (c && c.idd) d=this._fake.rowsAr[c.idd];
		else if (c && c.nextSibling) {
			d = {};
			d.nextSibling=this._fake.rowsAr[c.nextSibling.idd];
			d.parentNode=d.nextSibling.parentNode;
		} else if (this._fake._fillers.length){
			d = this._fake._fillers[this._fake._fillers.length-1][2];
		}
		this._fake._fillers.push(this._fake._add_filler(a,b,d));	
	}
	
	return this._add_filler_s.apply(this,arguments);
}
this._add_from_buffer_s=this._add_from_buffer;
this._add_from_buffer=function() { 
	var res=this._add_from_buffer_s.apply(this,arguments);
	if (res!=-1){
		this._fake._add_from_buffer.apply(this._fake,arguments);
		if (this.multiLine) this._correctRowHeight(this.rowsBuffer[arguments[0]].idd);
	}
	return res;
    }
this._fake.render_row=function(ind){
	var row=this._fake.render_row(ind);

	if (row == -1) return -1;
	if (row) {
		return this.rowsAr[row.idd]=this.rowsAr[row.idd]||this._fake.copy_row(row);
    }
	return null;
        }
this._reset_view_s=this._reset_view;
this._reset_view=function(){
	this._fake._reset_view(true);
	this._fake._fillers=[];
	this._reset_view_s();
    }

this.moveColumn_s=this.moveColumn;
this.moveColumn=function(a,b){
	if (b>=ind) return this.moveColumn_s(a,b);
}

    
this.attachEvent("onCellChanged",function(id,i,val){
	if (this._split_event && i<ind && this.rowsAr[id]){
		
		var cell=this._fake.rowsAr[id];
		if (!cell) return;
		if (cell._childIndexes)
			cell=cell.childNodes[cell._childIndexes[i]];
		else
			cell=cell.childNodes[i];
		var tcell = this.rowsAr[id].childNodes[i];
	
		if (tcell._treeCell && tcell.firstChild.lastChild)
			tcell.firstChild.lastChild.innerHTML = val;
		else
			tcell.innerHTML=cell.innerHTML;
		tcell._clearCell=false;
		tcell.combo_value = cell.combo_value;
		tcell.chstate=cell.chstate;	//TODO - more universal solution
	}
})





    this._fake.combos=this.combos;
	this.setSizes();
	if (this.rowsBuffer[0]) this._reset_view();
	this.attachEvent("onXLE",function(){this._fake._correctSplit()})
	this._fake._correctSplit();
}

dhtmlXGridObject.prototype._correctSplit=function(a){ 
    a=a||(this.obj.scrollWidth-this.objBox.scrollLeft);
    a=Math.min(this.globalBox.offsetWidth, a);
    if (a>-1){
	    this.entBox.style.width=a+"px";
	    this.objBox.style.width=a+"px";
	
		var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth)/2;
	    this._fake.entBox.style.left=a+"px";
	    this._fake.entBox.style.width=Math.max(0,this.globalBox.offsetWidth-a-(this.quirks?0:2)*outerBorder)+"px";
	    if (this._fake.ftr)
	    	this._fake.ftr.parentNode.style.width=this._fake.entBox.style.width;
	    if (_isIE){
		    var quirks=_isIE && !window.xmlHttpRequest;
			var outerBorder=(this.globalBox.offsetWidth-this.globalBox.clientWidth);
			this._fake.hdrBox.style.width=this._fake.objBox.style.width=Math.max(0,this.globalBox.offsetWidth-(quirks?outerBorder:0)-a)+"px";
		}
	}
}

dhtmlXGridObject.prototype._correctRowHeight=function(id,ind){
	if (!this.rowsAr[id] || !this._fake.rowsAr[id]) return;

	var h=parseInt(this.rowsAr[id].style.height) || this.rowsAr[id].offsetHeight;
	var h2=parseInt(this._fake.rowsAr[id].style.height) || this._fake.rowsAr[id].offsetHeight;
	var max = Math.max(h,h2) - (this.rowsAr[id].delta_fix || 0);
	if (!max) return;
	this.rowsAr[id].style.height=this._fake.rowsAr[id].style.height=Math.round(max+1)+"px";
	this.rowsAr[id].delta_fix = 1;
	if (window._KHTMLrv) {
		var j = this._fake._cCount;
		var td;
		while (!td && j>=0){
			td = this.rowsAr[id].childNodes[j];
			j-=1;
		}
		var td2 = this._fake.rowsAr[id].firstChild;
		if (td && td2){
			td.style.height=td2.style.height=max+"px";
		}
	}
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable automatic size saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSizeSaving = function(name,cookie_param){
		this.attachEvent("onResizeEnd",function(){ this.saveSizeToCookie(name,cookie_param) });
}

/**
*   @desc: store opene state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.saveOpenStates = function(name,cookie_param){
	if (!name) name=this.entBox.id;
	var t=[];
	this._h2.forEachChild(0,function(el){
		if (el.state=="minus") t.push(el.id);
	});
	var str = "gridOpen"+(name||"") + "=" + t.join("|") +  (cookie_param?("; "+cookie_param):"");
	document.cookie = str;
}


/**
*   @desc: load open state of TreeGrid in cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadOpenStates = function(name,cookie_param){
	var val=this.getCookie(name,"gridOpen");
	if (!val) return;
	val=val.split("|");
	for (var i = 0; i < val.length; i++) {
		var pid = this.getParentId(val[i]);
		if (!this.getOpenState(pid)) continue;
		this.openItem(val[i]);
	}
}

/**
*   @desc: enable automatic saving column state ( hidden | shown )
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoHiddenColumnsSaving = function(name,cookie_param){
		this.attachEvent("onColumnHidden",function(){ 
				this.saveHiddenColumnsToCookie(name,cookie_param); 
		});
}

/**
*   @desc: enable automatic sorting state saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSortingSaving = function(name,cookie_param){
	this.attachEvent("onBeforeSorting",function(){ 
		var that=this;
		window.setTimeout(function(){
			that.saveSortingToCookie(name,cookie_param);
			},1);
		return true;
		});	
}

/**
*   @desc: enable automatic column order saving to cookie
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableOrderSaving = function(name,cookie_param){
	this.attachEvent("onAfterCMove",function(){ 
		this.saveOrderToCookie(name,cookie_param);  
		this.saveSizeToCookie(name,cookie_param);
	});
}

/**
*   @desc: enable automatic saving of all possible params
*   @param: name - optional, cookie name
*   @param: cookie_param - additional parameters added to cookie
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableAutoSaving = function(name,cookie_param){
		this.enableOrderSaving(name,cookie_param);
		this.enableAutoSizeSaving(name,cookie_param);
		this.enableSortingSaving(name,cookie_param);
}


/**   @desc: save grid layout to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSizeToCookie=function(name,cookie_param){
	if (this.cellWidthType=='px')
		var z=this.cellWidthPX;
	else
		var z=this.cellWidthPC;

	var z2=(this.initCellWidth||[]).join(",");

	if (this._hrrar)
		for (var i = 0; i < this._hrrar.length; i++)
			if (this._hrrar[i]) z[i] = "";
		
	this.setCookie(name,cookie_param,0,z.join(","));
	this.setCookie(name,cookie_param,1,z2);
}

/**   @desc: save hidden columns to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveHiddenColumnsToCookie=function(name,cookie_param){

    var hs=[].concat(this._hrrar||[]);
    if (this._fake && this._fake._hrrar)
        for (var i=0; i < this._fake._cCount; i++)
            hs[i]=this._fake._hrrar[i]?"1":"";
	this.setCookie(name,cookie_param,4,hs.join(",").replace(/display:none;/g,"1"));
}

/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadHiddenColumnsFromCookie=function(name){
	var z=this._getCookie(name,4);
	var ar=(z||"").split(",");
	for (var i=0; i < this._cCount; i++) 
		this.setColumnHidden(i,(ar[i]?true:false));
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveSortingToCookie=function(name,cookie_param){
	this.setCookie(name,cookie_param,2,(this.getSortingState()||[]).join(","));
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSortingFromCookie=function(name){
	var z=this._getCookie(name,2);
	z=(z||"").split(",");
	if (z.length>1 && z[0]<this._cCount){
		this.sortRows(z[0],null,z[1]);
		this.setSortImgState(true,z[0],z[1]);
	}
}



/**   @desc: save sorting order to cookie
*     @type: public
*     @param: name - optional, cookie name
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.saveOrderToCookie=function(name,cookie_param){
	if (!this._c_order) {
		this._c_order=[];
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}
	this.setCookie(name,cookie_param,3,((this._c_order||[]).slice(0,this._cCount)).join(","));
	this.saveSortingToCookie(name, cookie_param);
}


/**   @desc: load sorting order from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadOrderFromCookie=function(name){
	var z=this._getCookie(name,3);
	z=(z||"").split(",");
	if (z.length>1 && z.length<=this._cCount){
			//code below probably may be optimized
			for (var i=0; i<z.length; i++)
				if ((!this._c_order && z[i]!=i)||(this._c_order && z[i]!=this._c_order[i])){
					var t=z[i];
					if (this._c_order)
						for (var j=0; j<this._c_order.length; j++) {
							if (this._c_order[j]==z[i]) {
								t=j; break;
								}
						}
					this.moveColumn(t*1,i);
				}
	}
}


/**   @desc: load grid layout from cookie
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.loadSizeFromCookie=function(name){ 
	var z=this._getCookie(name,1);
	if (z)
		this.initCellWidth=z.split(",");
	var z=this._getCookie(name,0);
	if ((z)&&(z.length)){
		z = z.split(",");

		if (!this._fake && this._hrrar) 
			for (var i=0; i<z.length; i++) 
				if (this._hrrar[i]) z[i]=0;

		if (this.cellWidthType=='px')
			this.cellWidthPX=z;
		else
			this.cellWidthPC=z;
		}

	for (var i=0; i<z.length; i++)
		if (z[i] === ""){
			z[i] = this.initCellWidth[i];
			this.setColumnHidden(i, true);
		}

	this.setSizes();
    return true;
}

/**   @desc: clear cookie with grid config details
*     @type: public
*     @param: name - optional,cookie name
*     @edition: Professional
*     @topic: 2
*/
dhtmlXGridObject.prototype.clearConfigCookie=function(name){
	if (!name) name=this.entBox.id;
	var str = "gridSettings"+name + "=||||";
	document.cookie = str;
}
dhtmlXGridObject.prototype.clearSizeCookie=dhtmlXGridObject.prototype.clearConfigCookie;


/**   @desc: save cookie
*     @type: private
*     @param: name - cookie name
*     @param: value - cookie value
*     @param: cookie_param - additional parameters added to cookie
*     @edition: Professional
*     @topic: 0
*/

dhtmlXGridObject.prototype.setCookie=function(name,cookie_param,pos,value) {
	if (!name) name=this.entBox.id;
	var t=this.getCookie(name);
	t=(t||"||||").split("|");
	t[pos]=value;
	var str = "gridSettings"+name + "=" + t.join("|").replace(/,/g,"-") +  (cookie_param?("; "+cookie_param):"");
//	console.log("save",str)
	document.cookie = str;
}

/**   @desc: get cookie
*     @type: private
*     @param: name - cookie name
*     @edition: Professional
*     @topic: 0
*/
dhtmlXGridObject.prototype.getCookie=function(name,surname) { 
	if (!name) name=this.entBox.id;
	name=(surname||"gridSettings")+name;
	var search = name + "=";
	if (document.cookie.length > 0) {
		var offset = document.cookie.indexOf(search);
		if (offset != -1) {
			offset += search.length;
			var end = document.cookie.indexOf(";", offset);
			if (end == -1)
				end = document.cookie.length;
			return document.cookie.substring(offset, end);
						}		}
};
dhtmlXGridObject.prototype._getCookie=function(name,pos) {
//	console.log("get",this.getCookie(name))
	return ((this.getCookie(name)||"||||").replace(/-/g,",").split("|"))[pos];
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.enableUndoRedo = function()
{ 
	var self = this;
	var func = function() {return self._onEditUndoRedo.apply(self,arguments);}
	this.attachEvent("onEditCell", func);
	var func2 = function(a,b,c) {return self._onEditUndoRedo.apply(self,[2,a,b,(c?1:0),(c?0:1)]);}		
	this.attachEvent("onCheckbox", func2);
	this._IsUndoRedoEnabled = true;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}
/**
*	@desc: disable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.disableUndoRedo = function()
{
	this._IsUndoRedoEnabled = false;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}

dhtmlXGridObject.prototype._onEditUndoRedo = function(stage, row_id, cell_index, new_value, old_value)
{
	if (this._IsUndoRedoEnabled && stage == 2 && old_value != new_value) {
	    if (this._UndoRedoPos !== -1 && this._UndoRedoPos != ( this._UndoRedoData.length-1 ) ) {
	        this._UndoRedoData = this._UndoRedoData.slice(0, this._UndoRedoPos+1);
	    } else if (this._UndoRedoPos === -1 && this._UndoRedoData.length > 0) {
	        this._UndoRedoData = [];
	    }

	    var obj = { old_value:old_value,
	                new_value:new_value,
	                row_id:row_id,
	                cell_index:cell_index
	    };
	    this._UndoRedoData.push(obj);
	    this._UndoRedoPos++;
	}
	return true;
}
/**
*	@desc: UnDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doUndo = function()
{
	if (this._UndoRedoPos === -1)
		return false;
	var obj = this._UndoRedoData[this._UndoRedoPos--];
	var c=this.cells(obj.row_id, obj.cell_index);
	if (this.getColType(obj.cell_index)=="tree")
		c.setLabel(obj.old_value);
	else
		c.setValue(obj.old_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: ReDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return false;
	var obj = this._UndoRedoData[++this._UndoRedoPos];
	this.cells(obj.row_id, obj.cell_index).setValue(obj.new_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: get length of available ReDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return [];
	return this._UndoRedoData.slice(this._UndoRedoPos+1);
}
/**
*	@desc: get length of available UnDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getUndo = function()
{
	if (this._UndoRedoPos == -1)
		return [];
	return this._UndoRedoData.slice(0, this._UndoRedoPos+1);
}
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.enableAccessKeyMap = function(){
/*
	keymap like MS Access offers
*/
this._select_ifpossible=function(){
	if (this.editor && this.editor.obj && this.editor.obj.select) this.editor.obj.select();
};
this._key_events={
			//ctrl-enter
			k13_1_0:function(){
				this.editStop();
			},
			//shift-enter
			k13_0_1:function(){
				this._key_events.k9_0_1.call(this);
			},
			//enter
			k13_0_0:function(){
				this._key_events.k9_0_0.call(this);
            },
            //tab
            k9_0_0:function(){
					this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				var z=this._getNextCell(null,1);
				if (z) {
					if (this.pagingOn) this.showRow(z.parentNode.idd);
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //shift-tab
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				var z=this._getNextCell(null,-1);
				if (z) {
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //f2 key
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            //space
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            //escape
            k27_0_0:function(){
            	this.editStop(true);
            },
            //pageUp
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pageDown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
	        //left
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
	        //right
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
            //ctrl left
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,false,false,true);
				this._select_ifpossible();
	        },
	        //ctrl right
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,false,false,true);
				this._select_ifpossible();
            },
            //ctrl up
			k38_1_0:function(){
			
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //ctrl down
			k40_1_0:function(){
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
            },
            //shift up
			k38_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //shift down
			k40_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                this._select_ifpossible();
            },   
            //ctrl shift up  
			k38_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
	        },
	        //ctrl shift down
			k40_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd+1; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
            },    
            //down               
			k40_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (this.rowsBuffer[rowInd]){
						var nrow=this._nextRow(rowInd-1,1);
						if (this.pagingOn && nrow) this.showRow(nrow.idd);
						this._Opera_stop=0;
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
                    else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
				this._still_active=true;								
            },
            //home
            k36_0_0:function(){ 
            	return this._key_events.k37_1_0.call(this);
            },
            //end
            k35_0_0:function(){ 
            	return this._key_events.k39_1_0.call(this);
            },            
            //ctrl-home
            k36_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true,false,true);
				this._select_ifpossible();
            },
            //ctrl-end
            k35_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true,false,true);
				this._select_ifpossible();
            },  
            //padeup
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pagedown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },  
	        //up                                
			k38_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
				
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (rowInd!=-1){
						var nrow=this._nextRow(rowInd-1,-1);
                        this._Opera_stop=0;
                        if (this.pagingOn && nrow) this.showRow(nrow.idd);
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
					else this._key_events.k33_0_0.apply(this,[]);
				}
				this._still_active=true;
            }
		};

};
dhtmlXGridObject.prototype.enableExcelKeyMap = function(){
/*
	keymap like MS Excel offers
*/
this._key_events={
			k13_1_0:function(){
				this.editStop();
			},
			k13_0_1:function(){
				this.editStop();
				this._key_events.k38_0_0.call(this);
			},
			k13_0_0:function(){
				this.editStop();
				this.callEvent("onEnter",[(this.row?this.row.idd:null),(this.cell?this.cell._cellIndex:null)]);
				this._still_active=true;
				this._key_events.k40_0_0.call(this);
            },
            k9_0_0:function(){
				this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				if (this.cell && (this.cell._cellIndex+1)>=this._cCount) return;
				var z=this._getNextCell(null,1);
				if (z && this.row==z.parentNode){
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
			},
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				if (this.cell && (this.cell._cellIndex==0)) return;
				var z=this._getNextCell(null,-1);
				if (z && this.row==z.parentNode) {
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
            },
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            k27_0_0:function(){
            	this.editStop(true);
            	this._still_active=true;
            },
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,true);
	        },
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,true);
            }, 
			k38_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true);
	        },
			k40_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true);
            },
			k38_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
	        },
			k40_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
            },     
			k38_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd - 1; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
	        },
			k40_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
            },                   
			k40_0_0:function(){
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (this.editor) return false;
					var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
					var row = this._nextRow(rowInd, 1);

					if (row){
						master._r_select=null;
						this.selectCell(row, this.cell._cellIndex, true);
						if (master.pagingOn) master.showRow(row.idd);
					} else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
            },
            k36_0_0:function(){ //home
            	return this._key_events.k37_1_0.call(this);
            },
            k35_0_0:function(){ //ctrl-home
            	return this._key_events.k39_1_0.call(this);
            },            
            k36_1_0:function(){ //home
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true);
            },
            k35_1_0:function(){ //ctrl-end
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true);
            },  
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },                                  
			k38_0_0:function(){	
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
					if (this.editor) return false;
					if (!this.row.idd) return;
					var rowInd = this.getRowIndex(this.row.idd)+1;
					if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
						var nrow = this._nextRow(rowInd-1, -1);
						this.selectCell(nrow, this.cell._cellIndex, true);
						if (master.pagingOn && nrow) master.showRow(nrow.idd);
					} else {
						this._key_events.k33_0_0.apply(this,[]);
					}
				}
            },
            k_other:function(ev){ 
            	if (this.editor) return false;
            	if (!ev.ctrlKey && ev.keyCode>=40 && (ev.keyCode < 91 || (ev.keyCode >95 && ev.keyCode <111) || ev.keyCode > 187))
            		if (this.cell){
            			var c=this.cells4(this.cell);
            			if (c.isDisabled()) return false;
            			var t=c.getValue();
            			if (c.editable!==false) c.setValue("");
            			this.editCell();
            			if (this.editor) {
            				this.editor.val=t;
            				if (this.editor.obj && this.editor.obj.select)
            					this.editor.obj.select();
        				}
            			else c.setValue(t);
            		}
            }
		};

};

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_time(cell){

		this.base = eXcell_ed;
		this.base(cell)
		this.getValue = function(){
				return this.cell.innerHTML.toString();
		}
		this.setValue = function(val){
		var re = new RegExp(" ","i")
		val = val.replace(re,":")
		if((val=="")) val = "00:00"
		else
		{
			var re = new RegExp("[a-zA-Z]","i")
			var res = val.match(re)
			
			if(res) val = "00:00";
			else{
				var re = new RegExp("[0-9]+[\\.\\/;\\-,_\\]\\[\\?\\: ][0-9]+","i")
				var res = val.search(re)
				if(res!=-1){
					var re = new RegExp("[\\./\\;\\-\\,\\_\\]\\[ \\?]","i")
					val = val.replace(re,":")
				}
				else
				{
					var re = new RegExp("[^0-9]","i")
					res1 = val.search(re)
					if(res = val.match(re) ) { val = "00:00";}
					else
					{
					if(val.length == 1)
					{
						val = "00:0"+val;
					}
					else
					{
						if(parseInt(val) < 60) val = "00:"+val;
						else
						if(val.length < 5)
						{
							var minutes = parseInt(val);
							var hours =  Math.floor(minutes/60);
							minutes = minutes - 60*hours;
							var hours = hours.toString();
							var minutes = minutes.toString();
							while(hours.length < 2){
								hours = "0" + hours;
							}
							while(minutes.length < 2){
								minutes = "0" + minutes;
							}
							val = hours+":"+minutes;
						}
					}
					}
						
				}
			}
		}
		this.cell.innerHTML = val;
		}

		
	}
	   eXcell_time.prototype = new eXcell_ed;
	   //(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_sub_row(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	
	this.getValue = function(){
		return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row");
	}
	this._setState = function(m,v){
		(v||this.cell).innerHTML="<img src='"+this.grid.imgURL+m+"' width='18' height='18' />";
		(v||this.cell).firstChild.onclick=this.grid._expandMonolite;
	}
	this.open = function (){
		this.cell.firstChild.onclick(null,true)
	}
	this.close = function (){
		this.cell.firstChild.onclick(null,false,true)
	}
	this.isOpen = function(){
		return !!this.cell.parentNode._expanded;
	}
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.setContent = function(val){
		if (this.cell.parentNode._expanded){
			this.cell.parentNode._expanded.innerHTML=val;
			this.resize();
		}
		else{
			this.cell._previous_content=null;
			this.setValue(val);
			this.cell._sub_row_type=null
		}
			
	}
	this.resize = function(){
		this.grid._detectHeight(this.cell.parentNode._expanded,this.cell,this.cell.parentNode._expanded.scrollHeight);
	},
	this.isDisabled = function(){ return true; }
	this.getTitle = function(){ return this.grid.getUserData(this.cell.parentNode.idd,"__sub_row")?"click to expand|collapse":""; }
}
eXcell_sub_row.prototype = new eXcell;

function eXcell_sub_row_ajax(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="ajax";
			this.cell._previous_content = null;
		this._setState(val?"plus.gif":"blank.gif");
	}
}
eXcell_sub_row_ajax.prototype = new eXcell_sub_row;

function eXcell_sub_row_grid(cell){
	this.base=eXcell_sub_row;
	this.base(cell);
	
	this.setValue = function(val){
		if (val)
			this.grid.setUserData(this.cell.parentNode.idd,"__sub_row",val);
			this.cell._sub_row_type="grid";
		this._setState(val?"plus.gif":"blank.gif");
	}
	this.getSubGrid = function(){
		if (!cell._sub_grid) return null;
		return cell._sub_grid;
	}
}
eXcell_sub_row_grid.prototype = new eXcell_sub_row;

dhtmlXGridObject.prototype._expandMonolite=function(n,show,hide){
	var td=this.parentNode;
	var row=td.parentNode;
	var that=row.grid;
	
	if (n||window.event){
		if (!hide && !row._expanded) that.editStop();
		(n||event).cancelBubble=true;
	}
	
	var c=that.getUserData(row.idd,"__sub_row");
	
	if (!that._sub_row_editor)
    	that._sub_row_editor=new eXcell_sub_row(td);
	
	if (!c) return;
	
	if (row._expanded && !show){
		that._sub_row_editor._setState("plus.gif",td);
		td._previous_content=row._expanded;
		that.objBox.removeChild(row._expanded);
		row._expanded=false;
		row.style.height=(row.oldHeight||20)+"px";
		td.style.height=(row.oldHeight||20)+"px";	
		
		if (that._fake){
			that._fake.rowsAr[row.idd].style.height=(row.oldHeight||20)+"px";
			that._fake.rowsAr[row.idd].firstChild.style.height=(row.oldHeight||20)+"px";
		}
			
		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="middle";
			
		delete that._flow[row.idd];
		that._correctMonolite();
		row._expanded.ctrl=null;
	}else if (!row._expanded && !hide){
		that._sub_row_editor._setState("minus.gif",td);
		row.oldHeight=td.offsetHeight-4;
		if (td._previous_content){
			var d=td._previous_content;
			d.ctrl=td;
			that.objBox.appendChild(d);
			that._detectHeight(d,td,parseInt(d.style.height))	
		}
		else {
			var d=document.createElement("DIV");
			d.ctrl=td;
			if (td._sub_row_type)
				that._sub_row_render[td._sub_row_type](that,d,td,c);
			else
				d.innerHTML=c;
			d.style.cssText="position:absolute; left:0px; top:0px; overflow:auto; font-family:Tahoma; font-size:8pt; margin-top:2px; margin-left:4px;";
			d.className="dhx_sub_row";
			that.objBox.appendChild(d);
			that._detectHeight(d,td)			
		}
		

			
		
		if (!that._flow) {
			that.attachEvent("onGridReconstructed",function(){ 
				if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite();
				else this._correctMonolite(); 
			});
			that.attachEvent("onResizeEnd",function(){ this._correctMonolite(true); });
			that.attachEvent("onAfterCMove",function(){ this._correctMonolite(true); });
			that.attachEvent("onDrop",function(){ this._correctMonolite(true); });
			that.attachEvent("onBeforePageChanged",function(){ this._collapsMonolite(); return true; });
			that.attachEvent("onGroupStateChanged",function(){ this._correctMonolite(); return true; });
			that.attachEvent("onFilterEnd",function(){ this._collapsMonolite(); });
			that.attachEvent("onUnGroup",function(){ this._collapsMonolite(); });
			that.attachEvent("onPageChanged",function(){ this._collapsMonolite(); });
			
			that.attachEvent("onXLE",function(){ this._collapsMonolite(); });
			that.attachEvent("onClearAll",function(){ for (var i in this._flow) {
				if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
			}; this._flow=[]; });
			that.attachEvent("onEditCell",function(a,b,c){  if ((a!==2) && this._flow[b] && this.cellType[c]!="ch" && this.cellType[c]!="ra") this._expandMonolite.apply(this._flow[b].ctrl.firstChild,[0,false,true]);  return true; });
			that.attachEvent("onCellChanged",function(id,ind){ if (!this._flow[id]) return; 
				var c=this.cells(id,ind).cell;
				c.style.verticalAlign="top";
			});
			
			that._flow=[];
		}
		that._flow[row.idd]=d;
		that._correctMonolite();
		//d.style.top=row.offsetTop+20+"px";
		
		var padtop = that._srdh > 30 ? 11:3;
		if (that.multiLine) padtop = 0;

		for (var i=0; i<row.cells.length; i++)
			row.cells[i].style.verticalAlign="top";
		if (that._fake){
			var frow=that._fake.rowsAr[row.idd];
			for (var i=0; i<frow.cells.length; i++){
				frow.cells[i].style.verticalAlign="top";
			}
		}
		row._expanded=d;
	}
	if (that._ahgr)
		that.setSizes()
	if (that.parentGrid)
		that.callEvent("onGridReconstructed",[]);
	that.callEvent("onSubRowOpen",[row.idd,(!!row._expanded)]);
}
dhtmlXGridObject.prototype._sub_row_render={
    "ajax":function(that,d,td,c){
        d.innerHTML="Loading...";
        //d.innerHTML=that.i18n.loading;
        dhx4.ajax.get(c, function(xml){
            d.innerHTML=xml.xmlDoc.responseText;
            var z=xml.xmlDoc.responseText.match(/<script[^>]*>([^\f]+?)<\/script>/g);
            if (z)
                for (var i=0; i<z.length; i++)
                    eval(z[i].replace(/<([\/]{0,1})s[^>]*>/g,""));

			that._detectHeight(d,td)
			that._correctMonolite();
			that.setUserData(td.parentNode.idd,"__sub_row",xml.xmlDoc.responseText);
			td._sub_row_type=null;
			if (that._ahgr)
				that.setSizes()
			that.callEvent("onSubAjaxLoad",[td.parentNode.idd,xml.xmlDoc.responseText]);
		});
	},
	"grid":function(that,d,td,c){
		   td._sub_grid= new dhtmlXGridObject(d);
		   if (that.skin_name)
				td._sub_grid.setSkin(that.skin_name);
				
		   td._sub_grid.parentGrid=that;
		   td._sub_grid.imgURL = that.imgURL;
		   td._sub_grid.iconURL = that.iconURL;
		   td._sub_grid.enableAutoHeight(true);
		   td._sub_grid._delta_x = td._sub_grid._delta_y = null;
		   td._sub_grid.attachEvent("onGridReconstructed",function(){
		   		that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(this.ftr?this.ftr.offsetHeight:0));
		   		that._correctMonolite();
		   		this.setSizes();
		   		if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
	   	   })
		   if (!that.callEvent("onSubGridCreated",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])){
		   		td._sub_grid.objBox.style.overflow="hidden";
				td._sub_row_type=null;
		   } else {
			   td._sub_grid.load(c,function(){
					that._detectHeight(d,td,td._sub_grid.objBox.scrollHeight+td._sub_grid.hdr.offsetHeight+(td._sub_grid.ftr?td._sub_grid.ftr.offsetHeight:0));
					td._sub_grid.objBox.style.overflow="hidden";
					that._correctMonolite();
					td._sub_row_type=null;
					if (!that.callEvent("onSubGridLoaded",[td._sub_grid,td.parentNode.idd,td._cellIndex,c])) return;
					if (that._ahgr) that.setSizes();
					if (that.parentGrid) that.callEvent("onGridReconstructed",[]);
			  	});		   
			}
	}
}

dhtmlXGridObject.prototype._detectHeight=function(d,td,h){
	var l=td.offsetLeft+td.offsetWidth;
		d.style.left=l+"px";
		d.style.width=Math.max(0,td.parentNode.offsetWidth-l-4)+"px"
		var h=h||d.scrollHeight;
		d.style.overflow="hidden";
		d.style.height=h+"px";		
		var row=td.parentNode;
		td.parentNode.style.height=(row.oldHeight||20)+h*1+"px";	
		td.style.height=(row.oldHeight||20)+h*1+"px";	
		if (this._fake){
			var tr=this._fake.rowsAr[td.parentNode.idd];
			tr.style.height=(row.oldHeight||20)+h*1+"px";	
			tr.firstChild.style.height=(row.oldHeight||20)+h*1+"px";	
		}
}
dhtmlXGridObject.prototype._correctMonolite=function(mode){
	if (this._in_correction) return;
	this._in_correction=true;
	
	for (var a in this._flow)
		if (this._flow[a] && this._flow[a].tagName=="DIV")
			if (this.rowsAr[a]){			
				if (this.rowsAr[a].style.display=="none") {
					this.cells4(this._flow[a].ctrl).close();
					continue;
				}
				this._flow[a].style.top=this.rowsAr[a].offsetTop+(this.rowsAr[a].oldHeight||20)+"px";
				if (mode) {
					var l=this._flow[a].ctrl.offsetLeft+this._flow[a].ctrl.offsetWidth;
					this._flow[a].style.left=l+"px";
					this._flow[a].style.width=this.rowsAr[a].offsetWidth-l-4+"px"
				}
			}
			else{
				this._flow[a].ctrl=null;
				this.objBox.removeChild(this._flow[a]);
				delete this._flow[a];
			}

	this._in_correction=false;
}
dhtmlXGridObject.prototype._collapsMonolite=function(){
		for (var a in this._flow)
			if (this._flow[a] && this._flow[a].tagName=="DIV")
				if (this.rowsAr[a])
					this.cells4(this._flow[a].ctrl).close();
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: radio editor
*   @returns: dhtmlxGrid cell editor object
*   @type: public
*/
function eXcell_ra_str(cell){
   if (cell){
   this.base = eXcell_ra;
   this.base(cell)
   this.grid = cell.parentNode.grid;
	}
}
eXcell_ra_str.prototype = new eXcell_ch;
eXcell_ra_str.prototype.setValue = function(val){
                  this.cell.style.verticalAlign = "middle";//nb:to center checkbox in line
                  if (val){
                           val=val.toString()._dhx_trim();
                     if ((val=="false")||(val=="0")) val="";
                     }
                  if(val){
		    if (this.grid.rowsAr[this.cell.parentNode.idd])
                     for (var i=0;i<this.grid._cCount;i++) {
			if (i!==this.cell._cellIndex) {
                            var cell = this.grid.cells(this.cell.parentNode.idd,i);
                            if ((cell.cell._cellType||this.grid.cellType[cell.cell._cellIndex])!="ra_str") continue;
                            if (cell.getValue())
                               cell.setValue("0");
			}
                     }
                     val = "1";
                     this.cell.chstate = "1";
                  }else{
                     val = "0";
                     this.cell.chstate = "0"
                  }
                  this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra_str(this.parentNode).changeState()'>",this.cell.chstate);
               }
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function(grid){
	if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;
	
	grid._col_combos = [];
	for (var i=0; i<grid._cCount; i++) {
		if(grid.cellType[i].indexOf("combo") == 0) {
			grid._col_combos[i] = eXcell_combo.prototype.initCombo.call({grid:grid},i);
		}
	}
	
	if (!grid._loading_handler_set) {
		grid._loading_handler_set = grid.attachEvent("onXLE", function(a,b,c,xml,type){
				if (type != "xml") return;
				eXcell_combo.prototype.fillColumnCombos(this,xml);
				this.detachEvent(this._loading_handler_set);
				this._loading_handler_set = null;
		});
	}
});


function eXcell_combo(cell) {
	
	if (!cell) return;
	
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";
	
	this.edit = function(){
		
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		
		this.val = this.getValue();
		var val = this.getText();
		if (this.cell._clearCell) val="";
		this.cell.innerHTML = "";
		
		if (!this.cell._brval) {
			this.combo = (this.grid._realfake?this.grid._fake:this.grid)._col_combos[this.cell._cellIndex];
		} else {
			this.combo = this.cell._brval;
		}
		this.cell.appendChild(this.combo.DOMParent);

		this.combo.DOMParent.style.margin = "0";
		
		this.combo.DOMelem_input.focus();
		this.combo.setSize(this.cell.offsetWidth-2);
		if (!this.combo._xml) {
			if (this.combo.getIndexByValue(this.cell.combo_value)!=-1) {
				this.combo.selectOption(this.combo.getIndexByValue(this.cell.combo_value));
			} else {
				if (this.combo.getOptionByLabel(val)) {
					this.combo.selectOption(this.combo.getIndexByValue(this.combo.getOptionByLabel(val).value));
				} else {
					this.combo.setComboText(val);
				}
			}
		} else {
			this.combo.setComboText(val);
		}
		this.combo.openSelect();
	}
	
	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}
	
	this.getValue = function(val){
		return this.cell.combo_value||"";
	}
	
	this.getText = function(val){
		var c = this.cell;
		if (this._combo_pre == "" && c.childNodes[1]) {
			c = c.childNodes[1];
		} else {
			c.childNodes[0].childNodes[1];
		}
		return (_isIE ? c.innerText : c.textContent);
	}
	
	this.setValue = function(val){
		
		if (typeof(val) == "object"){
			
			this.cell._brval = this.initCombo();
			var index = this.cell._cellIndex;
			var idd = this.cell.parentNode.idd;
			if (!val.firstChild) {
				this.cell.combo_value = "&nbsp;";
				this.cell._clearCell = true;
			} else {
				this.cell.combo_value = val.firstChild.data;
			}
			this.setComboOptions(this.cell._brval, val, this.grid, index, idd);
			
		} else {
			this.cell.combo_value = val;
			var cm = null;
			if ((cm = this.cell._brval) && (typeof(this.cell._brval) == "object")) {
				val = (cm.getOption(val)||{}).text||val;
			} else if (cm = this.grid._col_combos[this.cell._cellIndex]||((this.grid._fake) && (cm = this.grid._fake._col_combos[this.cell._cellIndex]))) {
				val = (cm.getOption(val)||{}).text||val;
			}
			
			if ((val||"").toString()._dhx_trim()=="") val = null;
			
			if (val !== null) {
				this.setComboCValue(val);
			} else {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell = true;
			}
		}
	}
	
	this.detach = function(){
		var p = this.combo.getParent();
		if (p.parentNode == this.cell) {
			this.cell.removeChild(p);
		} else {
			return false;
		}
		var val = this.cell.combo_value;
		this.combo._confirmSelect("blur");
		
		if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()=="") {
			this.setComboCValue("&nbsp;");
			this.cell._clearCell=true;
		} else {
			this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
			this.cell._clearCell = false;
		}
		
		this.cell.combo_value = this.combo.getActualValue();
		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}


eXcell_combo.prototype = new eXcell;
eXcell_combo_v = function(cell){
	var combo = new eXcell_combo(cell);
	combo._combo_pre = "<img src='"+(window.dhx_globalImgPath?window.dhx_globalImgPath:this.grid.imgURL)+"combo_select"+(dhtmlx.skin?"_"+dhtmlx.skin:"")+".gif' class='dhxgrid_combo_icon'/>";
	return combo;
};

eXcell_combo.prototype.initCombo = function(index){
	
	var container = document.createElement("DIV");
	container.className = "dhxcombo_in_grid_parent";
	var type = this.grid.defVal[arguments.length?index:this.cell._cellIndex];
	var combo = new dhtmlXCombo(container, "combo", 0, type);
	this.grid.defVal[arguments.length?index:this.cell._cellIndex] = "";
	
	var grid = this.grid;
	combo.DOMelem.onmousedown = combo.DOMelem.onclick = function(e){
		e = e||event;
		e.cancelBubble = true;
	};
	combo.DOMelem.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		return true;
	};
	
	this.grid.attachEvent("onScroll", function(){
		if (combo._isListVisible()) combo._hideList();
	});
	
	combo.attachEvent("onKeyPressed",function(ev){
		if (ev==13 || ev==27) {
			grid.editStop();
			if (grid._fake) grid._fake.editStop();
		}
	});
	
	return combo;
	
};

eXcell_combo.prototype.fillColumnCombos = function(grid,xml){
	if (!xml) return;
	var top  = dhx4.ajax.xmltop("rows", xml, -1);
	if (top && top.tagName !== "DIV"){
		grid.combo_columns = grid.combo_columns||[];
		columns = dhx4.ajax.xpath("//column", top);
		for (var i=0; i<columns.length; i++) {
			if ((columns[i].getAttribute("type")||"").indexOf("combo") == 0) {
				grid.combo_columns[grid.combo_columns.length] = i;
				this.setComboOptions(grid._col_combos[i], columns[i], grid, i);
			}
		}
	}
};

eXcell_combo.prototype.setComboCValue = function(value, value2) {
   	if (this._combo_pre != "") {
		var height = (this.cell.offsetHeight?this.cell.offsetHeight+"px":0);
   		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;'>"+this._combo_pre+"<span>"+value+"</span></div>";
   	}
   	if (arguments.length > 1) {
  		this.setCValue(value,value2);
	} else {
		this.setCValue(value);
	}
};

eXcell_combo.prototype.setComboOptions = function(combo, obj, grid, index, idd) {
	
	if (window.dhx4.s2b(obj.getAttribute("xmlcontent"))) {
		
		if (!obj.getAttribute("source")) {
			options = obj.childNodes;
			var _optArr = [];
			for (var i=0; i < options.length; i++){
				if(options[i].tagName =="option"){
					var text_opt = options[i].firstChild? options[i].firstChild.data:"";
					_optArr[_optArr.length]= [options[i].getAttribute("value"),text_opt, (options[i].getAttribute("css")||"")];
				}
			}
			combo.addOption(_optArr)
			if(arguments.length == 4){
				grid.forEachRowA(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType&&(c.cell._cellIndex==index)){
							if(c.cell.combo_value=="") c.setComboCValue("&nbsp;","");
							else{
								if(!combo.getOption(c.cell.combo_value))
									c.setComboCValue(c.cell.combo_value);
								else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							}
						}
				});	
			}
			else {
				var c = (this.cell)?this:grid.cells(idd,index);
				if(obj.getAttribute("text")) {
					if(obj.getAttribute("text")._dhx_trim()=="") c.setComboCValue("&nbsp;",""); 
					else c.setComboCValue(obj.getAttribute("text")); 
				}
				else{
					if((!c.cell.combo_value)||(c.cell.combo_value._dhx_trim()=="")) c.setComboCValue("&nbsp;","");
					else{
						if(!combo.getOption(c.cell.combo_value))
							c.setComboCValue(c.cell.combo_value);
						else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					}
				}
			}
			
		}
	}
	
	if (obj.getAttribute("source")) {
		if (obj.getAttribute("auto") && window.dhx4.s2b(obj.getAttribute("auto"))) {
			
			if (obj.getAttribute("xmlcontent")) {
				var c = (this.cell)?this:grid.cells(idd,index);
				if (obj.getAttribute("text")) c.setComboCValue(obj.getAttribute("text"));
			} else {
				grid.forEachRowA(function(id){
					var c = grid.cells(id,index);
					if (!c.cell._brval && !c.cell._cellType) {
						var str = c.cell.combo_value.toString();
						if (str.indexOf("^") != -1) {
							var arr = str.split("^");
							c.cell.combo_value = arr[0];
							c.setComboCValue(arr[1]);
						}
					}
				});
			}
			combo.enableFilteringMode(true, obj.getAttribute("source"), window.dhx4.s2b(obj.getAttribute("cache")||true), window.dhx4.s2b(obj.getAttribute("sub")||false));
			
		} else {
			
			var that = this;
			var length = arguments.length; 
			combo.load(obj.getAttribute("source"), function(){
				if (length == 4) {
					grid.forEachRow(function(id){
						var c = grid.cells(id,index);
						if (!c.cell._brval && !c.cell._cellType) {
							if (combo.getOption(c.cell.combo_value)) {
								c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							} else {
								if ((c.cell.combo_value||"").toString()._dhx_trim() == "") {
									c.setComboCValue("&nbsp;","");
									c.cell._clearCell=true;
								} else {
									c.setComboCValue(c.cell.combo_value);
								}
							}
						}
					});
				} else {
					//var c = (that.cell)? that : grid.cells(idd,index);
					var c = grid.cells(idd,index);
					//c.setCValue(obj.getAttribute("text"));
					if (combo.getOption(c.cell.combo_value)) {
						c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					} else {
						c.setComboCValue(c.cell.combo_value);
					}
				}
			});
			
		}
	}
	if (!obj.getAttribute("auto") || !window.dhx4.s2b(obj.getAttribute("auto"))) {
		if (obj.getAttribute("editable") && !window.dhx4.s2b(obj.getAttribute("editable"))) combo.readonly(true);
		if (obj.getAttribute("filter") && window.dhx4.s2b(obj.getAttribute("filter"))) combo.enableFilteringMode(true);
	}
	
};

eXcell_combo.prototype.getCellCombo = function() {
	
	if (this.cell._brval) return this.cell._brval;
	
	this.cell._brval = this.initCombo();
	return this.cell._brval;
	
};

eXcell_combo.prototype.refreshCell = function() {
	this.setValue(this.getValue());
};

dhtmlXGridObject.prototype.getColumnCombo = function(index) {
	if (this._col_combos && this._col_combos[index]) return this._col_combos[index];
	
	if (!this._col_combos) this._col_combos = [];
	this._col_combos[index] = eXcell_combo.prototype.initCombo.call({grid:this},index);
	return this._col_combos[index];
	
};

dhtmlXGridObject.prototype.refreshComboColumn = function(index) {
	this.forEachRow(function(id){
		if (this.cells(id,index).refreshCell) this.cells(id,index).refreshCell();
	});
};


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: multi select list editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_clist(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();
                    var a=(this.cell._combo||this.grid.clists[this.cell._cellIndex]);
                    if (!a) return;
					this.obj = document.createElement("DIV");
                    var b=this.val.split(",");
                    var text="";

                    for (var i=0; i<a.length; i++){
                        var fl=false;
                        for (var j=0; j<b.length; j++)
                            if (a[i]==b[j]) fl=true;
                        if (fl)
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"' checked='true' /><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                        else
                         text+="<div><input type='checkbox' id='dhx_clist_"+i+"'/><label for='dhx_clist_"+i+"'>"+a[i]+"</label></div>";
                    }
                    text+="<div><input type='button' value='"+(this.grid.applyButtonText||"Apply")+"' style='width:100px; font-size:8pt;' onclick='this.parentNode.parentNode.editor.grid.editStop();'/></div>"

                    this.obj.editor=this;
                    this.obj.innerHTML=text;
                    document.body.appendChild(this.obj);
                    this.obj.style.position="absolute";
					this.obj.className="dhx_clist";
					this.obj.onclick=function(e){  (e||event).cancelBubble=true; return true; };
					var arPos = this.grid.getPosition(this.cell);
                    this.obj.style.left=arPos[0]+"px";
                    this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

                    this.obj.getValue=function(){
                        var text="";
                        for (var i=0; i<this.childNodes.length-1; i++)
                            if (this.childNodes[i].childNodes[0].checked){
                                if (text) text+=", ";
                                    text+=this.childNodes[i].childNodes[1].innerHTML;
                                }
                        return text.replace(/&amp;/g,"&");
                    }
				}
	this.getValue = function(){
		//this.grid.editStop();
		if (this.cell._clearCell) return "";
		return this.cell.innerHTML.toString()._dhx_trim().replace(/&amp;/g,"&").replace(/, /g, ",");
	}

	this.detach = function(val){
                    if (this.obj){
    					this.setValue(this.obj.getValue());
                        this.obj.editor=null;
                        this.obj.parentNode.removeChild(this.obj);
                        this.obj=null;
                        }
					return this.val!=this.getValue();
				}
}
eXcell_clist.prototype = new eXcell;

eXcell_clist.prototype.setValue = function(val){
						if (typeof(val)=="object"){
							var optCol=dhx4.ajax.xpath("./option",val);
                            if (optCol.length)
                            	this.cell._combo=[];
                                for (var j=0;j<optCol.length; j++)
									this.cell._combo.push(optCol[j].firstChild?optCol[j].firstChild.data:"");
							val=val.firstChild.data;
						}
						if (val==="" || val === this.undefined){
							this.setCTxtValue(" ",val);
							this.cell._clearCell=true;
						}
						else{
                            val = val.replace(/,[ ]*/g, ", ");
                        	this.setCTxtValue(val);
                        	this.cell._clearCell=false;
                        }
					}

/**
*	@desc: register list of values for CList cell
*	@param: col - index of CList collumn
*	@param: list - array of list data
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.registerCList=function(col,list){
    if (!this.clists) this.clists=new Array();
	if (typeof(list)!="object") list=list.split(",");
    this.clists[col]=list;
    }

//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: calculator editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_calck(cell){
	try{
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
	}catch(er){}
	this.edit = function(){
					this.val = this.getValue();

					var arPos = this.grid.getPosition(this.cell);
					this.obj = new calcX(arPos[0],arPos[1]+this.cell.offsetHeight,this,this.val);

				}
	this.getValue = function(){
		//this.grid.editStop();
    	return this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(),this.cell._cellIndex);
	}
	this.detach = function(){
                    if (this.obj) {
						this.setValue(this.obj.inputZone.value);
						this.obj.removeSelf();
						}
                    this.obj=null;
					return this.val!=this.getValue();
				}
}
eXcell_calck.prototype = new eXcell;
eXcell_calck.prototype.setValue = function(val){
      if(!val || val.toString()._dhx_trim()=="")
          val="0"
      this.setCValue(this.grid._aplNF(val,this.cell._cellIndex),val);
}

function calcX(left,top,onReturnSub,val){
	this.top=top||0;
	this.left=left||0;
	this.onReturnSub=onReturnSub||null;

	this.operandA=0;
	this.operandB=0;
	this.operatorA="";
	this.state=0;
	this.dotState=0;


this.calckGo=function(){
	return (eval(this.operandA+"*1"+this.operatorA+this.operandB+"*1"));
};

this.isNumeric=function(str){
	return ((str.search(/[^1234567890]/gi)==-1)?(true):(false));
};
this.isOperation=function(str){
	return ((str.search(/[^\+\*\-\/]/gi)==-1)?(true):(false));
}
	this.onCalcKey=function(e)
	{
		that=this.calk;
		var z=this.innerHTML;
		var rZone=that.inputZone;
		if (((that.state==0)||(that.state==2))&&(that.isNumeric(z)))  	if (rZone.value!="0") rZone.value+=z; else rZone.value=z;
		if ((((that.state==0)||(that.state==2))&&(z=='.'))&&(that.dotState==0)) { that.dotState=1; rZone.value+=z; }
		if ((z=="C"))  { rZone.value=0; that.dotState=0; that.state=0; }
		if ((that.state==0)&&(that.isOperation(z)))  { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if ((that.state==2)&&(that.isOperation(z)))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if ((that.state==2)&&(z=="="))  { that.operandB=rZone.value; rZone.value=that.calckGo(); that.operatorA=z;  that.operandA=rZone.value; that.state=3; }
		if ((that.state==1)&&(that.isNumeric(z))) { rZone.value=z; that.state=2;  that.dotState=0 }
		if ((that.state==3)&&(that.isNumeric(z))) { rZone.value=z; that.state=0; }
		if ((that.state==3)&&(that.isOperation(z))) { that.operatorA=z;  that.operandA=rZone.value; that.state=1; }
		if (z=="e") { rZone.value=Math.E;  if (that.state==1) that.state=2; that.dotState=0   }
		if (z=="p") { rZone.value=Math.PI; if (that.state==1) that.state=2; that.dotState=0  }
		if (z=="Off") that.topNod.parentNode.removeChild(that.topNod);

		if (e||event) (e||event).cancelBubble=true;
	}
	this.sendResult=function(){
		that=this.calk;
		if (that.state==2){
            var rZone=that.inputZone;
            that.operandB=rZone.value;
            rZone.value=that.calckGo();
            that.operatorA=z;
            that.operandA=rZone.value;
            that.state=3; }
		var z=that.inputZone.value;

		that.topNod.parentNode.removeChild(that.topNod);
		that.onReturnSub.grid.editStop(false);
	};
    this.removeSelf=function(){
        if (this.topNod.parentNode)
        	this.topNod.parentNode.removeChild(this.topNod);
    }
	this.keyDown=function(){ this.className="calcPressed"; };
	this.keyUp=function(){ this.className="calcButton"; };
	this.init_table=function(){
		var table=this.topNod.childNodes[0];
		if ((!table)||(table.tagName!="TABLE")) return;
		for (i=1; i<table.childNodes[0].childNodes.length; i++)
			for (j=0; j<table.childNodes[0].childNodes[i].childNodes.length; j++)
			{
				table.childNodes[0].childNodes[i].childNodes[j].onclick=this.onCalcKey;
				table.childNodes[0].childNodes[i].childNodes[j].onmousedown=this.keyDown;
				table.childNodes[0].childNodes[i].childNodes[j].onmouseout=this.keyUp;
				table.childNodes[0].childNodes[i].childNodes[j].onmouseup=this.keyUp;
				table.childNodes[0].childNodes[i].childNodes[j].calk=this;
			}
		this.inputZone=this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0];
		if (this.onReturnSub)
		{
			this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].onclick=this.sendResult;
			this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].calk=this;
		}
		else this.topNod.childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[0].childNodes[1].innerHTML="";
	}
	this.drawSelf=function(){
		var div=document.createElement("div");
		div.className="calcTable";
		div.style.position="absolute";
		div.style.top=this.top+"px";
		div.style.left=this.left+"px";
		div.innerHTML="<table cellspacing='0' id='calc_01' class='calcTable'><tr><td colspan='4'><table cellpadding='1' cellspacing='0' width='100%'><tr><td width='100%' style='overflow:hidden;'><input style='width:100%' class='calcInput' value='0' align='right' readonly='true' style='text-align:right'></td><td class='calkSubmit'>=</td></tr></table></td></tr><tr><td class='calcButton' width='25%'>Off</td><td class='calcButton' width='25%'>p</td><td class='calcButton' width='25%'>e</td><td class='calcButton' width='25%'>/</td></tr><tr><td class='calcButton'>7</td><td class='calcButton'>8</td><td class='calcButton'>9</td><td class='calcButton'>*</td></tr><tr><td class='calcButton'>4</td><td class='calcButton'>5</td><td class='calcButton'>6</td><td class='calcButton'>+</td></tr><tr><td class='calcButton'>1</td><td class='calcButton'>2</td><td class='calcButton'>3</td><td class='calcButton'>-</td></tr><tr><td class='calcButton'>0</td><td class='calcButton'>.</td><td class='calcButton'>C</td><td class='calcButton'>=</td></tr></table>";
		div.onclick=function(e){ (e||event).cancelBubble=true; };
		document.body.appendChild(div);
		this.topNod=div;
	}

	this.drawSelf();
	this.init_table();

    if (val){
            var rZone=this.inputZone;
            rZone.value=val*1;
            this.operandA=val*1;
            this.state=3;
            }
	return this;
};
//(c)dhtmlx ltd. www.dhtmlx.com

/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: switch current row state (collapse/expand) tree grid row
*   @param: obj - row object
*   @type: private
*/
dhtmlXGridObject.prototype._updateTGRState=function(z){ 
	if (!z.update || z.id==0) return;
	if (this.rowsAr[z.id].imgTag)
	this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
	z.update=false;
}


dhtmlXGridObject.prototype.doExpand=function(obj){  
	this.editStop();
    var row = obj.parentNode.parentNode.parentNode;
	var r=this._h2.get[row.idd];
	if (!this.callEvent("onOpen",[row.idd,(r.state=="plus"?-1:1)])) return;
    if(r.state=="plus")
      this.expandKids(row)
    else
   	  if((r.state=="minus")&&(!r._closeable))
          this.collapseKids(row)
}


dhtmlXGridObject.prototype._createHierarchy=function(){  
	if (!this._emptyLineImg)
		this._emptyLineImg =  "blank";

	return new dhtmlxHierarchy({ _emptyLineImg : this._emptyLineImg });
}

function dhtmlxHierarchy(config){
		var z={id:0, childs:[], level:-1, parent:null, index:0, state:config._emptyLineImg};
		this.order=[z];
		this.get={"0":z};

		this.swap=function(a,b){
			var p=a.parent;
			var z=a.index;
			p.childs[z]=b;
			p.childs[b.index]=a;
			a.index=b.index; b.index=z;
		}
		this.forEachChildF=function(id,funct,that,funct2){
			var z=this.get[id];
			for (var i=0; i<z.childs.length; i++){
				if (!funct.apply((that||this),[z.childs[i]])) continue;
				if (z.childs[i].childs.length) this.forEachChildF(z.childs[i].id,funct,that,funct2);
				if (funct2) funct2.call((that||this),z.childs[i]);
			}
		}
		this.forEachChild=function(id,funct,that){
				var z=this.get[id];
				for (var i=0; i<z.childs.length; i++){
					funct.apply((that||this),[z.childs[i]]);
					if (z.childs[i].childs.length) this.forEachChild(z.childs[i].id,funct,that);
				}
		}
		this.change=function(id,name,val){
			var z=this.get[id];
			if (z[name]==val) return;
				z[name]=val;
				z.update=true;
		}
		this.add=function(id,parentId){ 
			return this.addAfter(id,parentId);
		}
		this.addAfter=function(id,parentId,afterId,fix){  
			var z=this.get[parentId||0];
			if (afterId)
				var ind=this.get[afterId].index+(fix?0:1);
			else var ind=z.childs.length;
			
			var x={id:id, childs:[], level:z.level+1, parent:z, index:ind, state:config._emptyLineImg}
			if (z.state==config._emptyLineImg)  this.change(parentId,"state",(parentId==0?"minus":"plus"));
			
			if (afterId){
				for (var i=ind; i<z.childs.length; i++) z.childs[i].index++;
				z.childs=z.childs.slice(0,ind).concat([x]).concat(z.childs.slice(ind,z.childs.length));
			}else
				z.childs.push(x);
			this.get[id]=x;
			return x;
		}
		this.addBefore=function(id,parentId,beforeId){
			return this.addAfter(id,parentId,beforeId,true)
		}		
		this.remove=function(id){  
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
			z.childs=[];	
			z.parent.childs=z.parent.childs.slice(0,z.index).concat(z.parent.childs.slice(z.index+1));				
			for (var i=z.index; i<z.parent.childs.length; i++)
				z.parent.childs[i].index--;
			delete this.get[id];
		}
		this.deleteAll=function(id){
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
				
			z.childs=[];				
			delete this.get[id];
		}		
		
		return this;
	}

dhtmlXGridObject.prototype._getOpenLenght=function(id,start){
	
	var z=this._h2.get[id].childs;
	start+=z.length;
	for (var i=0; i<z.length; i++)
		if (z[i].childs.length && z[i].state=='minus')
			start+=this._getOpenLenght(z[i].id,0);
	return start;
}
/**
*   @desc: close row of treegrid (removes kids from dom)
*   @param: curRow - row to process kids of
*   @type: private
*/
dhtmlXGridObject.prototype.collapseKids=function(curRow){ 
	var r=this._h2.get[curRow.idd];
    if (r.state!="minus") return;
    if (!this.callEvent("onOpenStart",[curRow.idd,1])) return;

    var start = curRow.rowIndex;
    //why Safari doesn't support standards?
    if (start<0) start=this.rowsCol._dhx_find(curRow)+1;

   	this._h2.change(r.id,"state","plus");
   	this._updateTGRState(r);

    if (this._srnd || this.pagingOn){
    	this._h2_to_buff();
    	this._renderSort();
    } else {
    var len=this._getOpenLenght(this.rowsCol[start-1].idd,0);
    for (var i=0; i<len; i++)
    	this.rowsCol[start+i].parentNode.removeChild(this.rowsCol[start+i]);
    this.rowsCol.splice(start,len);
	}

    //if (this._cssEven && !this._cssSP)
    this.callEvent("onGridReconstructed",[]);

    this.setSizes();
    this._h2_to_buff();
    this.callEvent("onOpenEnd",[curRow.idd,-1]);
}



dhtmlXGridObject.prototype._massInsert=function(r,start,ind,skip){  
	var anew=[];
	var par=(_isKHTML?this.obj:this.obj.rows[0].parentNode)
	this._h2_to_buff();
	if (this._srnd || this.pagingOn) return this._renderSort();
	var len=this._getOpenLenght(r.id,0);
	for(var i=0;i<len;i++){
		var ra=this.render_row(ind+i);
		if (start)
			start.parentNode.insertBefore(ra,start);
		else
			par.appendChild(ra);
		anew.push(ra)
		}
	this.rowsCol=dhtmlxArray(this.rowsCol.slice(0,ind).concat(anew).concat(this.rowsCol.slice(ind)));
	
	return r.childs.length+anew.length;
}
/**
*   @desc: change parent of row, correct kids collections
*   @param: curRow - row to process
*   @type: private
*/
dhtmlXGridObject.prototype.expandKids=function(curRow,sEv){

	var r=this._h2.get[curRow.idd];
	if ((!r.childs.length)&&(!r._xml_await)) return;
	if (r.state!="plus") return;
    
    
    if (!r._loading && !sEv)
    	if (!this.callEvent("onOpenStart",[r.id,-1])) return;
        


   var start = this.getRowIndex(r.id)+1;
   if(r.childs.length){
        r._loading=false;
        this._h2.change(r.id,"state","minus")
        this._updateTGRState(r);
		var len=this._massInsert(r,this.rowsCol[start],start);
		
		//if (this._cssEven && !this._cssSP)
		this.callEvent("onGridReconstructed",[]);
			

   }else{	
        if (r._xml_await){
			r._loading=true;
			if (this.callEvent("onDynXLS",[r.id]))
				this.load(this.kidsXmlFile+""+(this.kidsXmlFile.indexOf("?")!=-1?"&":"?")+"id="+encodeURIComponent(r.id), this._data_type);
        }
   }
    this.setSizes();
    if (!r._loading)
    this.callEvent("onOpenEnd",[r.id,1]);
    this._fixAlterCss();
}

dhtmlXGridObject.prototype.kidsXmlFile = "";



/**
*   @desc: sorts treegrid by specified column
*   @param: col - column index
*   @param:   type - str.int.date
*   @param: order - asc.desc
*   @type: public
*   @edition: Professional
*   @topic: 2,3,5,9
*/
dhtmlXGridObject.prototype.sortTreeRows = function(col,type,order){
				var amet="getValue";
				if (this.cells5({parentNode:{grid:this}},this.getColType(col)).getDate){ //FIXME! move inside cells5 in 2.2
					amet="getDate";
					type="str";
				}		
					

	            this.forEachRow(function(id){
                	var z=this._h2.get[id];
                	if (!z) return;
                	
                	var label=this._get_cell_value(z.buff,col,amet);
                	if(type=='int'){
						   z._sort=parseFloat(label);
						   z._sort=isNaN(z._sort)?-99999999999999:z._sort;
                     }else
                        z._sort=label;
                	});
                	
				var self=this;
				var pos=1; var neg=-1;
				if (order=="des") { pos=-1; neg=1; }
					
				var funct=null;
				if (typeof type == "function")
					funct = function(a,b){
						return type(a._sort, b._sort, order, a.id, b.id);
					}
				else {
	                if(type=='cus')
    	                 funct=function(a,b){
                            return self._customSorts[col](a._sort,b._sort,order,a.id,b.id);
                         };
     	
                   if(type=='str')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='int')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='date')
                     funct=function(a,b){return (Date.parse(new Date(a._sort||"01/01/1900"))-Date.parse(new Date(b._sort||"01/01/1900")))*pos}
                  }
                  this._sortTreeRows(funct,0);
                  this._renderSort(0,true);

            this.callEvent("onGridReconstructed",[]);
               
}

dhtmlXGridObject.prototype._sortTreeRows = function(funct,id){
				var ar=this._h2.get[id].childs;
				if (this.rowsCol.stablesort)
					this.rowsCol.stablesort.call(ar,funct);
				else
					ar.sort(funct);
					
				for (var i=0; i<ar.length; i++){
					if (ar[i].childs.length) 
						this._sortTreeRows(funct,ar[i].id);
					ar[i].index=i;
				}
};
dhtmlXGridObject.prototype._renderSort = function(id,mode){ 
	this._h2_to_buff();
	var top=this.objBox.scrollTop;
	this._reset_view();
	this.objBox.scrollTop=top;
};

dhtmlXGridObject.prototype._fixAlterCssTGR = function(){ 
if (!this._realfake)	
	this._h2.forEachChild(0,function(x){
		if (x.buff.tagName=="TR"){
			var cs=(this._cssSP?(x.level%2):(x.index%2))?this._cssUnEven:this._cssEven;
			this.rowsAr[x.id].className=(cs + (this._cssSU?(" "+cs+"_"+x.level):""))+" "+(this.rowsAr[x.id]._css||"")+((this.rowsAr[x.id].className.indexOf("rowselected") != -1)?" rowselected":"");
		}
	},this);
}
dhtmlXGridObject.prototype.moveRowUDTG = function(id,dir){ 
	var x=this._h2.get[id];
	var p=x.parent.childs[x.index+dir]
	if ((!p) || (p.parent!=x.parent)) return;
	var state=[x.state,p.state];
	this.collapseKids(this.rowsAr[x.id]);
	this.collapseKids(this.rowsAr[p.id]);	
	var ind = this.rowsCol._dhx_find(this.rowsAr[id]);
	var bInd = this.rowsBuffer._dhx_find(this.rowsAr[id]);
	
	var nod=this.obj.rows[0].parentNode.removeChild(this.rowsCol[ind]);	
	var tar=this.rowsCol[ind+((dir==1)?2:dir)];
	if (tar)
		tar.parentNode.insertBefore(nod,tar);
	else
		this.obj.rows[0].parentNode.appendChild(nod);
	this.rowsCol._dhx_swapItems(ind,ind+dir)
	this.rowsBuffer._dhx_swapItems(bInd,bInd+dir);
	this._h2.swap(p,x);
	
	
	if (state[0]=="minus") this.expandKids(this.rowsAr[x.id]);
	if (state[1]=="minus") this.expandKids(this.rowsAr[p.id]);	
	
	this._fixAlterCss(Math.min(ind,ind+dir));
}

/**
*   @desc: TreeGrid cell constructor (only for TreeGrid package)
*   @param: cell - cell object
*   @type: public
*/
function eXcell_tree(cell){
   if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
   }
   this.isDisabled = function(){ return this.cell._disabled||this.grid._edtc; }
   this.edit = function(){
        if ((this.er)||(this.grid._edtc)) return;
        this.er=this.cell.parentNode.valTag;
        this.val=this.getLabel();
        this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
        this.er.innerHTML="<"+this.cell.atag+" class='dhx_combo_edit' type='text' style='height:"+(this.cell.offsetHeight-4)+"px;line-height:"+(this.cell.offsetHeight-6)+"px; width:100%; border:0px; margin:0px; padding:0px; overflow:hidden;'></"+this.cell.atag+">";
        this.er.childNodes[0].onmousedown = function(e){(e||event).cancelBubble = true}
        this.er.childNodes[0].onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
        this.er.className+=" editable";
        this.er.firstChild.onclick = function(e){(e||event).cancelBubble = true};
        this.er.firstChild.value=this.val;
        this.obj=this.er.firstChild;
		this.er.firstChild.style.width=Math.max(0,this.cell.offsetWidth-this.er.offsetLeft-2)+"px";
        this.er.firstChild.focus();
        if (_isIE)
			this.er.firstChild.focus();
    }
   this.detach = function(){
        if (!this.er) return;
            this.setLabel(this.er.firstChild.value);
            this.er.className=this.er.className.replace("editable","");
            var z=(this.val!=this.er.innerHTML);

			this.obj=this.er=null;
        return (z);
    }
   this.getValue = function(){
   		return this.getLabel();
   }

    
    /**
    *   @desc: get image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.setImage = function(url){
        this.cell.parentNode.imgTag.nextSibling.src=this.grid.iconURL+url;
        this.grid._h2.get[this.cell.parentNode.idd].image=url;
   }
   this.setIcon = function(icon){
		this.grid._h2.get[this.cell.parentNode.idd].icon = icon;
		this.cell.parentNode.imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
   }
    /**
    *   @desc: set image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.getImage = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].image;
   }
   this.getIcon = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].icon;
   }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.setLabel = function(val){
                  this.setValueA(val);
            }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.getLabel = function(val){
     return this.cell.parentNode.valTag.innerHTML;
    }
}
    /**
    *   @desc: set value of grid item
    *   @param: val  - new value (for treegrid this method only used while adding new rows)
    *   @type: private
    */
	
eXcell_tree.prototype = new eXcell;
    /**
    *   @desc: set label of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   eXcell_tree.prototype.setValueA = function(content){
   		this.cell.parentNode.valTag.innerHTML=content;
		this.grid.callEvent("onCellChanged",[this.cell.parentNode.idd,this.cell._cellIndex,content])
    }
	eXcell_tree.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.iconTree==null)||(this.grid._tgc.iconTree!=this.grid.iconTree)){
			var _tgc={};
			_tgc.spacer="<img src='"+this.grid.iconTree+"blank.gif'  align='top' class='space'>";
			_tgc.imst="<img class='grid_collapse_icon' src='"+this.grid.iconTree;
			_tgc.imsti="<img style='padding-top:2px;'  src='"+(this.grid.iconURL||this.grid.iconTree);
			_tgc.imact="' align='top' onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div class='treegrid_cell' style='overflow:hidden; white-space : nowrap; line-height:23px; height:"+(_isIE?21:23)+"px;'>";
			
			_tgc.itemim="' align='top' "+(this.grid._img_height?(" height=\""+this.grid._img_height+"\""):"")+(this.grid._img_width?(" width=\""+this.grid._img_width+"\""):"")+" >";
			_tgc.itemne="<span id='nodeval'>";
			_tgc.close="</span></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) { 
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.icon=row.icon||(this.cell._attrs["icon"]||(this.grid.iconset?"file-o":""));

		row.label=valAr;
               
        var html=[_tgc.start];
		
        for(var i=0;i<row.level;i++)
        	html.push(_tgc.spacer);
        
       //if has children
        if(row.has_kids){
        	html.push(_tgc.plus);
        	row.state="plus"
        	}
        else
        	html.push(_tgc.imst+row.state+".gif"+_tgc.imact);
                        
		if (!row.icon){
			html.push(_tgc.imsti);
			html.push(row.image);
			html.push(_tgc.itemim);
		} else {
			html.push("<i class='dhx_treegrid_icon fa fa-"+row.icon+"'></i>");
		}
		html.push(_tgc.itemne);
		html.push(row.label);
		html.push(_tgc.close);
		
                    

		this.cell.innerHTML=html.join("");
		this.cell._treeCell=true;
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[row.level];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[row.level+2];
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus") {
				this.grid._updateTGRState(row.parent,false);
				this.cell.parentNode._skipInsert=true;		
			}

		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
    
dhtmlXGridObject.prototype._process_tree_xml=function(top,pid){
	this._parsing=true;
	var main=false;
	if (!pid){
		this.render_row=this.render_row_tree;
		main=true;
		
		pid=top.getAttribute("parent")||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2= this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 

	var rows=dhx4.ajax.xpath(this.xml.row, top);
	this._open=this._open||[];
	for (var i=0; i < rows.length; i++) {
		var id=rows[i].getAttribute("id");
		if (!id) {
			id=this.uid();
			rows[i].setAttribute("id",id);
		}
		var row=this._h2.add(id,pid);
		row.buff={ idd:id, data:rows[i], _parser: this._process_xml_row, _locator:this._get_xml_data };
		if (rows[i].getAttribute("open")){
			row.state="minus";
			this._open.push(id);
		}
		
		this.rowsAr[id]=row.buff;
		this._process_tree_xml(rows[i],id);
	}
	if (main){ 
		if (!rows.length) this._h2.change(pid,"state",this._emptyLineImg);
		else if (pid!=0 && !this._srnd) {
			this._h2.change(pid,"state","minus");
		}
		for (var i=0; i < this._open.length; i++) {
			var r=this._h2.get[this._open[i]];
			if (!r.childs.length)
				r.state=this._emptyLineImg;
		};
		
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		if (pid!=0 && this._srnd) this.openItem(pid);
		else {
			if (this.pagingOn)
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this.kidsXmlFile){
			for (var i=0; i < this._open.length; i++) {
				var r=this._h2.get[this._open[i]];
				if (r._xml_await) 
					this.expandKids({idd:r.id});
			}
		}
		this._open=[];

		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
		if (pid!=0 && !this._srnd) {
		    this.callEvent("onOpenEnd",[pid,1]);
		}
	}
}	
dhtmlXGridObject.prototype._h2_to_buff=function(top){
	if (!top){
		top=this._h2.get[0];
		this.rowsBuffer = new dhtmlxArray();
		if (this._fake && !this._realfake) this._fake.rowsBuffer = this.rowsBuffer;
	}
	for (var i=0; i < top.childs.length; i++) {
		this.rowsBuffer.push(top.childs[i].buff);
		if (top.childs[i].state == "minus")
			this._h2_to_buff(top.childs[i]);
	}
};
dhtmlXGridObject.prototype.render_row_tree=function(ind,id){ 
	if (id){
		var r=this._h2.get[id];
		r=r?r.buff:r;
	} else
	var r=this.rowsBuffer[ind];
	if (!r) 
		return -1;
	
	if (r._parser){
		if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
			return this._h2.get[r.idd].buff=this.rowsBuffer[ind]=this.rowsAr[r.idd];
		var row=this._prepareRow(r.idd);
		this.rowsAr[r.idd]=row;

		if (!id)
			this.rowsBuffer[ind]=row;
		this._h2.get[r.idd].buff=row;	//treegrid specific
		
		r._parser.call(this,row,r.data);
		this._postRowProcessing(row);		
		
		return row;
		}
	return r;
}
    
    /**
    *   @desc: remove row from treegrid
    *   @param: node  - row object
    *   @type: private
    */
dhtmlXGridObject.prototype._removeTrGrRow=function(node,x){ 
		 if(x){
		     this._h2.forEachChild(x.id,function(x){
		     	this._removeTrGrRow(null,x);
	    		delete this.rowsAr[x.id];
    		},this);
    		return;
		 }
		 
		 var ind=this.getRowIndex(node.idd);
		 var x=this._h2.get[node.idd];
		 
		 
		 if (ind!=-1 && ind!==this.undefined){// in case of dnd we can receive delete command for some child item, which was not rendered yet
		 	var len=1;
		 	if (x && x.state=="minus") len+=this._getOpenLenght(x.id,0)
		 	for (var i=0; i<len; i++)
		 		if (this.rowsCol[i+ind])
            		this.rowsCol[i+ind].parentNode.removeChild(this.rowsCol[i+ind]);
            if (this._fake){
            	for (var i=0; i<len; i++)
            		if (this._fake.rowsCol[i+ind])
            			this._fake.rowsCol[i+ind].parentNode.removeChild(this._fake.rowsCol[i+ind]);
            	if (len>1)
            		this._fake.rowsCol.splice(ind+1,len-1);
        	}
            	
	         this.rowsCol.splice(ind,len);
	         this.rowsBuffer.splice(ind,len);
	         
	    }
	    
	    if (!x) return;
	    this._removeTrGrRow(null,x);
    		
    	delete this.rowsAr[x.id];
	
    	if (x.parent.childs.length==1){
    		this._h2.change(x.parent.id,"state",this._emptyLineImg);
    		this._updateTGRState(x.parent);
    	}
    	this._h2.remove(x.id);
      }




/**
*   @desc: expand row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.openItem=function(rowId){
		var y=this._h2.get[rowId||0];
        var x=this.getRowById(rowId||0);
		if (!x) return;
        if (y.parent && y.parent.id!=0)
        	this.openItem(y.parent.id);
        this.expandKids(x);
}

dhtmlXGridObject.prototype._addRowClassic=dhtmlXGridObject.prototype.addRow;

    /**
    *   @desc: add new row to treeGrid
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: ind  - position of row (set to null, for using parentId)
    *   @param: parent_id  - id of parent row
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRow=function(new_id,text,ind,parent_id,img,child){ 
	if (!this._h2) return this._addRowClassic(new_id,text,ind);
	parent_id=parent_id||0;
	var trcol=this.cellType._dhx_find("tree");
    if (typeof(text)=="string") text=text.split(this.delim);
    var row=this._h2.get[new_id];
    if (!row){
	    if (parent_id==0) ind=this.rowsBuffer.length;
	    else{
	    	ind=this.getRowIndex(parent_id)+1;
			if (this._h2.get[parent_id].state=="minus") 
				ind+=this._getOpenLenght(parent_id,0);
            else
				this._skipInsert=true;
            }
}
	row=row||this._h2.add(new_id,parent_id);
	row.image=img;
	row.has_kids=child;
    return row.buff=this._addRowClassic(new_id,text,ind);
}
    /**
    *   @desc: add new row to treeGrid, before some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowBefore=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id));
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	this._h2.addBefore(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,this._h2.get[sibl_id].parent.id,img,child);
}
    /**
    *   @desc: add new row to treeGrid, after some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowAfter=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id)+1);
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	if (this._h2.get[sibl_id].state=="minus") ind+=this._getOpenLenght(sibl_id,0)+1;	
	else	ind++;
	
	this._h2.addAfter(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,pid,img,child);
}





dhtmlXGridObject.prototype.enableSmartXMLParsing=function(mode) {
	this._slowParse=dhx4.s2b(mode);
};



    /**
    *   @desc: copy content between different rows
    *   @param: frRow  - source row object
    *   @param: from_row_id  - source row id
    *   @param: to_row_id  - target row id
    *   @type: private
    */
dhtmlXGridObject.prototype._copyTreeGridRowContent=function(frRow,from_row_id,to_row_id){
    var z=this.cellType._dhx_find("tree");
    for(i=0;i<frRow.cells.length;i++){
        if (i!=z)
           this.cells(to_row_id,i).setValue(this.cells(from_row_id,i).getValue())
        else
            this.cells(to_row_id,i).setValueA(this.cells(from_row_id,i).getValue())

    }
}

/**
*   @desc: collapse row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.closeItem=function(rowId){
        var x=this.getRowById(rowId);
        if (!x) return;
        this.collapseKids(x);
}
/**
*   @desc: delete all childs of row in question
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.deleteChildItems=function(rowId){
        var z=this._h2.get[rowId];
        if (!z) return;
        while (z.childs.length)
            this.deleteRow(z.childs[0].id);
            
}
/**
*   @desc: get list of id of all nested rows
*   @param: rowId - id of row
*   @type:  public
*   @returns: list of id of all nested rows
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getAllSubItems=function(rowId){
        var str=[];
        var z=this._h2.get[rowId||0];
        if (z)
        for (var i=0; i<z.childs.length; i++){
            str.push(z.childs[i].id);
            if (z.childs[i].childs.length)
            str=str.concat(this.getAllSubItems(z.childs[i].id).split(this.delim));
            }

        return str.join(this.delim);
}

/**
*   @desc: get id of child item at specified position
*   @param: rowId - id of row
*   @param: ind - child node index
*   @type:  public
*   @returns: id of child item at specified position
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getChildItemIdByIndex=function(rowId,ind){
		var z=this._h2.get[rowId||0];
        if (!z) return null;
        return (z.childs[ind]?z.childs[ind].id:null);
}

/**
*   @desc: get real caption of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: real caption of tree col
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemText=function(rowId){
        return this.cells(rowId,this.cellType._dhx_find("tree")).getLabel();
}

/**
*   @desc: return open/close state of row
*   @param: rowId - id of row
*   @type:  public
*   @returns: open/close state of row
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getOpenState=function(rowId){
        var z=this._h2.get[rowId||0];
        if (!z) return;
        if (z.state=="minus") return true;
        return false;
}
/**
*   @desc: return id of parent row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: id of parent row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getParentId=function(rowId){
        var z=this._h2.get[rowId||0];
        if ((!z) || (!z.parent)) return null;
        return z.parent.id;
}
/**
*   @desc: return list of child row id, sparated by comma
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: list of child rows
*   @topic: 7
*/
dhtmlXGridObject.prototype.getSubItems=function(rowId){
      var str=[];
      var z=this._h2.get[rowId||0];
      if (z)
      	for (var i=0; i<z.childs.length; i++)
      		str.push(z.childs[i].id);
      return str.join(this.delim);
}


/**
*   @desc: expand all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.expandAll=function(rowId){
	this._renderAllExpand(rowId||0);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}
	
dhtmlXGridObject.prototype._renderAllExpand=function(z){
	var x=this._h2.get[z].childs;
	for (var i=0; i<x.length; i++){
		if (x[i].childs.length){
			this._h2.change(x[i].id,"state","minus")
			this._updateTGRState(x[i]);
			this._renderAllExpand(x[i].id)
		}
	}
}
/**
*   @desc: collapse all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.collapseAll=function(rowId){
	this._h2.forEachChild((rowId||0),function(z){
		if (z && z.state=="minus"){
			z.state="plus";
			z.update=true;
			this._updateTGRState(z);
		}
	},this);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}

/**
*   @desc: return children count
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: children count
*   @topic: 7
*/
dhtmlXGridObject.prototype.hasChildren=function(rowId){
        var x=this._h2.get[rowId];
        if (x && x.childs.length) return x.childs.length;
        if (x._xml_await) return -1;
        return 0;
}


/**
*   @desc: enable/disable closing of row
*   @param: rowId - id of row
*   @param: status - true/false
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/

dhtmlXGridObject.prototype.setItemCloseable=function(rowId,status){
        var x=this._h2.get[rowId];
        if (!x) return;
        x._closeable=(!dhx4.s2b(status));
}
/**
*   @desc: set real caption of tree col
*   @param: rowId - id of row
*   @param: newtext - new text
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemText=function(rowId,newtext){
	return this.cells(rowId,this.cellType._dhx_find("tree")).setLabel(newtext);
}


/**
*   @desc: set image of tree col
*   @param: rowId - id of row
*   @param: url - image url
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemImage=function(rowId,url){
	this._h2.get[rowId].image=url; 
	this.rowsAr[rowId].imgTag.nextSibling.src=(this.iconURL||"")+url; 
}
dhtmlXGridObject.prototype.setItemIcon=function(rowId,icon){
	this._h2.get[rowId].icon = icon;
	this.rowsAr[rowId].imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
}

/**
*   @desc: get image of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemImage=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].image;  
}
dhtmlXGridObject.prototype.getItemIcon=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].icon;
}


/**
*   @desc: set size of treegrid images
*   @param: width -  width of image
*   @param: height - height of image
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setImageSize=function(width,height){
        this._img_width=width;
        this._img_height=height;
}


dhtmlXGridObject.prototype._getRowImage=function(row){
	return this._h2.get[row.idd].image;    
        }


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenStart
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXGridObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func); };
   
/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenEnd
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*/
   dhtmlXGridObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);   };


    /**
*     @desc: enable/disable editor of tree cell ; enabled by default
*     @param: mode -  (boolean) true/false
*     @type: public
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableTreeCellEdit=function(mode){
        this._edtc=!dhx4.s2b(mode);
    };



/**
*   @desc: return level of treeGrid row
*   @param: rowId - id of row
*   @type:  public
*   @returns: level of treeGrid row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getLevel=function(rowId){      
        var z=this._h2.get[rowId||0];
        if (!z) return -1;
        return z.level;
}

dhtmlXGridObject.prototype._fixHiddenRowsAllTG=function(ind,state){
  for (i in this.rowsAr){
     if ((this.rowsAr[i])&&(this.rowsAr[i].childNodes))
        this.rowsAr[i].childNodes[ind].style.display=state;
  }
}
//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._updateLine=function(z,row){ 
	row=row||this.rowsAr[z.id];
	if (!row) return;
	var im=row.imgTag;
	if (!im) return;
	if (z.state=="blank") return im.src=this.iconTree+"blank.gif";
	
		var n=1;
		if (z.index==0){
			if (z.level==0){
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else n=1;
			}
			else
			{
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else
					n=2;
			}
		}
		else
			if ((z.parent.childs.length-1)>z.index)
				n=3;
			else
				n=2;
			
		
		im.src=this.iconTree+z.state+n+".gif";
}
dhtmlXGridObject.prototype._updateParentLine=function(z,row){
		row=row||this.rowsAr[z.id];
		if (!row) return;
		var im=row.imgTag;
		if (!im) return;
		for (var i=z.level; i>0; i--){
			if (z.id==0) break;
			im=im.previousSibling;
			z=z.parent;
			if ((z.parent.childs.length-1)>z.index)
				im.src=this.iconTree+"line1.gif";
			else
				im.src=this.iconTree+"blank.gif";
		}
}

dhtmlXGridObject.prototype._renderSortA=dhtmlXGridObject.prototype._renderSort;
dhtmlXGridObject.prototype._renderSort=function(){
	this._renderSortA.apply(this,arguments);
	this._redrawLines(0)	
} 
dhtmlXGridObject.prototype._redrawLines=function(id){
		if (this._tgle)
			this._h2.forEachChild((id||0),function(z){
					this._updateLine(z);
					this._updateParentLine(z);
			},this);
	}
/**
*   @desc: enable lines in treeGrid 
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableTreeGridLines=function(){
	this._emptyLineImg="line";

	
	this._updateTGRState=function(z,force){ 
		if (force || !z.update || z.id==0) return;
		if (this._tgle)
			this._updateLine(z,this.rowsAr[z.id]);
		z.update=false;
	}

	this._tgle=true;
	this.attachEvent("onXLE",function(a,b,id){
		this._redrawLines(id)
	});    
	
	this.attachEvent("onOpenEnd",function(id){
		this._redrawLines(id)
	});    
	
	
	this.attachEvent("onRowAdded",function(id){ 
		var z=this._h2.get[id];
		this._updateLine(z); 
		this._updateParentLine(z);
		if (z.index<(z.parent.childs.length-1)){
			z=z.parent.childs[z.index+1];
			this._updateLine(z);
			this._updateParentLine(z);
		}
		else if (z.index!=0){
			z=z.parent.childs[z.index-1];
			this._updateLine(z);
			this._updateParentLine(z);
			if (z.childs.length)
				this._h2.forEachChild(z.id,function(c_el){
					this._updateParentLine(c_el)
				},this)
		}
	});
	this.attachEvent("onOpen",function(id,state){ 
		if (state){ 
			var z=this._h2.get[id];
			for (var i=0; i < z.childs.length; i++) 
				this._updateParentLine(z.childs[i]);
		}
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		var self=this;
		var z=this._h2.get[id];
		var w=null;
		if (z.index!=0)
			w=z.parent.childs[z.index-1];
		z=z.parent;
			
		window.setTimeout(function(){
			z  = self._h2.get[z.id];
			if (!z) return;
						
			self._updateLine(z);
			self._updateParentLine(z);
			
			if (w){
				self._updateLine(w);
				if (w.state=="minus")
				self._h2.forEachChild(w.id,function(z){
					self._updateParentLine(z);
				},self);
			}
		},1);
		return true;
	});
} 

//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//beware that function started from _in_header_ must not be obfuscated


/**
*   @desc: allows to define , which level of tree must be used for filtering
*   @type: public
*   @param: level - level value, -1 value means last one
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFiltrationLevel=function(level,show_lower,show_upper){
	this._tr_strfltr=level;
	this._tr_fltr_c=show_lower;
	this._tr_fltr_d=show_upper;
	this.refreshFilters();
}


/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterTreeBy=function(column, value, preserve){
	var origin = this._h2;
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	if (this._f_rowsBuffer){
		if (!preserve){
			this._h2=this._f_rowsBuffer;
			if (this._fake) this._fake._h2=this._h2;
		}
	} else
		this._f_rowsBuffer=this._h2;	//backup copy
	
	//if (!this.rowsBuffer.length && preserve) return;
	var d=true;
	this.dma(true)
	this._fbf={};
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterTreeA(column[j],value[j]);
	else
			this._filterTreeA(column,value);
	this._fbf=null;
	this.dma(false)
	this._fix_filtered_images(this._h2,origin);
	this._renderSort()
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterTreeA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	
	var add_line=function(el,s,t){
			var z=t.get[el.parent.id];
			if (!z) z=add_line(el.parent,s,t)
			var t=temp.get[el.id];
			if (!t){
				t={id:el.id, childs:[], level:el.level, parent:z, index:z.childs.length, image:el.image, state:el.state, buff:el.buff, has_kids:el.has_kids, _xml_await:el._xml_await};
			z.childs.push(t);
			temp.get[t.id]=t;
			}
			return t;
	}
	var fbf=this._fbf;
	var temp = this._createHierarchy();
	var check; 
	var mode = this._tr_strfltr;
	var that=this;	
	var temp_c=function(el){
		for (var i=0; i < el.childs.length; i++) 
			that.temp(el.childs[i]);
	}
	switch(mode.toString()){
		case "-2": check=function(el){ if (fbf[el.id]) return false; temp_c(el); return true;}; break;
		case "-1": check=function(el){return !el.childs.length;}; break;
		default: check=function(el){return mode==el.level}; break;
	}
	this.temp=function(el){
		if (el.id!=0 && check(el)){
			if (d?(this._get_cell_value(el.buff,column).toString().toLowerCase().indexOf(value)==-1):(!value(this._get_cell_value(el.buff,column),el.id))){
				fbf[el.id]=true;
				if (this._tr_fltr_c) add_line(el.parent,this._h2,temp);
				return false;
			} else {
				add_line(el,this._h2,temp);
				if (el.childs && mode!=-2)
					this._h2.forEachChild(el.id,function(cel){
						add_line(cel,this._h2,temp);
					},this)
				return true;
			}
		} else {
			if (this._tr_fltr_d && this._tr_strfltr > el.level && el.id!=0) add_line(el,this._h2,temp);
			temp_c(el);
		}
	}

	
	this.temp(this._h2.get[0]);
	this._h2=temp;	
	if (this._fake) this._fake._h2=this._h2;
}

dhtmlXGridObject.prototype._fix_filtered_images=function(temp,origin){
		temp.forEachChild(0,function(el){
		if (!el.childs.length && !el.has_kids){
			if (el.state!=this._emptyLineImg){
				el.state=this._emptyLineImg;
				el.update=true;
				this._updateTGRState(el);
			}
		} else {
			if (el.buff.tagName=="TR"){
				var prev=origin.get[el.id];
				if (prev && prev.state!=this._emptyLineImg)
					el.state=prev.state;
				el.update=true;
				this._updateTGRState(el);
			}
		}
	},this)
}
/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectTreeValues=function(column){
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	this.dma(true)
	this._build_m_order();		
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this._h2;
	col.forEachChild(0,function(el){
		if (this._tr_strfltr==-2 || (this._tr_strfltr==-1 && !el.childs.length) || (this._tr_strfltr==el.level)){
			var val=this._get_cell_value(el.buff,column);
			if (val) c[val]=true;
    	}
	},this);
	this.dma(false)
	
	var vals=this.combos[column];
	for (var d in c) 
		if (c[d]===true) f.push(vals?(vals.get(d)||d):d);
	
	return f.sort();			
}




dhtmlXGridObject.prototype._in_header_stat_tree_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_total_leaf=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total_leaf=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max_leaf=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min_leaf=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average_leaf=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count_leaf=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			if (!el.childs.length) count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
//	if (this._realfake) return this._fake._stat_in_header(t,calck,i,c);
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ind==i) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}
dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}


//(c)dhtmlx ltd. www.dhtmlx.com


/*
Product Name: dhtmlxTreeGrid 
Version: 5.0.2 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

if(!window.dhtmlx)
	window.dhtmlx = {};

(function(){
	var _dhx_msg_cfg = null;
	function callback(config, result){
			var usercall = config.callback;
			modality(false);
			config.box.parentNode.removeChild(config.box);
			_dhx_msg_cfg = config.box = null;
			if (usercall)
				usercall(result);
	}
	function modal_key(e){
		if (_dhx_msg_cfg){
			e = e||event;
			var code = e.which||event.keyCode;
			if (dhtmlx.message.keyboard){
				if (code == 13 || code == 32)
					callback(_dhx_msg_cfg, true);
				if (code == 27)
					callback(_dhx_msg_cfg, false);
			}
			if (e.preventDefault)
				e.preventDefault();
			return !(e.cancelBubble = true);
		}
	}
	if (document.attachEvent)
		document.attachEvent("onkeydown", modal_key);
	else
		document.addEventListener("keydown", modal_key, true);
		
	function modality(mode){
		if(!modality.cover){
			modality.cover = document.createElement("DIV");
			//necessary for IE only
			modality.cover.onkeydown = modal_key;
			modality.cover.className = "dhx_modal_cover";
			document.body.appendChild(modality.cover);
		}
		var height =  document.body.scrollHeight;
		modality.cover.style.display = mode?"inline-block":"none";
	}

	function button(text, result){
		return "<div class='dhtmlx_popup_button' result='"+result+"' ><div>"+text+"</div></div>";
	}

	function info(text){
		if (!t.area){
			t.area = document.createElement("DIV");
			t.area.className = "dhtmlx_message_area";
			t.area.style[t.position]="15px";
			document.body.appendChild(t.area);
		}

		t.hide(text.id);
		var message = document.createElement("DIV");
		message.innerHTML = "<div>"+text.text+"</div>";
		message.className = "dhtmlx-info dhtmlx-" + text.type;
		message.onclick = function(){
			if (text) t.hide(text.id);
			text = null;
		};

		if (t.position == "bottom" && t.area.firstChild)
			t.area.insertBefore(message,t.area.firstChild);
		else
			t.area.appendChild(message);
		
		if (text.expire > 0)
			t.timers[text.id]=window.setTimeout(function(){
				t.hide(text.id);
			}, text.expire);

		t.pull[text.id] = message;
		message = null;

		return text.id;
	}
	function _boxStructure(config, ok, cancel){
		var box = document.createElement("DIV");
		box.className = " dhtmlx_modal_box dhtmlx-"+config.type;
		box.setAttribute("dhxbox", 1);
			
		var inner = '';

		if (config.width)
			box.style.width = config.width;
		if (config.height)
			box.style.height = config.height;
		if (config.title)
			inner+='<div class="dhtmlx_popup_title">'+config.title+'</div>';
		inner+='<div class="dhtmlx_popup_text"><span>'+(config.content?'':config.text)+'</span></div><div  class="dhtmlx_popup_controls">';
		if (ok)
			inner += button(config.ok || "OK", true);
		if (cancel)
			inner += button(config.cancel || "Cancel", false);
		if (config.buttons){
			for (var i=0; i<config.buttons.length; i++)
				inner += button(config.buttons[i],i);
		}
		inner += '</div>';
		box.innerHTML = inner;

		if (config.content){
			var node = config.content;
			if (typeof node == "string") 
				node = document.getElementById(node);
			if (node.style.display == 'none')
				node.style.display = "";
			box.childNodes[config.title?1:0].appendChild(node);
		}

		box.onclick = function(e){
			e = e ||event;
			var source = e.target || e.srcElement;
			if (!source.className) source = source.parentNode;
			if (source.className == "dhtmlx_popup_button"){
				var result = source.getAttribute("result");
				result = (result == "true")||(result == "false"?false:result);
				callback(config, result);
			}
		};
		config.box = box;
		if (ok||cancel)
			_dhx_msg_cfg = config;

		return box;
	}
	function _createBox(config, ok, cancel){
		var box = config.tagName ? config : _boxStructure(config, ok, cancel);
		
		if (!config.hidden)
			modality(true);
		document.body.appendChild(box);
		var x = config.left||Math.abs(Math.floor(((window.innerWidth||document.documentElement.offsetWidth) - box.offsetWidth)/2));
		var y = config.top||Math.abs(Math.floor(((window.innerHeight||document.documentElement.offsetHeight) - box.offsetHeight)/2));
		if (config.position == "top")
			box.style.top = "-3px";
		else
			box.style.top = y+'px';
		box.style.left = x+'px';
		//necessary for IE only
		box.onkeydown = modal_key;

		box.focus();
		if (config.hidden)
			dhtmlx.modalbox.hide(box);

		return box;
	}

	function alertPopup(config){
		return _createBox(config, true, false);
	}
	function confirmPopup(config){
		return _createBox(config, true, true);
	}
	function boxPopup(config){
		return _createBox(config);
	}
	function box_params(text, type, callback){
		if (typeof text != "object"){
			if (typeof type == "function"){
				callback = type;
				type = "";
			}
			text = {text:text, type:type, callback:callback };
		}
		return text;
	}
	function params(text, type, expire, id){
		if (typeof text != "object" || !text)
			text = {text:text, type:type, expire:expire, id:id};
		text.id = text.id||t.uid();
		text.expire = text.expire||t.expire;
		return text;
	}
	dhtmlx.alert = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "confirm";
		return alertPopup(text);
	};
	dhtmlx.confirm = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return confirmPopup(text);
	};
	dhtmlx.modalbox = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return boxPopup(text);
	};
	dhtmlx.modalbox.hide = function(node){
		while (node && node.getAttribute && !node.getAttribute("dhxbox"))
			node = node.parentNode;
		if (node){
			node.parentNode.removeChild(node);
			modality(false);
			_dhx_msg_cfg = null;
		}
	};
	var t = dhtmlx.message = function(text, type, expire, id){
		text = params.apply(this, arguments);
		text.type = text.type||"info";

		var subtype = text.type.split("-")[0];
		switch (subtype){
			case "alert":
				return alertPopup(text);
			case "confirm":
				return confirmPopup(text);
			case "modalbox":
				return boxPopup(text);
			default:
				return info(text);
			break;
		}
	};

	t.seed = (new Date()).valueOf();
	t.uid = function(){return t.seed++;};
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function(){
		for (var key in t.pull)
			t.hide(key);
	};
	t.hide = function(id){
		var obj = t.pull[id];
		if (obj && obj.parentNode){
			window.setTimeout(function(){
				obj.parentNode.removeChild(obj);
				obj = null;
			},2000);
			obj.className+=" hidden";
			
			if(t.timers[id])
				window.clearTimeout(t.timers[id]);
			delete t.pull[id];
		}
	};
})();

